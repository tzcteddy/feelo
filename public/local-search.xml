<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>动画与过渡</title>
    <link href="/2024/06/06/frontendGuide/vue3Advanced/animation/"/>
    <url>/2024/06/06/frontendGuide/vue3Advanced/animation/</url>
    
    <content type="html"><![CDATA[<h2 id="动画与过渡"><a href="#动画与过渡" class="headerlink" title="动画与过渡"></a>动画与过渡</h2><p>在 Vue 3 中，动画和过渡是创建用户友好界面的重要部分。Vue 提供了强大的工具来实现元素的过渡和动画效果。本文将介绍过渡的基本使用、使用 Transition 组件以及动画的高级用法。</p><h3 id="过渡的基本使用"><a href="#过渡的基本使用" class="headerlink" title="过渡的基本使用"></a>过渡的基本使用</h3><p>过渡效果主要用于元素的插入、更新和移除。当元素状态发生变化时，可以通过过渡效果为用户提供视觉反馈。Vue 提供了简单的方式来实现这些效果。</p><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>通过 <code>v-if</code> 或 <code>v-show</code> 指令结合 <code>transition</code> 组件，可以轻松实现元素的过渡效果。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;show = !show&quot;</span>&gt;</span>Toggle<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Transition</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;show&quot;</span>&gt;</span>hello<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">Transition</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> show = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>);</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123; show &#125;;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.v-enter-active</span>,</span><br><span class="language-css">  <span class="hljs-selector-class">.v-leave-active</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">transition</span>: opacity <span class="hljs-number">0.5s</span> ease;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.v-enter-from</span>,</span><br><span class="language-css">  <span class="hljs-selector-class">.v-leave-to</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="CSS-过渡-class"><a href="#CSS-过渡-class" class="headerlink" title="CSS 过渡 class"></a>CSS 过渡 class</h4><p><img src="/../../../img/transition.png" alt="css 过渡 class"></p><p>1、v-enter-from：进入动画的起始状态。在元素插入之前添加，在元素插入完成后的下一帧移除。</p><p>2、v-enter-active：进入动画的生效状态。应用于整个进入动画阶段。在元素被插入之前添加，在过渡或动画完成之后移除。这个 class 可以被用来定义进入动画的持续时间、延迟与速度曲线类型。</p><p>3、v-enter-to：进入动画的结束状态。在元素插入完成后的下一帧被添加 (也就是 v-enter-from 被移除的同时)，在过渡或动画完成之后移除。</p><p>4、v-leave-from：离开动画的起始状态。在离开过渡效果被触发时立即添加，在一帧后被移除。</p><p>5、v-leave-active：离开动画的生效状态。应用于整个离开动画阶段。在离开过渡效果被触发时立即添加，在过渡或动画完成之后移除。这个 class 可以被用来定义离开动画的持续时间、延迟与速度曲线类型。</p><p>6、v-leave-to：离开动画的结束状态。在一个离开动画被触发后的下一帧被添加 (也就是 v-leave-from 被移除的同时)，在过渡或动画完成之后移除。</p><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p><code>&lt;transition&gt;</code> 组件接受以下几个属性：</p><ul><li><code>name</code>：指定过渡效果的类名前缀。</li><li><code>mode</code>：定义过渡模式（<code>in-out</code>、<code>out-in</code>）。</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;toggle&quot;</span>&gt;</span>Toggle<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">transition</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;slide-fade&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;show&quot;</span>&gt;</span>Sliding and Fading in Vue 3!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> show = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>);</span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> <span class="hljs-title function_">toggle</span> = (<span class="hljs-params"></span>) =&gt; (show.<span class="hljs-property">value</span> = !show.<span class="hljs-property">value</span>);</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123; show, toggle &#125;;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.slide-fade-enter-active</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">transition</span>: all <span class="hljs-number">0.5s</span> ease;</span><br><span class="language-css">  &#125;</span><br><span class="language-css">  <span class="hljs-selector-class">.slide-fade-leave-active</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">transition</span>: all <span class="hljs-number">0.5s</span> ease;</span><br><span class="language-css">  &#125;</span><br><span class="language-css">  <span class="hljs-selector-class">.slide-fade-enter-from</span>, <span class="hljs-selector-class">.slide-fade-leave-to</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">10px</span>);</span><br><span class="language-css">    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="动画的高级用法"><a href="#动画的高级用法" class="headerlink" title="动画的高级用法"></a>动画的高级用法</h3><p>高级动画使用包括自定义过渡类名、JavaScript 钩子函数、使用第三方动画库、动画组 (Transition Group) 和动态过渡等。</p><h4 id="自定义过渡类名"><a href="#自定义过渡类名" class="headerlink" title="自定义过渡类名"></a>自定义过渡类名</h4><p>你可以通过 <code>&lt;transition&gt;</code> 组件的 <code>enter-active-class</code> 和 <code>leave-active-class</code> 属性自定义过渡类名。传入的这些 class 会覆盖相应阶段的默认 class 名。这个功能在你想要在 Vue 的动画机制下集成其他的第三方 CSS 动画库时非常有用，比如 Animate.css：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;toggle&quot;</span>&gt;</span>Toggle<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">transition</span></span><br><span class="hljs-tag">      <span class="hljs-attr">enter-active-class</span>=<span class="hljs-string">&quot;animate__animated animate__fadeIn&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">leave-active-class</span>=<span class="hljs-string">&quot;animate__animated animate__fadeOut&quot;</span></span><br><span class="hljs-tag">    &gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;show&quot;</span>&gt;</span>Custom Transition Classes<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> show = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>);</span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> <span class="hljs-title function_">toggle</span> = (<span class="hljs-params"></span>) =&gt; (show.<span class="hljs-property">value</span> = !show.<span class="hljs-property">value</span>);</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123; show, toggle &#125;;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="JavaScript-钩子函数"><a href="#JavaScript-钩子函数" class="headerlink" title="JavaScript 钩子函数"></a>JavaScript 钩子函数</h4><p>Vue 提供了 JavaScript 钩子函数，使得在过渡过程中执行自定义的 JavaScript 逻辑成为可能。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> gsap <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;gsap&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> show = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">onBeforeEnter</span>(<span class="hljs-params">el</span>) &#123;</span><br><span class="language-javascript">  gsap.<span class="hljs-title function_">set</span>(el, &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">scaleX</span>: <span class="hljs-number">0.25</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">scaleY</span>: <span class="hljs-number">0.25</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">opacity</span>: <span class="hljs-number">1</span></span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">  </span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">onEnter</span>(<span class="hljs-params">el, done</span>) &#123;</span><br><span class="language-javascript">  gsap.<span class="hljs-title function_">to</span>(el, &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">duration</span>: <span class="hljs-number">1</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">scaleX</span>: <span class="hljs-number">1</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">scaleY</span>: <span class="hljs-number">1</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">opacity</span>: <span class="hljs-number">1</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">ease</span>: <span class="hljs-string">&#x27;elastic.inOut(2.5, 1)&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">onComplete</span>: done</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">onLeave</span>(<span class="hljs-params">el, done</span>) &#123;</span><br><span class="language-javascript">gsap.<span class="hljs-title function_">to</span>(el, &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">duration</span>: <span class="hljs-number">0.7</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">scaleX</span>: <span class="hljs-number">1</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">scaleY</span>: <span class="hljs-number">1</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">x</span>: <span class="hljs-number">300</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">ease</span>: <span class="hljs-string">&#x27;elastic.inOut(2.5, 1)&#x27;</span></span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript">  gsap.<span class="hljs-title function_">to</span>(el, &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">duration</span>: <span class="hljs-number">0.2</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">delay</span>: <span class="hljs-number">0.5</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">opacity</span>: <span class="hljs-number">0</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">onComplete</span>: done</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;show = !show&quot;</span>&gt;</span>Toggle<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Transition</span></span><br><span class="hljs-tag">    @<span class="hljs-attr">before-enter</span>=<span class="hljs-string">&quot;onBeforeEnter&quot;</span></span><br><span class="hljs-tag">    @<span class="hljs-attr">enter</span>=<span class="hljs-string">&quot;onEnter&quot;</span></span><br><span class="hljs-tag">    @<span class="hljs-attr">leave</span>=<span class="hljs-string">&quot;onLeave&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">:css</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">  &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;gsap-box&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;show&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">Transition</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.gsap-box</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">background</span>: <span class="hljs-number">#42b883</span>;</span><br><span class="language-css">  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">  <span class="hljs-attribute">width</span>: <span class="hljs-number">30px</span>;</span><br><span class="language-css">  <span class="hljs-attribute">height</span>: <span class="hljs-number">30px</span>;</span><br><span class="language-css">  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">50%</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在使用仅由 JavaScript 执行的动画时，最好是添加一个 :css&#x3D;”false” prop。这显式地向 Vue 表明可以跳过对 CSS 过渡的自动探测。除了性能稍好一些之外，还可以防止 CSS 规则意外地干扰过渡效果。在有了 :css&#x3D;”false” 后，我们就自己全权负责控制什么时候过渡结束了。</p><h4 id="动态过渡"><a href="#动态过渡" class="headerlink" title="动态过渡"></a>动态过渡</h4><p>可以根据条件动态设置过渡效果。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;toggle&quot;</span>&gt;</span>Toggle<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>&#123;&#123; transitionName &#125;&#125;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">transition</span> <span class="hljs-attr">:name</span>=<span class="hljs-string">&quot;transitionName&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;show&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span>Dynamic Transition<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">transition</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> show = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">true</span>);</span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> transitionName = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;fade&#x27;</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> <span class="hljs-title function_">toggle</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">        show.<span class="hljs-property">value</span> = !show.<span class="hljs-property">value</span>;</span><br><span class="language-javascript">        transitionName.<span class="hljs-property">value</span> = show.<span class="hljs-property">value</span> ? <span class="hljs-string">&#x27;fade&#x27;</span> : <span class="hljs-string">&#x27;slide&#x27;</span>;</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123; show, transitionName, toggle &#125;;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.fade-enter-active</span>,</span><br><span class="language-css">  <span class="hljs-selector-class">.fade-leave-active</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">transition</span>: opacity <span class="hljs-number">3s</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css">  <span class="hljs-selector-class">.fade-enter-from</span>,</span><br><span class="language-css">  <span class="hljs-selector-class">.fade-leave-to</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0.5</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.slide-enter-active</span>,</span><br><span class="language-css">  <span class="hljs-selector-class">.slide-leave-active</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">transition</span>: transform <span class="hljs-number">1s</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css">  <span class="hljs-selector-class">.slide-enter-from</span>,</span><br><span class="language-css">  <span class="hljs-selector-class">.slide-leave-to</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateY</span>(<span class="hljs-number">30px</span>);</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="动画组-Transition-Group"><a href="#动画组-Transition-Group" class="headerlink" title="动画组 (Transition Group)"></a>动画组 (Transition Group)</h4><p><code>&lt;transition-group&gt;</code> 用于为列表中的多个元素应用过渡效果。可以实现列表的插入、删除和移动动画。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;addItem&quot;</span>&gt;</span>Add Item<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">transition-group</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;list&quot;</span> <span class="hljs-attr">tag</span>=<span class="hljs-string">&quot;ul&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in items&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list-item&quot;</span>&gt;</span>&#123;&#123; item &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">transition-group</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> items = <span class="hljs-title function_">ref</span>([<span class="hljs-string">&#x27;Item 1&#x27;</span>, <span class="hljs-string">&#x27;Item 2&#x27;</span>, <span class="hljs-string">&#x27;Item 3&#x27;</span>]);</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> <span class="hljs-title function_">addItem</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">        items.<span class="hljs-property">value</span>.<span class="hljs-title function_">push</span>(<span class="hljs-string">`Item <span class="hljs-subst">$&#123;items.value.length + <span class="hljs-number">1</span>&#125;</span>`</span>);</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123; items, addItem &#125;;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.list-enter-active</span>,</span><br><span class="language-css">  <span class="hljs-selector-class">.list-leave-active</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">transition</span>: all <span class="hljs-number">0.5s</span> ease;</span><br><span class="language-css">  &#125;</span><br><span class="language-css">  <span class="hljs-selector-class">.list-enter-from</span>,</span><br><span class="language-css">  <span class="hljs-selector-class">.list-leave-to</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>;</span><br><span class="language-css">    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translateX</span>(<span class="hljs-number">30px</span>);</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p><TransitionGroup> 支持和 <Transition> 基本相同的 props、CSS 过渡 class 和 JavaScript 钩子监听器，但有以下几点区别：</p><ul><li>默认情况下，它不会渲染一个容器元素。但你可以通过传入 tag prop 来指定一个元素作为容器元素来渲染。</li><li>过渡模式在这里不可用，因为我们不再是在互斥的元素之间进行切换。</li><li>列表中的每个元素都必须有一个独一无二的 key attribute。</li><li>CSS 过渡 class 会被应用在列表内的元素上，而不是容器元素上</li></ul><p>通过以上内容，您可以在 Vue 3 中实现从简单到复杂的动画和过渡效果，使应用更加生动和吸引用户。</p>]]></content>
    
    
    <categories>
      
      <category>前端开发手册</category>
      
      <category>进阶奇妙旅程：解锁 Vue3 的高级魔法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
      <tag>vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基础知识</title>
    <link href="/2024/06/06/frontendGuide/vue3/basic/"/>
    <url>/2024/06/06/frontendGuide/vue3/basic/</url>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="Vue-3-的基本概念"><a href="#Vue-3-的基本概念" class="headerlink" title="Vue 3 的基本概念"></a>Vue 3 的基本概念</h2><p>Vue.js 是一个用于构建用户界面的渐进式框架，核心库只关注视图层。Vue 3 是 Vue.js 的最新版本，具备更好的性能和改进的开发体验。Vue 3 引入了 Composition API，支持更灵活的代码组织方式。Vue 3 相比 Vue 2 在性能、源码体积和 TypeScript 支持等方面都有显著提升。</p><h2 id="项目初始化与配置"><a href="#项目初始化与配置" class="headerlink" title="项目初始化与配置"></a>项目初始化与配置</h2><h3 id="1-创建-Vue-3-项目"><a href="#1-创建-Vue-3-项目" class="headerlink" title="1. 创建 Vue 3 项目"></a>1. 创建 Vue 3 项目</h3><p>在开始使用 Vue 3 之前，我们需要创建一个新的 Vue 3 项目。可以使用 Vite 来快速初始化项目。Vite 是一个新型的前端构建工具，具有快速、轻量的特点，非常适合用于 Vue 3 项目。</p><h4 id="Vite"><a href="#Vite" class="headerlink" title="Vite"></a>Vite</h4><p>Vite（法语意为 “快速的”，发音 &#x2F;vit&#x2F;，发音同 “veet”）是一种新型前端构建工具，旨在显著提升前端开发体验。它主要由两部分组成：</p><ol><li><strong>开发服务器</strong>：基于原生 ES 模块，提供了丰富的内建功能，如速度极快的模块热更新（HMR）。</li><li><strong>构建指令</strong>：使用 Rollup 打包代码，并预配置以输出高度优化的静态资源 ¹²。</li></ol><h4 id="创建新项目"><a href="#创建新项目" class="headerlink" title="创建新项目"></a>创建新项目</h4><p>使用 Vite 创建一个新的 Vue 3 项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm create vite@latest<br></code></pre></td></tr></table></figure><h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><p>进入项目目录并安装依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> vue3-demo<br>npm install<br></code></pre></td></tr></table></figure><h4 id="启动开发服务器"><a href="#启动开发服务器" class="headerlink" title="启动开发服务器"></a>启动开发服务器</h4><p>使用以下命令启动开发服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm run dev<br></code></pre></td></tr></table></figure><p>开发服务器启动后，你可以在浏览器中访问 <code>http://localhost:5173</code> 查看你的 Vue 3 项目。</p><h3 id="2-项目配置"><a href="#2-项目配置" class="headerlink" title="2. 项目配置"></a>2. 项目配置</h3><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>Vite 的主要配置文件是 <code>vite.config.js</code>。这是一个 JavaScript 模块，你可以在其中导出一个配置对象。默认的配置如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span>;<br><span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@vitejs/plugin-vue&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">vue</span>()],<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="路径别名"><a href="#路径别名" class="headerlink" title="路径别名"></a>路径别名</h4><p>你可以在 <code>vite.config.js</code> 中配置路径别名。例如，将 <code>@</code> 指向 <code>src</code> 目录：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span>;<br><span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@vitejs/plugin-vue&#x27;</span>;<br><span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;path&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">vue</span>()],<br>  <span class="hljs-attr">resolve</span>: &#123;<br>    <span class="hljs-attr">alias</span>: &#123;<br>      <span class="hljs-string">&#x27;@&#x27;</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;./src&#x27;</span>),<br>    &#125;,<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// App.vue</span><br><span class="hljs-comment">// import HelloWorld from &#x27;./components/HelloWorld.vue&#x27;;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">HelloWorld</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/HelloWorld.vue&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>Vite 支持使用 <code>.env</code> 文件来配置环境变量。在项目根目录下创建 <code>.env</code> 文件，并在其中定义变量：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">VITE_APP_TITLE</span>=My Vue <span class="hljs-number">3</span> Project<br></code></pre></td></tr></table></figure><p>在代码中使用这些变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// App.vue</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">import</span>.<span class="hljs-property">meta</span>.<span class="hljs-property">env</span>.<span class="hljs-property">VITE_APP_TITLE</span>);<br></code></pre></td></tr></table></figure><h4 id="代理配置"><a href="#代理配置" class="headerlink" title="代理配置"></a>代理配置</h4><p>如果你需要在开发环境中代理 API 请求，可以在 <code>vite.config.js</code> 中配置代理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 示例：ProxyDemo.vue</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">vue</span>()],<br>  <span class="hljs-attr">server</span>: &#123;<br>    <span class="hljs-attr">proxy</span>: &#123;<br>      <span class="hljs-string">&#x27;/api/mock&#x27;</span>: &#123;<br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com&#x27;</span>,<br>        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">rewrite</span>: <span class="hljs-function">(<span class="hljs-params">path</span>) =&gt;</span> path.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^\/api\/mock/</span>, <span class="hljs-string">&#x27;&#x27;</span>),<br>      &#125;,<br>    &#125;,<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>这样，当你在开发环境中发送到 <code>/api</code> 的请求会被代理到 <code>http://backend-api</code>。</p><h4 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h4><p>你可以根据项目需求，在 <code>vite.config.js</code> 中添加更多配置。例如，配置 CSS 预处理器、静态资源处理等。</p><p>更多详细配置可以参考 <a href="https://vitejs.dev/config/">Vite 官方文档</a>。</p><h3 id="3-项目结构"><a href="#3-项目结构" class="headerlink" title="3. 项目结构"></a>3. 项目结构</h3><p>一个典型的 Vue 3 项目结构如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stylus">vue3-demo/<br>├── public/         -- 公共目录，文件打包后原封不动放在根目录下面<br>│   └── favicon<span class="hljs-selector-class">.ico</span><br>├── <span class="hljs-attribute">src</span>/<br>│   ├── assets/     -- 存放静态资源，例如图片、字体等<br>│   ├── components/ -- 存放 Vue 组件<br>│   ├── views/      -- 存放视图组件，一般与路由对应<br>│   ├── App<span class="hljs-selector-class">.vue</span>     -- 根组件<br>│   ├── <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.js</span>     -- 应用入口文件<br>│   └── router<span class="hljs-selector-class">.js</span>   -- 路由配置文件<br>├── <span class="hljs-selector-class">.gitignore</span><br>├── index<span class="hljs-selector-class">.html</span><br>├── package<span class="hljs-selector-class">.json</span><br>├── README<span class="hljs-selector-class">.md</span><br>└── vite<span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.js</span>  -- vite 配置文件<br></code></pre></td></tr></table></figure><p>通过以上步骤，你已经成功初始化并配置了一个使用 Vite 的 Vue 3 项目。接下来，你可以根据项目需求继续开发。</p><h2 id="模版语法"><a href="#模版语法" class="headerlink" title="模版语法"></a>模版语法</h2><h3 id="插值"><a href="#插值" class="headerlink" title="插值"></a>插值</h3><p>插值（Interpolation）是 Vue 模版语法中最基础的部分。通过插值语法，可以在模版中展示数据。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>&#123;&#123; message &#125;&#125;</code> 会被替换为 Vue 实例中 <code>message</code> 属性的值。</p><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><p>指令（Directives）是带有 <code>v-</code> 前缀的特殊属性，用于在模版中绑定行为。常用指令包括 <code>v-bind</code>、<code>v-model</code> 和 <code>v-for</code>。</p><h4 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h4><p><code>v-bind</code> 指令用于绑定 HTML 属性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:href</span>=<span class="hljs-string">&quot;url&quot;</span>&gt;</span>点击这里<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h4><p><code>v-model</code> 指令用于创建双向数据绑定。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;输入一些文字&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><h4 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h4><p><code>v-for</code> 指令用于渲染一个列表。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in items&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span>&#123;&#123; item.text &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h3><p>条件渲染使用 <code>v-if</code> 和 <code>v-show</code> 指令。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;seen&quot;</span>&gt;</span>现在你看到我了<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">&quot;seen&quot;</span>&gt;</span>你还能看到我吗？<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>v-if</code> 完全销毁和重建元素，而 <code>v-show</code> 仅仅是切换元素的可见性。</p><h3 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h3><h4 id="计算属性和监听器"><a href="#计算属性和监听器" class="headerlink" title="计算属性和监听器"></a>计算属性和监听器</h4><p>计算属性（Computed Properties）和监听器（Watchers）是 Vue 的强大功能，用于处理复杂逻辑和异步操作。</p><h5 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h5><p>计算属性是基于它们的依赖进行缓存的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">computed</span>: &#123;<br>  <span class="hljs-title function_">reversedMessage</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">message</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; reversedMessage &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h5><p>监听器用于在数据变化时执行异步操作或开销较大的操作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">watch</span>: &#123;<br>  <span class="hljs-title function_">message</span>(<span class="hljs-params">newVal, oldVal</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">logMessage</span>(newVal);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="模版引用"><a href="#模版引用" class="headerlink" title="模版引用"></a>模版引用</h4><p>模版引用（Template Refs）允许我们直接访问 DOM 元素或子组件实例。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;input&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">input</span>.<span class="hljs-title function_">focus</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h4><p>插槽（Slots）用于构建可复用的组件，允许在组件使用时传递内容。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用插槽：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">custom-component</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是插入的内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">custom-component</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h4><p>动态组件（Dynamic Components）允许我们在同一个挂载点动态切换不同的组件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;currentComponent&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">currentComponent</span>: <span class="hljs-string">&#x27;componentA&#x27;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="模版事件处理"><a href="#模版事件处理" class="headerlink" title="模版事件处理"></a>模版事件处理</h3><h4 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h4><p>使用 <code>v-on</code> 指令绑定事件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span>点击我<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 可使用 @ 简写 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span>点击我<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h4><p>事件修饰符用于修改事件行为。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">v-on:submit.prevent</span>=<span class="hljs-string">&quot;onSubmit&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 等效于 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> @<span class="hljs-attr">submit.prevent</span>=<span class="hljs-string">&quot;onSubmit&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><p>常用修饰符包括 <code>.stop</code>、<code>.prevent</code>、<code>.capture</code>、<code>.self</code>、<code>.once</code> 等。</p><h3 id="模版中的条件与循环"><a href="#模版中的条件与循环" class="headerlink" title="模版中的条件与循环"></a>模版中的条件与循环</h3><h4 id="条件渲染-1"><a href="#条件渲染-1" class="headerlink" title="条件渲染"></a>条件渲染</h4><p>通过 <code>v-if</code>、<code>v-else-if</code> 和 <code>v-else</code> 实现复杂的条件渲染。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;type === &#x27;A&#x27;&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;type === &#x27;B&#x27;&quot;</span>&gt;</span>B<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span>C<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h4><p>通过 <code>v-for</code> 渲染列表，并使用 <code>key</code> 提高渲染效率。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in items&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;item.id&quot;</span>&gt;</span>&#123;&#123; item.text &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Vue 3 的模版语法提供了强大的功能和灵活性，使得我们可以轻松构建复杂的用户界面。通过合理使用插值、指令、计算属性、监听器、插槽和动态组件，我们可以实现高效、可维护的前端代码。</p><h2 id="Composition-API-概述"><a href="#Composition-API-概述" class="headerlink" title="Composition API 概述"></a>Composition API 概述</h2><p>在 Vue 3 中，Composition API 是一个全新的特性，旨在解决 Options API 在大型项目中的一些局限性。它通过提供一种更灵活和可重用的方式来组织组件逻辑，使得代码更加简洁和模块化。以下是 Composition API 的一些核心概念和其优点的概述。</p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ol><li><p><strong>setup 函数</strong><br><code>setup</code> 是 Composition API 的入口函数，它在组件实例创建之前执行。这个函数接收两个参数：<code>props</code> 和 <code>context</code>，其中 <code>context</code> 包括 <code>attrs</code>、<code>slots</code> 和 <code>emit</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">setup</span>(<span class="hljs-params">props, context</span>) &#123;<br>  <span class="hljs-comment">// 初始化逻辑</span><br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-comment">// 公开给模板的变量和方法</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>响应式状态</strong><br>Composition API 提供了 <code>reactive</code> 和 <code>ref</code> 两个函数来创建响应式状态。</p><ul><li><p><code>reactive</code>：用于创建一个深层响应式对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p><code>ref</code>：用于创建一个简单的响应式值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure></li></ul></li><li><p><strong>计算属性和侦听器</strong><br>Composition API 也支持计算属性和侦听器，通过 <code>computed</code> 和 <code>watch</code> 函数实现。</p><ul><li><p><code>computed</code>：用于创建计算属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">const</span> doubled = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> state.<span class="hljs-property">count</span> * <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure></li><li><p><code>watch</code>：用于监听响应式数据的变化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; watch &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-title function_">watch</span>(<br>  <span class="hljs-function">() =&gt;</span> state.<span class="hljs-property">count</span>,<br>  <span class="hljs-function">(<span class="hljs-params">newValue, oldValue</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Count changed from <span class="hljs-subst">$&#123;oldValue&#125;</span> to <span class="hljs-subst">$&#123;newValue&#125;</span>`</span>);<br>  &#125;<br>);<br></code></pre></td></tr></table></figure></li></ul></li></ol><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li><p><strong>逻辑复用</strong><br>Composition API 允许将组件的逻辑拆分成可复用的函数，这些函数可以在不同组件中共享，避免了代码的重复。</p></li><li><p><strong>代码组织</strong><br>通过将相关逻辑集中在一个函数内，Composition API 提供了一种更自然的方式来组织代码，尤其是在处理复杂组件时。</p></li><li><p><strong>类型推断</strong><br>在 TypeScript 项目中，Composition API 可以更好地利用类型推断和类型检查功能，提供更好的开发体验。</p></li><li><p><strong>性能优化</strong><br>由于 Composition API 在组件实例创建之前执行，减少了在 Options API 中因生命周期钩子引入的额外开销，从而提高了性能。</p></li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>以下是一个简单的计数器组件，展示了如何使用 Composition API：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment&quot;</span>&gt;</span>Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        count.<span class="hljs-property">value</span>++;</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">        count,</span><br><span class="language-javascript">        increment,</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 或者 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">function</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    count.<span class="hljs-property">value</span>++;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在这个示例中，我们使用 <code>ref</code> 创建了一个响应式的 <code>count</code> 变量，并定义了一个 <code>increment</code> 方法来修改它。<code>setup</code> 函数返回的对象中的属性和方法会被暴露给模板。</p><h2 id="setup-函数详解"><a href="#setup-函数详解" class="headerlink" title="setup 函数详解"></a>setup 函数详解</h2><p>在 Vue 3 中，<code>setup</code> 函数是一个全新的特性，用于在组件内部进行初始化和配置。它是在组件实例创建之前执行的，并且是唯一一个具有副作用的生命周期钩子。通过 <code>setup</code> 函数，你可以访问组件的 props、context 和响应式数据等。</p><h3 id="1-使用方式"><a href="#1-使用方式" class="headerlink" title="1. 使用方式"></a>1. 使用方式</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params">props, context</span>) &#123;<br>    <span class="hljs-comment">// 在这里进行初始化和配置</span><br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-参数"><a href="#2-参数" class="headerlink" title="2. 参数"></a>2. 参数</h3><ul><li><code>props</code>: 组件的 props 对象，可以直接访问，也可以使用解构语法获取特定的 prop。</li><li><code>context</code>: 组件的上下文对象，包含一些常用的属性和方法，例如 <code>attrs</code>、<code>slots</code>、<code>emit</code> 等。</li></ul><h3 id="3-返回值"><a href="#3-返回值" class="headerlink" title="3. 返回值"></a>3. 返回值</h3><p><code>setup</code> 函数必须返回一个对象，该对象包含组件中需要响应式追踪的数据、方法等。</p><h3 id="4-响应式数据"><a href="#4-响应式数据" class="headerlink" title="4. 响应式数据"></a>4. 响应式数据</h3><p>通过 <code>ref</code>、<code>reactive</code> 等函数创建的数据会自动成为响应式数据，可以在模板中直接使用，并且在数据更新时，模板会自动更新。</p><h3 id="5-示例"><a href="#5-示例" class="headerlink" title="5. 示例"></a>5. 示例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">props</span>: &#123;<br>    <span class="hljs-attr">initialCount</span>: &#123;<br>      <span class="hljs-attr">type</span>: <span class="hljs-title class_">Number</span>,<br>      <span class="hljs-attr">default</span>: <span class="hljs-number">0</span>,<br>    &#125;,<br>  &#125;,<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(props.<span class="hljs-property">initialCount</span>);<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>      count.<span class="hljs-property">value</span>++;<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> &#123;<br>      count,<br>      increment,<br>    &#125;;<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>在模板中可以这样使用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment&quot;</span>&gt;</span>Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Count: &#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="Reactive-和-Ref-的使用"><a href="#Reactive-和-Ref-的使用" class="headerlink" title="Reactive 和 Ref 的使用"></a>Reactive 和 Ref 的使用</h2><p>在 Vue 3 中，<code>ref</code> 和 <code>reactive</code> 是两种用于创建响应式数据的主要方式。它们都能够让数据在发生变化时自动更新相关的视图，但在使用方式和适用场景上略有不同。</p><h3 id="1-ref"><a href="#1-ref" class="headerlink" title="1. ref"></a>1. ref</h3><p><code>ref</code> 是用于创建单个基本类型数据或对象的响应式引用。它返回一个包含 <code>.value</code> 属性的对象，该属性用于访问和修改数据。</p><h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>); <span class="hljs-comment">// 创建一个 ref</span><br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(count.<span class="hljs-property">value</span>); <span class="hljs-comment">// 访问 ref 中的值</span><br><br>count.<span class="hljs-property">value</span>++; <span class="hljs-comment">// 修改 ref 中的值</span><br></code></pre></td></tr></table></figure><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>简单的基本类型数据，如数字、字符串等。</li><li>无需直接访问内部属性的对象。</li></ul><h3 id="2-reactive"><a href="#2-reactive" class="headerlink" title="2. reactive"></a>2. reactive</h3><p><code>reactive</code> 用于创建包含多个属性的响应式对象。它接收一个普通对象，并返回一个代理对象，该代理对象会拦截对象上的所有属性访问，使其成为响应式的。</p><h4 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello&#x27;</span>,<br>&#125;);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(state.<span class="hljs-property">count</span>); <span class="hljs-comment">// 访问响应式对象的属性</span><br><br>state.<span class="hljs-property">count</span>++; <span class="hljs-comment">// 修改响应式对象的属性</span><br></code></pre></td></tr></table></figure><h4 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h4><ul><li>复杂的对象，包含多个属性。</li><li>需要直接访问对象的属性。</li></ul><h3 id="3-reactive-的局限性"><a href="#3-reactive-的局限性" class="headerlink" title="3. reactive 的局限性"></a>3. reactive 的局限性</h3><p>Vue 3 中的 <code>reactive()</code> 是一个非常强大的 API，用于创建响应式对象。然而，尽管它功能强大，但在某些情况下，它也有一些局限性和需要注意的地方。以下是一些常见的局限性：</p><h4 id="1-不能使非对象类型响应式"><a href="#1-不能使非对象类型响应式" class="headerlink" title="1. 不能使非对象类型响应式"></a>1. 不能使非对象类型响应式</h4><p><code>reactive()</code> 只能使对象类型（包括数组）变为响应式，而不能用于基本类型（如字符串、数字、布尔值等）。对于基本类型，可以使用 <code>ref()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello&#x27;</span>,<br>&#125;);<br><span class="hljs-comment">// 不能使 count 或 message 单独响应式</span><br></code></pre></td></tr></table></figure><h4 id="2-深层嵌套对象的性能问题"><a href="#2-深层嵌套对象的性能问题" class="headerlink" title="2. 深层嵌套对象的性能问题"></a>2. 深层嵌套对象的性能问题</h4><p>对于深层嵌套的对象，<code>reactive()</code> 会递归地将所有嵌套属性都变为响应式，这在某些情况下可能会导致性能问题。尽量避免过深的嵌套结构，或者仅在必要时使用 <code>reactive()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">const</span> deepState = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-attr">level1</span>: &#123;<br>    <span class="hljs-attr">level2</span>: &#123;<br>      <span class="hljs-attr">level3</span>: &#123;<br>        <span class="hljs-attr">level4</span>: <span class="hljs-string">&#x27;deep value&#x27;</span>,<br>      &#125;,<br>    &#125;,<br>  &#125;,<br>&#125;);<br><span class="hljs-comment">// 这种深层嵌套结构可能导致性能问题</span><br></code></pre></td></tr></table></figure><h4 id="3-对解构操作不友好"><a href="#3-对解构操作不友好" class="headerlink" title="3. 对解构操作不友好"></a>3. 对解构操作不友好</h4><p>解构操作将会使变量失去响应性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;);<br><br><span class="hljs-comment">// 解构的时候 count 和 state.count 失去关联</span><br><span class="hljs-keyword">let</span> &#123; count &#125; = state;<br><span class="hljs-comment">// 不会影响 state.count</span><br>count++;<br><br><span class="hljs-comment">// the function receives a plain number and</span><br><span class="hljs-comment">// won&#x27;t be able to track changes to state.count</span><br><span class="hljs-comment">// we have to pass the entire object in to retain reactivity</span><br><span class="hljs-title function_">callSomeFunction</span>(state.<span class="hljs-property">count</span>);<br></code></pre></td></tr></table></figure><h4 id="4-不能直接对整个对象赋值"><a href="#4-不能直接对整个对象赋值" class="headerlink" title="4. 不能直接对整个对象赋值"></a>4. 不能直接对整个对象赋值</h4><p>对整个对象赋值将会使对象失去响应性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> state = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;);<br><br><span class="hljs-comment">// the above reference (&#123; count: 0 &#125;) is no longer being tracked</span><br><span class="hljs-comment">// (reactivity connection is lost!)</span><br>state = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">1</span> &#125;);<br></code></pre></td></tr></table></figure><h2 id="生命周期钩子"><a href="#生命周期钩子" class="headerlink" title="生命周期钩子"></a>生命周期钩子</h2><p>在 Vue 3 中，生命周期函数是组件在其生命周期中的特定阶段执行的函数。这些函数在组件的不同阶段被自动调用，使得开发者可以在这些阶段执行特定的逻辑，例如数据初始化、DOM 挂载、更新和销毁等。合理使用生命周期函数可以有效地管理组件的状态和行为。</p><p><img src="/../../img/vue3/lifecycle.png" alt="生命周期"></p><h3 id="Vue-3-选项式-API-的生命周期钩子"><a href="#Vue-3-选项式-API-的生命周期钩子" class="headerlink" title="Vue 3 选项式 API 的生命周期钩子"></a>Vue 3 选项式 API 的生命周期钩子</h3><ol><li><strong>beforeCreate</strong>: 实例初始化之后，数据观测(data observation) 和事件配置(events) 之前被调用。</li><li><strong>created</strong>: 实例创建完成，数据观测(data observation) 和事件配置(events) 之后被调用。</li><li><strong>beforeMount</strong>: 在挂载开始之前被调用：相关的 render 函数首次被调用。</li><li><strong>mounted</strong>: Vue 实例被挂载到 DOM 上后调用。</li><li><strong>beforeUpdate</strong>: 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。</li><li><strong>updated</strong>: 由于数据更改导致的虚拟 DOM 重新渲染和打补丁之后调用。</li><li><strong>beforeUnmount</strong>: 实例销毁之前调用。在这一步，实例仍然完全可用。</li><li><strong>unmounted</strong>: Vue 实例销毁后调用。</li></ol><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">beforeCreate</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;beforeCreate&#x27;</span>);<br>  &#125;,<br>  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;created&#x27;</span>);<br>  &#125;,<br>  <span class="hljs-title function_">beforeMount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;beforeMount&#x27;</span>);<br>  &#125;,<br>  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;mounted&#x27;</span>);<br>  &#125;,<br>  <span class="hljs-title function_">beforeUpdate</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;beforeUpdate&#x27;</span>);<br>  &#125;,<br>  <span class="hljs-title function_">updated</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;updated&#x27;</span>);<br>  &#125;,<br>  <span class="hljs-title function_">beforeUnmount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;beforeUnmount&#x27;</span>);<br>  &#125;,<br>  <span class="hljs-title function_">unmounted</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;unmounted&#x27;</span>);<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="Vue-3-组合式-API-的生命周期-hooks"><a href="#Vue-3-组合式-API-的生命周期-hooks" class="headerlink" title="Vue 3 组合式 API 的生命周期 hooks"></a>Vue 3 组合式 API 的生命周期 hooks</h3><ol><li><strong>onBeforeMount</strong>: 在挂载开始之前调用。</li><li><strong>onMounted</strong>: 组件挂载到 DOM 之后调用，通常在这里发起 API 请求。</li><li><strong>onBeforeUpdate</strong>: 数据更新时调用，发生在虚拟 DOM 重新渲染和打补丁之前。</li><li><strong>onUpdated</strong>: 由于数据更改导致的虚拟 DOM 重新渲染和打补丁之后调用。</li><li><strong>onBeforeUnmount</strong>: 组件实例销毁之前调用。</li><li><strong>onUnmounted</strong>: 组件实例销毁后调用。</li></ol><p>以下是一个示例，展示了如何在组合式 API 中使用这些 hooks：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123;<br>  ref,<br>  onBeforeMount,<br>  onMounted,<br>  onBeforeUpdate,<br>  onUpdated,<br>  onBeforeUnmount,<br>  onUnmounted,<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>);<br><br>    <span class="hljs-title function_">onBeforeMount</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Component will mount&#x27;</span>);<br>    &#125;);<br><br>    <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Component mounted&#x27;</span>);<br>      <span class="hljs-title function_">fetchData</span>();<br>    &#125;);<br><br>    <span class="hljs-title function_">onBeforeUpdate</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Component will update&#x27;</span>);<br>    &#125;);<br><br>    <span class="hljs-title function_">onUpdated</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Component updated&#x27;</span>);<br>    &#125;);<br><br>    <span class="hljs-title function_">onBeforeUnmount</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Component will unmount&#x27;</span>);<br>    &#125;);<br><br>    <span class="hljs-title function_">onUnmounted</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Component unmounted&#x27;</span>);<br>    &#125;);<br><br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">fetchData</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>);<br>        data.<span class="hljs-property">value</span> = <span class="hljs-keyword">await</span> response.<span class="hljs-title function_">json</span>();<br>      &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);<br>      &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">return</span> &#123;<br>      data,<br>    &#125;;<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="生命周期的实际应用"><a href="#生命周期的实际应用" class="headerlink" title="生命周期的实际应用"></a>生命周期的实际应用</h3><h4 id="组件初始化时获取数据"><a href="#组件初始化时获取数据" class="headerlink" title="组件初始化时获取数据"></a>组件初始化时获取数据</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; data &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; ref, onMounted &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">onMounted</span>(<span class="hljs-keyword">async</span> () =&gt; &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">        data.<span class="hljs-property">value</span> = response.<span class="hljs-property">data</span>;</span></span><br><span class="language-javascript"><span class="language-xml">      &#125; <span class="hljs-keyword">catch</span> (error) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      data,</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="组件销毁前清理资源"><a href="#组件销毁前清理资源" class="headerlink" title="组件销毁前清理资源"></a>组件销毁前清理资源</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; data &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; ref, onMounted, onUnmounted &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> data = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> intervalId = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">onMounted</span>(<span class="hljs-keyword">async</span> () =&gt; &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">try</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;https://api.example.com/data&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">        data.<span class="hljs-property">value</span> = response.<span class="hljs-property">data</span>;</span></span><br><span class="language-javascript"><span class="language-xml">      &#125; <span class="hljs-keyword">catch</span> (error) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error);</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">      intervalId.<span class="hljs-property">value</span> = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Interval running&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;, <span class="hljs-number">1000</span>);</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">onUnmounted</span>(<span class="hljs-function">() =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">if</span> (intervalId.<span class="hljs-property">value</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-built_in">clearInterval</span>(intervalId.<span class="hljs-property">value</span>);</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Interval cleared&#x27;</span>);</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;);</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      data,</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>通过这些生命周期钩子和组合式 API，你可以在 Vue 3 中更灵活地管理组件的状态和副作用。</p>]]></content>
    
    
    <categories>
      
      <category>前端开发手册</category>
      
      <category>Vue3 奇妙之旅：轻松掌握新语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
      <tag>vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解 Vue 3 组件</title>
    <link href="/2024/06/06/frontendGuide/vue3/component/"/>
    <url>/2024/06/06/frontendGuide/vue3/component/</url>
    
    <content type="html"><![CDATA[<h2 id="1-组件基础"><a href="#1-组件基础" class="headerlink" title="1. 组件基础"></a>1. 组件基础</h2><h3 id="1-1-什么是组件"><a href="#1-1-什么是组件" class="headerlink" title="1.1 什么是组件"></a>1.1 什么是组件</h3><p>组件是 Vue 应用程序的基本构建块。每个组件都封装了特定的功能或 UI 部分，可以像 HTML 元素一样使用。</p><h3 id="1-2-定义组件"><a href="#1-2-定义组件" class="headerlink" title="1.2 定义组件"></a>1.2 定义组件</h3><p>在 Vue 3 中，可以使用 <code>defineComponent</code> 方法定义组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; defineComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineComponent</span>(&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;MyComponent&#x27;</span>,<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello, Vue 3!&#x27;</span><br>    &#125;;<br>  &#125;,<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;`</span><br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="2-组件形式"><a href="#2-组件形式" class="headerlink" title="2. 组件形式"></a>2. 组件形式</h2><h3 id="2-1-单文件组件（Single-File-Component-SFC）"><a href="#2-1-单文件组件（Single-File-Component-SFC）" class="headerlink" title="2.1 单文件组件（Single File Component, SFC）"></a>2.1 单文件组件（Single File Component, SFC）</h3><p>单文件组件是 Vue 3 中最常见的组件形式，使用 <code>.vue</code> 文件扩展名。一个 <code>.vue</code> 文件包含 <code>&lt;template&gt;</code>、<code>&lt;script&gt;</code> 和 <code>&lt;style&gt;</code> 三个部分。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello, Vue 3!&#x27;</span></span><br><span class="language-javascript">    &#125;;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-tag">div</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">color</span>: blue;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-2-纯-JS-组件"><a href="#2-2-纯-JS-组件" class="headerlink" title="2.2 纯 JS 组件"></a>2.2 纯 JS 组件</h3><p>不常用，需要配置 alias <code>vue: &#39;vue/dist/vue.esm-bundler.js&#39;</code>，使用 <code>.js</code> 文件扩展名。使用选项式 api 的 template 属性提供字符串形式的模板。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; defineComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineComponent</span>(&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;JsComponent&#x27;</span>,<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello, form js component&#x27;</span><br>    &#125;;<br>  &#125;,<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;`</span><br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="2-3-全局注册和局部注册"><a href="#2-3-全局注册和局部注册" class="headerlink" title="2.3 全局注册和局部注册"></a>2.3 全局注册和局部注册</h3><h4 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h4><p>全局注册的组件可以在任何地方使用。通过 <code>app.component</code> 方法注册：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/MyComponent.vue&#x27;</span>;<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>);<br>app.<span class="hljs-title function_">component</span>(<span class="hljs-string">&#x27;MyComponent&#x27;</span>, <span class="hljs-title class_">MyComponent</span>);<br>app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>);<br></code></pre></td></tr></table></figure><h4 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h4><p>局部注册的组件只能在注册它们的组件中使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/MyComponent.vue&#x27;</span>;<br><br><span class="hljs-comment">// 使用 setup 可以跳过 components 配置，直接使用</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">components</span>: &#123;<br>    <span class="hljs-title class_">MyComponent</span><br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="3-组件引用"><a href="#3-组件引用" class="headerlink" title="3. 组件引用"></a>3. 组件引用</h2><p>在模板中引用组件非常简单，只需使用组件名称作为标签即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/MyComponent.vue&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title class_">MyComponent</span></span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="4-组件之间的传值"><a href="#4-组件之间的传值" class="headerlink" title="4. 组件之间的传值"></a>4. 组件之间的传值</h2><p>在 Vue 中，父组件和子组件是组件之间的一种层级关系。让我详细解释一下这些概念以及为什么会这样命名。</p><h3 id="4-1-父子组件概念"><a href="#4-1-父子组件概念" class="headerlink" title="4.1 父子组件概念"></a>4.1 父子组件概念</h3><ol><li><p><strong>父组件</strong>：</p><ul><li>父组件是包含子组件的组件。它负责定义子组件的数据和行为，并将其传递给子组件进行处理。</li><li>父组件可以通过属性（<code>props</code>）向子组件传递数据和事件。子组件可以使用这些属性来渲染自身或执行一些操作。</li><li>举个例子，如果我们有一个页面组件，它包含了一个按钮组件，那么页面组件就是父组件，按钮组件就是子组件。</li></ul></li><li><p><strong>子组件</strong>：</p><ul><li>子组件是被包含在父组件中的组件。它通常用于封装一部分功能或界面元素，以便在不同的地方重复使用。</li><li>子组件可以接收父组件传递的数据，并根据这些数据来展示内容或执行操作。</li><li>例如，我们可以创建一个自定义的日期选择器组件，然后在不同的页面中多次使用它作为子组件。</li></ul></li></ol><p>为什么这样命名呢？这是因为在组件层级结构中，父组件通常包含了子组件，就像家庭中的父母和子女一样。这种命名方式有助于我们理解组件之间的关系，以及数据和事件是如何在它们之间流动的。</p><h3 id="4-2-父组件向子组件传值"><a href="#4-2-父组件向子组件传值" class="headerlink" title="4.2 父组件向子组件传值"></a>4.2 父组件向子组件传值</h3><p>使用 <code>props</code> 可以实现父组件向子组件传递数据。首先，在子组件中定义 <code>props</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">props</span>: &#123;<br>    <span class="hljs-attr">message</span>: <span class="hljs-title class_">String</span><br>  &#125;,<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;div&gt;&#123;&#123; message &#125;&#125;&lt;/div&gt;`</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>然后在父组件中使用子组件时传递数据：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> <span class="hljs-attr">message</span>=<span class="hljs-string">&quot;Hello from parent&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/MyComponent.vue&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title class_">MyComponent</span></span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4-3-子组件向父组件传值"><a href="#4-3-子组件向父组件传值" class="headerlink" title="4.3 子组件向父组件传值"></a>4.3 子组件向父组件传值</h3><p>使用事件和 <code>emit</code> 方法可以实现子组件向父组件传递数据。在子组件中触发事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">sendMessage</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;message-sent&#x27;</span>, <span class="hljs-string">&#x27;Hello from child&#x27;</span>);<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;button @click=&quot;sendMessage&quot;&gt;Send Message&lt;/button&gt;`</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>在父组件中监听事件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> @<span class="hljs-attr">message-sent</span>=<span class="hljs-string">&quot;handleMessage&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/MyComponent.vue&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title class_">MyComponent</span></span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">handleMessage</span>(<span class="hljs-params">message</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(message);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4-4-使用-v-model-实现双向绑定"><a href="#4-4-使用-v-model-实现双向绑定" class="headerlink" title="4.4 使用 v-model 实现双向绑定"></a>4.4 使用 <code>v-model</code> 实现双向绑定</h3><p>Vue 3 支持在自定义组件上使用 <code>v-model</code> 实现双向绑定。首先，在子组件中定义 <code>modelValue</code> prop 并触发 <code>update:modelValue</code> 事件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">props</span>: &#123;<br>    <span class="hljs-attr">modelValue</span>: <span class="hljs-title class_">String</span><br>  &#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-title function_">updateValue</span>(<span class="hljs-params">event</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;update:modelValue&#x27;</span>, event.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>);<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;input :value=&quot;modelValue&quot; @input=&quot;updateValue&quot; /&gt;`</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>在父组件中使用 <code>v-model</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">MyComponent</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./components/MyComponent.vue&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title class_">MyComponent</span></span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello, Vue 3!&#x27;</span></span><br><span class="language-javascript">    &#125;;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5. 结论"></a>5. 结论</h2><p>Vue 3 的组件系统提供了强大的工具和灵活的方式来构建现代化的 Web 应用程序。通过理解组件的基础知识、形式、引用方法和传值机制，开发者可以更加高效地开发和维护应用。希望这篇文章能帮助你更好地掌握 Vue 3 组件的使用。</p>]]></content>
    
    
    <categories>
      
      <category>前端开发手册</category>
      
      <category>Vue3 奇妙之旅：轻松掌握新语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
      <tag>vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>进阶概念</title>
    <link href="/2024/06/06/frontendGuide/vue3Advanced/advanced/"/>
    <url>/2024/06/06/frontendGuide/vue3Advanced/advanced/</url>
    
    <content type="html"><![CDATA[<h1 id="进阶概念"><a href="#进阶概念" class="headerlink" title="进阶概念"></a>进阶概念</h1><h2 id="依赖注入（Provide-Inject）"><a href="#依赖注入（Provide-Inject）" class="headerlink" title="依赖注入（Provide&#x2F;Inject）"></a>依赖注入（Provide&#x2F;Inject）</h2><p><code>provide</code> 和 <code>inject</code> 用于跨组件共享数据，通常在父组件中使用 <code>provide</code> 提供数据，在子组件中使用 <code>inject</code> 接收数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ParentComponent.vue</span><br><span class="hljs-keyword">import</span> &#123; provide &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">provide</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-string">&#x27;Hello from Parent&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// ChildComponent.vue</span><br><span class="hljs-keyword">import</span> &#123; inject &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> message = <span class="hljs-title function_">inject</span>(<span class="hljs-string">&#x27;message&#x27;</span>);<br>    <span class="hljs-keyword">return</span> &#123; message &#125;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li><strong>依赖关系</strong>：确保提供的数据在注入之前已经存在，否则会导致注入失败。</li><li><strong>作用域</strong>：提供的数据仅在当前组件树中有效。</li></ul><h2 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h2><p>自定义指令是 Vue 框架中用于对 DOM 元素进行复杂操作的一种方式。它可以帮助我们封装常用的 DOM 操作逻辑，提高代码的可重用性和可维护性。以下是详细的介绍，包括全局注册、局部注册、自定义 hooks 以及指令钩子和参数。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>自定义指令在模板中通过 <code>v-</code> 前缀使用。可以传递参数、修饰符和绑定值。</p><h3 id="全局注册自定义指令"><a href="#全局注册自定义指令" class="headerlink" title="全局注册自定义指令"></a>全局注册自定义指令</h3><p>全局注册自定义指令使得指令可以在整个应用中使用。我们需要在应用实例上通过 <code>directive</code> 方法进行注册。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span>;<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>);<br><br><span class="hljs-comment">// 定义全局指令</span><br>app.<span class="hljs-title function_">directive</span>(<span class="hljs-string">&#x27;focus&#x27;</span>, &#123;<br>  <span class="hljs-title function_">mounted</span>(<span class="hljs-params">el</span>) &#123;<br>    el.<span class="hljs-title function_">focus</span>();<br>  &#125;,<br>&#125;);<br><br>app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>);<br></code></pre></td></tr></table></figure><p>在模板中使用全局指令：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-focus</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="局部注册自定义指令"><a href="#局部注册自定义指令" class="headerlink" title="局部注册自定义指令"></a>局部注册自定义指令</h3><p>局部注册自定义指令使得指令仅在特定组件中可用。这种方式适合特定组件中使用的指令，避免全局污染。</p><h4 id="使用-Options-API"><a href="#使用-Options-API" class="headerlink" title="使用 Options API"></a>使用 Options API</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-focus</span> /&gt;</span></span><br>&lt;/template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">directives</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">focus</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-title function_">mounted</span>(<span class="hljs-params">el</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">          el.<span class="hljs-title function_">focus</span>();</span></span><br><span class="language-javascript"><span class="language-xml">        &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">      &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="使用-Composition-API"><a href="#使用-Composition-API" class="headerlink" title="使用 Composition API"></a>使用 Composition API</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-focus</span> /&gt;</span></span><br>&lt;/template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-keyword">const</span> vFocus = &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">mounted</span>: <span class="hljs-function">(<span class="hljs-params">el</span>) =&gt;</span> el.<span class="hljs-title function_">focus</span>()</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="指令钩子"><a href="#指令钩子" class="headerlink" title="指令钩子"></a>指令钩子</h3><p>一个指令的定义对象可以提供几种钩子函数 (都是可选的)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> myDirective = &#123;<br>  <span class="hljs-title function_">created</span>(<span class="hljs-params">el, binding, vnode, prevVnode</span>) &#123;<br>    <span class="hljs-comment">// 在绑定元素的 attribute 前或事件监听器应用前调用</span><br>  &#125;,<br>  <span class="hljs-title function_">beforeMount</span>(<span class="hljs-params">el, binding, vnode, prevVnode</span>) &#123;<br>    <span class="hljs-comment">// 在元素被插入到 DOM 前调用</span><br>  &#125;,<br>  <span class="hljs-title function_">mounted</span>(<span class="hljs-params">el, binding, vnode, prevVnode</span>) &#123;<br>    <span class="hljs-comment">// 在绑定元素的父组件及他自己的所有子节点都挂载完成后调用</span><br>  &#125;,<br>  <span class="hljs-title function_">beforeUpdate</span>(<span class="hljs-params">el, binding, vnode, prevVnode</span>) &#123;<br>    <span class="hljs-comment">// 绑定元素的父组件更新前调用</span><br>  &#125;,<br>  <span class="hljs-title function_">updated</span>(<span class="hljs-params">el, binding, vnode, prevVnode</span>) &#123;<br>    <span class="hljs-comment">// 在绑定元素的父组件及他自己的所有子节点都更新后调用</span><br>  &#125;,<br>  <span class="hljs-title function_">beforeUnmount</span>(<span class="hljs-params">el, binding, vnode, prevVnode</span>) &#123;<br>    <span class="hljs-comment">// 绑定元素的父组件卸载前调用</span><br>  &#125;,<br>  <span class="hljs-title function_">unmounted</span>(<span class="hljs-params">el, binding, vnode, prevVnode</span>) &#123;<br>    <span class="hljs-comment">// 绑定元素的父组件卸载后调用</span><br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="钩子参数"><a href="#钩子参数" class="headerlink" title="钩子参数"></a>钩子参数</h3><p>指令的钩子会传递以下几种参数：</p><ul><li><code>el</code>：指令绑定到的元素。这可以用于直接操作 DOM。</li><li><code>binding</code>：一个对象，包含以下属性。<ul><li><code>value</code>：传递给指令的值。例如在 <code>v-my-directive=&quot;1 + 1&quot;</code> 中，值是 <code>2</code>。</li><li><code>oldValue</code>：之前的值，仅在 <code>beforeUpdate</code> 和 <code>updated</code> 中可用。无论值是否更改，它都可用。</li><li><code>arg</code>：传递给指令的参数 (如果有的话)。例如在 <code>v-my-directive:foo</code> 中，参数是 <code>&quot;foo&quot;</code>。</li><li><code>modifiers</code>：一个包含修饰符的对象 (如果有的话)。例如在 <code>v-my-directive.foo.bar</code> 中，修饰符对象是 <code>&#123; foo: true, bar: true &#125;</code>。</li><li><code>instance</code>：使用该指令的组件实例。</li><li><code>dir</code>：指令的定义对象。</li></ul></li><li><code>vnode</code>：代表绑定元素的底层 VNode。</li><li><code>prevVnode</code>：代表之前的渲染中指令所绑定元素的 VNode。仅在 <code>beforeUpdate</code> 和 <code>updated</code> 钩子中可用。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;div v-<span class="hljs-attr">example</span>:foo.<span class="hljs-property">bar</span>=<span class="hljs-string">&quot;baz&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>binding 参数会是一个这样的对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>  <span class="hljs-attr">arg</span>: <span class="hljs-string">&#x27;foo&#x27;</span>,<br>  <span class="hljs-attr">modifiers</span>: &#123; <span class="hljs-attr">bar</span>: <span class="hljs-literal">true</span> &#125;,<br>  <span class="hljs-attr">value</span>: <span class="hljs-comment">/* `baz` 的值 */</span>,<br>  <span class="hljs-attr">oldValue</span>: <span class="hljs-comment">/* 上一次更新时 `baz` 的值 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h4><p>通过指令名后加参数来传递参数。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-focus</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">directives</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">focus</span>: &#123;</span><br><span class="language-javascript">        <span class="hljs-title function_">mounted</span>(<span class="hljs-params">el, binding</span>) &#123;</span><br><span class="language-javascript">          <span class="hljs-keyword">if</span> (binding.<span class="hljs-property">value</span>) &#123;</span><br><span class="language-javascript">            el.<span class="hljs-title function_">focus</span>();</span><br><span class="language-javascript">          &#125;</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">      &#125;,</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="使用注意事项"><a href="#使用注意事项" class="headerlink" title="使用注意事项"></a>使用注意事项</h3><ol><li><strong>命名冲突</strong>：避免与内置指令或其他自定义指令名称冲突。</li><li><strong>内存泄漏</strong>：确保在 <code>unmounted</code> 钩子中清理所有绑定的事件和资源，避免内存泄漏。</li><li><strong>复用性</strong>：自定义指令的逻辑应尽量通用，以便在多个组件中复用。</li><li><strong>性能</strong>：避免在指令钩子中执行耗时操作，影响性能。</li></ol><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ol><li><strong>表单处理</strong>：自动聚焦输入框、验证输入内容等。</li><li><strong>事件处理</strong>：处理复杂的 DOM 事件绑定和解绑。</li><li><strong>动画效果</strong>：实现复杂的动画效果。</li><li><strong>拖拽操作</strong>：实现元素拖拽功能。</li><li><strong>工具提示</strong>：实现悬停提示信息等。</li></ol><p>通过以上内容，希望大家对 Vue 3 中自定义指令的使用有一个全面的了解。自定义指令是 Vue 强大且灵活的功能之一，可以极大地提高开发效率和代码可维护性。</p><h2 id="动态组件与异步组件"><a href="#动态组件与异步组件" class="headerlink" title="动态组件与异步组件"></a>动态组件与异步组件</h2><p>Vue 3 提供了强大的动态组件和异步组件功能，使得组件的使用更加灵活和高效。动态组件允许根据条件动态渲染不同的组件，而异步组件则允许按需加载组件，从而提高应用的性能。</p><h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h3><p>动态组件允许我们根据条件动态切换组件。这对于需要在同一位置显示不同组件的场景非常有用。使用 <code>component</code> 标签和 <code>is</code> 属性可以实现这一点。</p><h4 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h4><p>首先，需要在模板中使用 <code>component</code> 标签并绑定 <code>is</code> 属性。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;currentComponent&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在脚本部分，根据条件动态设置 <code>currentComponent</code> 的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ComponentA</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ComponentA.vue&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ComponentB</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ComponentB.vue&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">components</span>: &#123;<br>    <span class="hljs-title class_">ComponentA</span>,<br>    <span class="hljs-title class_">ComponentB</span>,<br>  &#125;,<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> currentComponent = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;ComponentA&#x27;</span>);<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">switchComponent</span>(<span class="hljs-params"></span>) &#123;<br>      currentComponent.<span class="hljs-property">value</span> =<br>        currentComponent.<span class="hljs-property">value</span> === <span class="hljs-string">&#x27;ComponentA&#x27;</span> ? <span class="hljs-string">&#x27;ComponentB&#x27;</span> : <span class="hljs-string">&#x27;ComponentA&#x27;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> &#123;<br>      currentComponent,<br>      switchComponent,<br>    &#125;;<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>这样，当 <code>currentComponent</code> 的值发生变化时，渲染的组件也会相应切换。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;switchComponent&quot;</span>&gt;</span>Switch Component<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;currentComponent&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> <span class="hljs-title class_">ComponentA</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ComponentA.vue&#x27;</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> <span class="hljs-title class_">ComponentB</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ComponentB.vue&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-title class_">ComponentA</span>,</span><br><span class="language-javascript">      <span class="hljs-title class_">ComponentB</span>,</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> currentComponent = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;ComponentA&#x27;</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">function</span> <span class="hljs-title function_">switchComponent</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        currentComponent.<span class="hljs-property">value</span> =</span><br><span class="language-javascript">          currentComponent.<span class="hljs-property">value</span> === <span class="hljs-string">&#x27;ComponentA&#x27;</span> ? <span class="hljs-string">&#x27;ComponentB&#x27;</span> : <span class="hljs-string">&#x27;ComponentA&#x27;</span>;</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">        currentComponent,</span><br><span class="language-javascript">        switchComponent,</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当使用 <code>&lt;component :is=&quot;...&quot;&gt;</code> 来在多个组件间作切换时，被切换掉的组件会被卸载。我们可以通过 <code>&lt;KeepAlive&gt;</code> 组件强制被切换掉的组件仍然保持“存活”的状态。</p><h3 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h3><p>异步组件是 Vue 3 中用于按需加载组件的一种方式，可以显著减少初始加载时间，提高应用性能。Vue 3 提供了 <code>defineAsyncComponent</code> 函数用于定义异步加载的组件。</p><h4 id="使用方法-2"><a href="#使用方法-2" class="headerlink" title="使用方法"></a>使用方法</h4><p>定义一个异步组件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; defineAsyncComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">AsyncComponent</span> = <span class="hljs-title function_">defineAsyncComponent</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./MyComponent.vue&#x27;</span>));<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">components</span>: &#123;<br>    <span class="hljs-title class_">AsyncComponent</span>,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>在模板中使用异步组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">AsyncComponent</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h4><p>可以为异步组件配置加载状态、错误处理和重试逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; defineAsyncComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title class_">AsyncComponent</span> = <span class="hljs-title function_">defineAsyncComponent</span>(&#123;<br>  <span class="hljs-attr">loader</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./MyComponent.vue&#x27;</span>),<span class="hljs-comment">// 加载函数</span><br>  <span class="hljs-attr">loadingComponent</span>: <span class="hljs-title class_">LoadingComponent</span>,<span class="hljs-comment">// 加载异步组件时使用的组件</span><br>  <span class="hljs-attr">delay</span>: <span class="hljs-number">200</span>, <span class="hljs-comment">// 展示加载组件前的延迟时间，默认为 200ms</span><br>  <span class="hljs-attr">errorComponent</span>: <span class="hljs-title class_">ErrorComponent</span>,<span class="hljs-comment">// 加载失败后展示的组件</span><br>  <span class="hljs-comment">// 如果提供了一个 timeout 时间限制，并超时了</span><br>  <span class="hljs-comment">// 也会显示这里配置的报错组件，默认值是：Infinity</span><br>  <span class="hljs-attr">timeout</span>: <span class="hljs-number">3000</span>, <span class="hljs-comment">// 超时时间(ms)，超时后显示errorComponent</span><br>&#125;);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">components</span>: &#123;<br>    <span class="hljs-title class_">AsyncComponent</span>,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">AsyncComponent</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; defineAsyncComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> <span class="hljs-title class_">LoadingComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./LoadingComponent.vue&#x27;</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> <span class="hljs-title class_">ErrorComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ErrorComponent.vue&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> <span class="hljs-title class_">AsyncComponent</span> = <span class="hljs-title function_">defineAsyncComponent</span>(&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">loader</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./MyComponent.vue&#x27;</span>),</span><br><span class="language-javascript">    <span class="hljs-attr">loadingComponent</span>: <span class="hljs-title class_">LoadingComponent</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">errorComponent</span>: <span class="hljs-title class_">ErrorComponent</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">delay</span>: <span class="hljs-number">200</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">timeout</span>: <span class="hljs-number">3000</span>,</span><br><span class="language-javascript">  &#125;);</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-title class_">AsyncComponent</span>,</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>动态组件</strong> 适用于需要根据条件动态渲染不同组件的场景。</li><li><strong>异步组件</strong> 则适用于需要按需加载组件以提高性能的场景。</li></ul><p>通过合理使用动态组件和异步组件，可以极大地提高 Vue 应用的灵活性和性能。</p><h4 id="KeepAlive组件"><a href="#KeepAlive组件" class="headerlink" title="KeepAlive组件"></a>KeepAlive组件</h4><p><code>&lt;KeepAlive&gt;</code> 是一个内置组件，它的功能是在多个组件间动态切换时缓存被移除的组件实例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script setup&gt;<br><span class="hljs-keyword">import</span> &#123; shallowRef &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">CompA</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./CompA.vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">CompB</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./CompB.vue&#x27;</span><br><br><span class="hljs-keyword">const</span> current = <span class="hljs-title function_">shallowRef</span>(<span class="hljs-title class_">CompA</span>)<br>&lt;/script&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;demo&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;current&quot;</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;CompA&quot;</span> /&gt;</span> A<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;current&quot;</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;CompB&quot;</span> /&gt;</span> B<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;current&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script setup&gt;<br><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br>&lt;/script&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Current component: A<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>count: &#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;count++&quot;</span>&gt;</span>+<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script setup&gt;<br><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">const</span> msg = <span class="hljs-title function_">ref</span>(<span class="hljs-string">&#x27;&#x27;</span>)<br>&lt;/script&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Current component: B<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>Message is: &#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;msg&quot;</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>运行上面的例子，你会看到两个有状态的组件——A 有一个计数器，而 B 有一个通过 v-model 同步 input 框输入内容的文字展示。尝试先更改一下任意一个组件的状态，然后切走，再切回来。之前已更改的状态都被重置了。</p><p>想要组件能在被“切走”的时候保留它们的状态。要解决这个问题，我们可以用 <code>&lt;KeepAlive&gt;</code> 内置组件将这些动态组件包装起来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;!-- 非活跃的组件将会被缓存！ --&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">KeepAlive</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;activeComponent&quot;</span> /&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">KeepAlive</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="ref高级用法"><a href="#ref高级用法" class="headerlink" title="ref高级用法"></a>ref高级用法</h3><h4 id="动态绑定-ref"><a href="#动态绑定-ref" class="headerlink" title="动态绑定 ref"></a>动态绑定 ref</h4><p>需要 v3.2.25 及以上版本</p><p>可以通过 <code>v-for</code> 动态绑定多个 <code>ref</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script setup&gt;<br><span class="hljs-keyword">import</span> &#123; ref, onMounted &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">const</span> list = <span class="hljs-title function_">ref</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><br><span class="hljs-keyword">const</span> itemRefs = <span class="hljs-title function_">ref</span>([])<br><br><span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">alert</span>(itemRefs.<span class="hljs-property">value</span>.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> i.<span class="hljs-property">textContent</span>))<br>&#125;)<br>&lt;/script&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;item in list&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;itemRefs&quot;</span>&gt;</span></span><br><span class="language-xml">      &#123;&#123; item &#125;&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h3 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><strong>保证 ref 的唯一性</strong>：在同一个作用域中，避免多个元素使用相同的 ref 名称。</li><li><strong>ref 的时效性</strong>：你只可以<strong>在组件挂载后</strong>才能访问模板引用。如果你想在模板中的表达式上访问 input，在初次渲染时会是 null。这是因为在初次渲染前这个元素还不存在呢！</li><li><strong>访问子组件的公共接口</strong>：通过 ref 访问子组件时，应避免访问子组件的私有状态或方法，只访问公开的接口。</li></ol><h3 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h3><ol><li><strong>直接 DOM 操作</strong>：需要直接操作 DOM 元素时，例如手动聚焦、获取输入框的值等。</li><li><strong>访问子组件方法</strong>：需要从父组件调用子组件的方法或访问子组件的状态时。</li><li><strong>动画和过渡效果</strong>：需要手动控制元素的动画和过渡效果时。</li></ol><p>通过合理使用模板引用与 ref，可以在 Vue 3 中实现更加灵活和强大的功能，使得组件间的交互和 DOM 操作更加便捷。</p><h2 id="Teleport-组件"><a href="#Teleport-组件" class="headerlink" title="Teleport 组件"></a>Teleport 组件</h2><p><code>Teleport</code> 用于将组件渲染到 DOM 树的指定位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//App.vue</span><br>&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;outer&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Tooltips with Vue 3 Teleport<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">MyModal</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">MyModal</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./MyModal.vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//MyModal.vue</span><br>&lt;script setup&gt;<br><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-keyword">const</span> open = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>)<br>&lt;/script&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;open = true&quot;</span>&gt;</span>Open Modal<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">Teleport</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;body&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;open&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;modal&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello from the modal!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;open = false&quot;</span>&gt;</span>Close<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">Teleport</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span></span><br><span class="language-css"><span class="language-xml"><span class="hljs-selector-class">.modal</span> &#123;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">position</span>: fixed;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">z-index</span>: <span class="hljs-number">999</span>;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">top</span>: <span class="hljs-number">20%</span>;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">150px</span>;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#000</span>;</span></span><br><span class="language-css"><span class="language-xml">  <span class="hljs-attribute">text-align</span>: center;</span></span><br><span class="language-css"><span class="language-xml">&#125;</span></span><br><span class="language-css"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><code>Teleport</code> 组件使得组件内容可以脱离父组件的 DOM 层次结构，直接移动到指定的目标元素中。</p><p>这类场景最常见的例子就是全屏的模态框。理想情况下，我们希望触发模态框的按钮和模态框本身是在同一个组件中，因为它们都与组件的开关状态有关。但这意味着该模态框将与按钮一起渲染在应用 DOM 结构里很深的地方。这会导致该模态框的 CSS 布局代码很难写。</p>]]></content>
    
    
    <categories>
      
      <category>前端开发手册</category>
      
      <category>进阶奇妙旅程：解锁 Vue3 的高级魔法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
      <tag>vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>表单处理</title>
    <link href="/2024/06/06/frontendGuide/vue3/form/"/>
    <url>/2024/06/06/frontendGuide/vue3/form/</url>
    
    <content type="html"><![CDATA[<h1 id="表单处理"><a href="#表单处理" class="headerlink" title="表单处理"></a>表单处理</h1><p>表单处理是 Web 开发中的一项重要任务，Vue 3 提供了强大的工具来简化表单的绑定与验证。本文将介绍表单绑定与验证、表单验证和自定义表单组件的相关内容，并使用 Ant Design Vue 作为第三方库示例。</p><h2 id="表单绑定与验证"><a href="#表单绑定与验证" class="headerlink" title="表单绑定与验证"></a>表单绑定与验证</h2><p>在 Vue 3 中，表单绑定通过 <code>v-model</code> 指令实现，允许我们轻松地在表单控件和组件数据之间创建双向绑定。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>以下是一个简单的表单绑定示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> @<span class="hljs-attr">submit.prevent</span>=<span class="hljs-string">&quot;handleSubmit&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>Name:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;formData.name&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> /&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;email&quot;</span>&gt;</span>Email:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;email&quot;</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;formData.email&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;email&quot;</span> /&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Name: &#123;&#123; formData.name &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Email: &#123;&#123; formData.email &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> formData = <span class="hljs-title function_">ref</span>(&#123;</span><br><span class="language-javascript">        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">email</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">      &#125;);</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleSubmit</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Form submitted:&#x27;</span>, formData.<span class="hljs-property">value</span>);</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">        formData,</span><br><span class="language-javascript">        handleSubmit,</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h2><p>表单验证可以通过手动编写验证逻辑或使用第三方库来实现。以下示例展示了如何使用 Ant Design Vue 进行表单验证。</p><h3 id="使用-Ant-Design-Vue-示例"><a href="#使用-Ant-Design-Vue-示例" class="headerlink" title="使用 Ant Design Vue 示例"></a>使用 Ant Design Vue 示例</h3><p>安装 Ant Design Vue：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install ant-design-vue<br></code></pre></td></tr></table></figure><p>在项目中引入 Ant Design Vue：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Antd</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;ant-design-vue&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;ant-design-vue/dist/antd.css&#x27;</span>;<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>);<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Antd</span>);<br>app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="创建表单验证示例"><a href="#创建表单验证示例" class="headerlink" title="创建表单验证示例"></a>创建表单验证示例</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a-form</span></span><br><span class="hljs-tag">    <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;formRef&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">:model</span>=<span class="hljs-string">&quot;formState&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">:rules</span>=<span class="hljs-string">&quot;rules&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">:label-col</span>=<span class="hljs-string">&quot;labelCol&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">:wrapper-col</span>=<span class="hljs-string">&quot;wrapperCol&quot;</span></span><br><span class="hljs-tag">  &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a-form-item</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;Activity name&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a-input</span> <span class="hljs-attr">v-model:value</span>=<span class="hljs-string">&quot;formState.name&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a-form-item</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a-form-item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;Activity zone&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;region&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a-select</span></span><br><span class="hljs-tag">        <span class="hljs-attr">v-model:value</span>=<span class="hljs-string">&quot;formState.region&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;please select your zone&quot;</span></span><br><span class="hljs-tag">      &gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a-select-option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;shanghai&quot;</span>&gt;</span>Zone one<span class="hljs-tag">&lt;/<span class="hljs-name">a-select-option</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a-select-option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;beijing&quot;</span>&gt;</span>Zone two<span class="hljs-tag">&lt;/<span class="hljs-name">a-select-option</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">a-select</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a-form-item</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a-form-item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;Activity time&quot;</span> <span class="hljs-attr">required</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;date1&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a-date-picker</span></span><br><span class="hljs-tag">        <span class="hljs-attr">v-model:value</span>=<span class="hljs-string">&quot;formState.date1&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">show-time</span></span><br><span class="hljs-tag">        <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;date&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Pick a date&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 100%&quot;</span></span><br><span class="hljs-tag">      /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a-form-item</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a-form-item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;Instant delivery&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;delivery&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a-switch</span> <span class="hljs-attr">v-model:checked</span>=<span class="hljs-string">&quot;formState.delivery&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a-form-item</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a-form-item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;Activity type&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;type&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a-checkbox-group</span> <span class="hljs-attr">v-model:value</span>=<span class="hljs-string">&quot;formState.type&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a-checkbox</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;type&quot;</span>&gt;</span>Online<span class="hljs-tag">&lt;/<span class="hljs-name">a-checkbox</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a-checkbox</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;type&quot;</span>&gt;</span>Promotion<span class="hljs-tag">&lt;/<span class="hljs-name">a-checkbox</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a-checkbox</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;type&quot;</span>&gt;</span>Offline<span class="hljs-tag">&lt;/<span class="hljs-name">a-checkbox</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">a-checkbox-group</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a-form-item</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a-form-item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;Resources&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;resource&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a-radio-group</span> <span class="hljs-attr">v-model:value</span>=<span class="hljs-string">&quot;formState.resource&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a-radio</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>Sponsor<span class="hljs-tag">&lt;/<span class="hljs-name">a-radio</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a-radio</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>Venue<span class="hljs-tag">&lt;/<span class="hljs-name">a-radio</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">a-radio-group</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a-form-item</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a-form-item</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;Activity form&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;desc&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a-textarea</span> <span class="hljs-attr">v-model:value</span>=<span class="hljs-string">&quot;formState.desc&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a-form-item</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a-form-item</span> <span class="hljs-attr">:wrapper-col</span>=<span class="hljs-string">&quot;&#123; span: 14, offset: 4 &#125;&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;onSubmit&quot;</span>&gt;</span>Create<span class="hljs-tag">&lt;/<span class="hljs-name">a-button</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a-button</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;margin-left: 10px&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;resetForm&quot;</span>&gt;</span>Reset<span class="hljs-tag">&lt;/<span class="hljs-name">a-button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a-form-item</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">a-form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; reactive, ref, toRaw &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> formRef = <span class="hljs-title function_">ref</span>();</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> labelCol = &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">span</span>: <span class="hljs-number">5</span>,</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> wrapperCol = &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">span</span>: <span class="hljs-number">13</span>,</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> formState = <span class="hljs-title function_">reactive</span>(&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">region</span>: <span class="hljs-literal">undefined</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">date1</span>: <span class="hljs-literal">undefined</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">delivery</span>: <span class="hljs-literal">false</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">type</span>: [],</span><br><span class="language-javascript">    <span class="hljs-attr">resource</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">desc</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">  &#125;);</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> rules = &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">name</span>: [</span><br><span class="language-javascript">      &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Please input Activity name&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">trigger</span>: <span class="hljs-string">&#x27;change&#x27;</span>,</span><br><span class="language-javascript">      &#125;,</span><br><span class="language-javascript">      &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">min</span>: <span class="hljs-number">3</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">max</span>: <span class="hljs-number">5</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Length should be 3 to 5&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">trigger</span>: <span class="hljs-string">&#x27;blur&#x27;</span>,</span><br><span class="language-javascript">      &#125;,</span><br><span class="language-javascript">    ],</span><br><span class="language-javascript">    <span class="hljs-attr">region</span>: [</span><br><span class="language-javascript">      &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Please select Activity zone&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">trigger</span>: <span class="hljs-string">&#x27;change&#x27;</span>,</span><br><span class="language-javascript">      &#125;,</span><br><span class="language-javascript">    ],</span><br><span class="language-javascript">    <span class="hljs-attr">date1</span>: [</span><br><span class="language-javascript">      &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Please pick a date&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">trigger</span>: <span class="hljs-string">&#x27;change&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;object&#x27;</span>,</span><br><span class="language-javascript">      &#125;,</span><br><span class="language-javascript">    ],</span><br><span class="language-javascript">    <span class="hljs-attr">type</span>: [</span><br><span class="language-javascript">      &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;array&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Please select at least one activity type&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">trigger</span>: <span class="hljs-string">&#x27;change&#x27;</span>,</span><br><span class="language-javascript">      &#125;,</span><br><span class="language-javascript">    ],</span><br><span class="language-javascript">    <span class="hljs-attr">resource</span>: [</span><br><span class="language-javascript">      &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Please select activity resource&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">trigger</span>: <span class="hljs-string">&#x27;change&#x27;</span>,</span><br><span class="language-javascript">      &#125;,</span><br><span class="language-javascript">    ],</span><br><span class="language-javascript">    <span class="hljs-attr">desc</span>: [</span><br><span class="language-javascript">      &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Please input activity form&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">trigger</span>: <span class="hljs-string">&#x27;blur&#x27;</span>,</span><br><span class="language-javascript">      &#125;,</span><br><span class="language-javascript">    ],</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> <span class="hljs-title function_">onSubmit</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">    formRef.<span class="hljs-property">value</span></span><br><span class="language-javascript">      .<span class="hljs-title function_">validate</span>()</span><br><span class="language-javascript">      .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;values&#x27;</span>, formState, <span class="hljs-title function_">toRaw</span>(formState));</span><br><span class="language-javascript">      &#125;)</span><br><span class="language-javascript">      .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;error&#x27;</span>, error);</span><br><span class="language-javascript">      &#125;);</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> <span class="hljs-title function_">resetForm</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">    formRef.<span class="hljs-property">value</span>.<span class="hljs-title function_">resetFields</span>();</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="自定义表单组件"><a href="#自定义表单组件" class="headerlink" title="自定义表单组件"></a>自定义表单组件</h2><p>自定义表单组件可以提高代码的可重用性和可维护性。以下示例展示了如何创建和使用自定义表单组件。</p><h3 id="创建自定义表单组件"><a href="#创建自定义表单组件" class="headerlink" title="创建自定义表单组件"></a>创建自定义表单组件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- PriceUnit.vue --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a-input</span></span><br><span class="hljs-tag">      <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;value.number&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 100px&quot;</span></span><br><span class="hljs-tag">      @<span class="hljs-attr">change</span>=<span class="hljs-string">&quot;onNumberChange&quot;</span></span><br><span class="hljs-tag">    /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a-select</span></span><br><span class="hljs-tag">      <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;value.currency&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width: 80px; margin: 0 8px&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">:options</span>=<span class="hljs-string">&quot;[</span></span><br><span class="hljs-string"><span class="hljs-tag">        &#123; value: &#x27;rmb&#x27;, label: &#x27;RMB&#x27; &#125;,</span></span><br><span class="hljs-string"><span class="hljs-tag">        &#123; value: &#x27;dollar&#x27;, label: &#x27;Dollar&#x27; &#125;,</span></span><br><span class="hljs-string"><span class="hljs-tag">      ]&quot;</span></span><br><span class="hljs-tag">      @<span class="hljs-attr">change</span>=<span class="hljs-string">&quot;onCurrencyChange&quot;</span></span><br><span class="hljs-tag">    &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a-select</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; defineComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> type &#123; <span class="hljs-title class_">PropType</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">Form</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;ant-design-vue&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">export</span> type <span class="hljs-title class_">Currency</span> = <span class="hljs-string">&#x27;rmb&#x27;</span> | <span class="hljs-string">&#x27;dollar&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  interface <span class="hljs-title class_">PriceValue</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">number</span>: number;</span><br><span class="language-javascript">    <span class="hljs-attr">currency</span>: <span class="hljs-title class_">Currency</span>;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineComponent</span>(&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">props</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">value</span>: &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">type</span>: <span class="hljs-title class_">Object</span> <span class="hljs-keyword">as</span> <span class="hljs-title class_">PropType</span>&lt;<span class="hljs-title class_">PriceValue</span>&gt;,</span><br><span class="language-javascript">        <span class="hljs-attr">isRequired</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">default</span>: &#123;</span><br><span class="language-javascript">          <span class="hljs-attr">number</span>: <span class="hljs-number">0</span>,</span><br><span class="language-javascript">          <span class="hljs-attr">currency</span>: <span class="hljs-string">&#x27;rmb&#x27;</span>,</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">      &#125;,</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">emits</span>: [<span class="hljs-string">&#x27;update:value&#x27;</span>],</span><br><span class="language-javascript">    <span class="hljs-title function_">setup</span>(<span class="hljs-params">props, &#123; emit &#125;</span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> formItemContext = <span class="hljs-title class_">Form</span>.<span class="hljs-title function_">useInjectFormItemContext</span>();</span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> <span class="hljs-title function_">triggerChange</span> = (<span class="hljs-params">changedValue: &#123;</span></span><br><span class="hljs-params"><span class="language-javascript">        number?: number;</span></span><br><span class="hljs-params"><span class="language-javascript">        currency?: Currency;</span></span><br><span class="hljs-params"><span class="language-javascript">      &#125;</span>) =&gt; &#123;</span><br><span class="language-javascript">        <span class="hljs-title function_">emit</span>(<span class="hljs-string">&#x27;update:value&#x27;</span>, &#123; ...props.<span class="hljs-property">value</span>, ...changedValue &#125;);</span><br><span class="language-javascript">        formItemContext.<span class="hljs-title function_">onFieldChange</span>();</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> <span class="hljs-title function_">onNumberChange</span> = (<span class="hljs-params">e: InputEvent</span>) =&gt; &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> newNumber = <span class="hljs-built_in">parseInt</span>((e.<span class="hljs-property">target</span> <span class="hljs-keyword">as</span> any).<span class="hljs-property">value</span> || <span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-number">10</span>);</span><br><span class="language-javascript">        <span class="hljs-title function_">triggerChange</span>(&#123; <span class="hljs-attr">number</span>: newNumber &#125;);</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> <span class="hljs-title function_">onCurrencyChange</span> = (<span class="hljs-params">newCurrency: Currency</span>) =&gt; &#123;</span><br><span class="language-javascript">        <span class="hljs-title function_">triggerChange</span>(&#123; <span class="hljs-attr">currency</span>: newCurrency &#125;);</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">        onNumberChange,</span><br><span class="language-javascript">        onCurrencyChange,</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">  &#125;);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="使用自定义表单组件"><a href="#使用自定义表单组件" class="headerlink" title="使用自定义表单组件"></a>使用自定义表单组件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a-form</span> <span class="hljs-attr">:model</span>=<span class="hljs-string">&quot;formData&quot;</span> <span class="hljs-attr">:rules</span>=<span class="hljs-string">&quot;rules&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;formRef&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a-form-item</span></span><br><span class="hljs-tag">      <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;price&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;Price&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">:rules</span>=<span class="hljs-string">&quot;[&#123; validator: checkPrice &#125;]&quot;</span></span><br><span class="hljs-tag">    &gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">PriceUnit</span> <span class="hljs-attr">v-model:value</span>=<span class="hljs-string">&quot;formState.price&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a-form-item</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a-form-item</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleSubmit&quot;</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">a-button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a-form-item</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">a-form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; message &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;ant-design-vue&#x27;</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> <span class="hljs-title class_">PriceUnit</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./PriceUnit.vue&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-title class_">PriceUnit</span>,</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> formData = <span class="hljs-title function_">ref</span>(&#123;</span><br><span class="language-javascript">        <span class="hljs-attr">price</span>: &#123;</span><br><span class="language-javascript">          <span class="hljs-attr">currency</span>: <span class="hljs-string">&#x27;rmb&#x27;</span>,</span><br><span class="language-javascript">          <span class="hljs-attr">number</span>: <span class="hljs-number">0</span>,</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">      &#125;);</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> errors = <span class="hljs-title function_">ref</span>(&#123;&#125;);</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> rules = &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">name</span>: [</span><br><span class="language-javascript">          &#123; <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Name is required&#x27;</span>, <span class="hljs-attr">trigger</span>: <span class="hljs-string">&#x27;blur&#x27;</span> &#125;,</span><br><span class="language-javascript">        ],</span><br><span class="language-javascript">        <span class="hljs-attr">email</span>: [</span><br><span class="language-javascript">          &#123; <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Email is required&#x27;</span>, <span class="hljs-attr">trigger</span>: <span class="hljs-string">&#x27;blur&#x27;</span> &#125;,</span><br><span class="language-javascript">          &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;email&#x27;</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Email is invalid&#x27;</span>,</span><br><span class="language-javascript">            <span class="hljs-attr">trigger</span>: [<span class="hljs-string">&#x27;blur&#x27;</span>, <span class="hljs-string">&#x27;change&#x27;</span>],</span><br><span class="language-javascript">          &#125;,</span><br><span class="language-javascript">        ],</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> formRef = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>);</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> <span class="hljs-title function_">validate</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> formRef.<span class="hljs-property">value</span></span><br><span class="language-javascript">          .<span class="hljs-title function_">validate</span>()</span><br><span class="language-javascript">          .<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-literal">true</span>)</span><br><span class="language-javascript">          .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">            errors.<span class="hljs-property">value</span> = err.<span class="hljs-property">errorFields</span>.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, field</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">              acc[field.<span class="hljs-property">name</span>[<span class="hljs-number">0</span>]] = field.<span class="hljs-property">errors</span>[<span class="hljs-number">0</span>];</span><br><span class="language-javascript">              <span class="hljs-keyword">return</span> acc;</span><br><span class="language-javascript">            &#125;, &#123;&#125;);</span><br><span class="language-javascript">            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</span><br><span class="language-javascript">          &#125;);</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleSubmit</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">const</span> isValid = <span class="hljs-keyword">await</span> <span class="hljs-title function_">validate</span>();</span><br><span class="language-javascript">        <span class="hljs-keyword">if</span> (isValid) &#123;</span><br><span class="language-javascript">          message.<span class="hljs-title function_">success</span>(<span class="hljs-string">&#x27;Form submitted successfully!&#x27;</span>);</span><br><span class="language-javascript">          <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Form submitted:&#x27;</span>, formData.<span class="hljs-property">value</span>);</span><br><span class="language-javascript">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="language-javascript">          message.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;Form validation failed.&#x27;</span>);</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> <span class="hljs-title function_">checkPrice</span> = (<span class="hljs-params">_, value</span>) =&gt; &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">if</span> (value.<span class="hljs-property">number</span> &gt; <span class="hljs-number">0</span>) &#123;</span><br><span class="language-javascript">          <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>();</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Price must be greater than zero!&#x27;</span>));</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">        formData,</span><br><span class="language-javascript">        errors,</span><br><span class="language-javascript">        rules,</span><br><span class="language-javascript">        formRef,</span><br><span class="language-javascript">        handleSubmit,</span><br><span class="language-javascript">        checkPrice,</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通过以上内容，您可以在 Vue 3 中实现表单的绑定与验证，使用 <a href="https://next.antdv.com/components/form-cn">Ant Design Vue</a> 进行表单验证，以及创建和使用自定义表单组件来提高代码的可复用性和可维护性。</p>]]></content>
    
    
    <categories>
      
      <category>前端开发手册</category>
      
      <category>Vue3 奇妙之旅：轻松掌握新语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
      <tag>vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解 Vue3 的响应式原理</title>
    <link href="/2024/06/06/frontendGuide/vue3Advanced/proxy/"/>
    <url>/2024/06/06/frontendGuide/vue3Advanced/proxy/</url>
    
    <content type="html"><![CDATA[<h3 id="深入理解-Vue-3-的响应式原理"><a href="#深入理解-Vue-3-的响应式原理" class="headerlink" title="深入理解 Vue 3 的响应式原理"></a>深入理解 Vue 3 的响应式原理</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>Vue 3 引入了全新的响应式系统，进一步提升了开发者的体验和应用的性能。响应式系统是 Vue 框架的核心特性之一，它通过数据驱动的方式，让开发者能够高效地管理和更新视图。今天，我们将深入探讨 Vue 3 的响应式原理，了解其基本概念、实现原理以及相关优化策略。</p><h4 id="响应式系统的基本概念"><a href="#响应式系统的基本概念" class="headerlink" title="响应式系统的基本概念"></a>响应式系统的基本概念</h4><p>Vue 的响应式系统使得数据的变化能够自动触发视图的更新，而不需要手动操作 DOM。这一特性主要通过以下几个概念实现：</p><ol><li><strong>数据驱动</strong>：Vue 通过数据来驱动视图的变化，当数据发生变化时，视图会自动更新。</li><li><strong>双向绑定</strong>：数据和视图之间是双向绑定的，数据的变化会反映到视图上，视图的变化（如用户输入）也会更新数据。</li><li><strong>依赖追踪</strong>：Vue 自动追踪组件中数据的依赖关系，从而在数据变化时，只更新受影响的部分视图。</li></ol><h4 id="实现单个值的响应式"><a href="#实现单个值的响应式" class="headerlink" title="实现单个值的响应式"></a>实现单个值的响应式</h4><p>在普通 js 代码中，不会有响应式变化，例如下面这段代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> price = <span class="hljs-number">10</span>, quantity = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">const</span> total = price * quantity;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`total: <span class="hljs-subst">$&#123;total&#125;</span>`</span>); <span class="hljs-comment">// total: 20</span><br>price = <span class="hljs-number">20</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`total: <span class="hljs-subst">$&#123;total&#125;</span>`</span>); <span class="hljs-comment">// total: 20</span><br></code></pre></td></tr></table></figure><p>在修改 price 变量的值后， total 的值并没有发生改变。</p><p>那么如何修改上面代码，让 total 能够自动更新呢？我们其实可以将修改 total 值的方法保存起来，等到与 total 值相关的变量（如 price 或 quantity 变量的值）发生变化时，触发该方法，更新 total 即可。我们可以这么实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> price = <span class="hljs-number">10</span>, quantity = <span class="hljs-number">2</span>, total = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<span class="hljs-comment">//初始化 Set 类型的 dep 变量，用来存储需要执行的副作用函数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">effect</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  total = price * quantity<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">track</span> = (<span class="hljs-params"></span>)=&gt;&#123;<span class="hljs-comment">//创建 track 函数将需要执行的副作用函数保存到 dep 变量中</span><br>  dep.<span class="hljs-title function_">add</span>(effect)<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">trigger</span> = (<span class="hljs-params"></span>)=&gt;&#123;<span class="hljs-comment">//创建 trigger 函数用来执行所有副作用</span><br>  dep.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">effect</span> =&gt;</span> <span class="hljs-title function_">effect</span>())<br>&#125;<br><span class="hljs-title function_">track</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`total: <span class="hljs-subst">$&#123;total&#125;</span>`</span>); <span class="hljs-comment">// total: 0</span><br><span class="hljs-title function_">trigger</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`total: <span class="hljs-subst">$&#123;total&#125;</span>`</span>); <span class="hljs-comment">// total: 20</span><br>price = <span class="hljs-number">20</span>;<br><span class="hljs-title function_">trigger</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`total: <span class="hljs-subst">$&#123;total&#125;</span>`</span>); <span class="hljs-comment">// total: 40</span><br></code></pre></td></tr></table></figure><p>在每次 price 或 quantity 变化之后调用 trigger()执行所有副作用，就可以将 total 值更新为最新的值</p><h4 id="实现单个对象的响应式"><a href="#实现单个对象的响应式" class="headerlink" title="实现单个对象的响应式"></a>实现单个对象的响应式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> product = &#123; <span class="hljs-attr">price</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">quantity</span>: <span class="hljs-number">2</span> &#125;, total = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">const</span> depsMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(); <span class="hljs-comment">// 初始化一个 Map 类型的 depsMap 变量，用来保存每个需要响应式变化的对象属性（key 为对象的属性， value 为前面 Set 集合）</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">effect</span> = (<span class="hljs-params"></span>) =&gt; &#123; total = product.<span class="hljs-property">price</span> * product.<span class="hljs-property">quantity</span> &#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">track</span> = key =&gt; &#123;     <span class="hljs-comment">// 创建 track() 函数，用来将需要执行的副作用保存到 depsMap 变量中对应的对象属性下</span><br>  <span class="hljs-keyword">let</span> dep = depsMap.<span class="hljs-title function_">get</span>(key);<br>  <span class="hljs-keyword">if</span>(!dep) &#123;<br>    depsMap.<span class="hljs-title function_">set</span>(key, (dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()));<br>  &#125;<br>  dep.<span class="hljs-title function_">add</span>(effect);<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">trigger</span> = key =&gt; &#123;  <span class="hljs-comment">// 创建 trigger() 函数，用来执行 dep 变量中指定对象属性的所有副作用</span><br>  <span class="hljs-keyword">let</span> dep = depsMap.<span class="hljs-title function_">get</span>(key);<br>  <span class="hljs-keyword">if</span>(dep) &#123;<br>    dep.<span class="hljs-title function_">forEach</span>( <span class="hljs-function"><span class="hljs-params">effect</span> =&gt;</span> <span class="hljs-title function_">effect</span>() );<br>  &#125;<br>&#125;;<br><br><span class="hljs-title function_">track</span>(<span class="hljs-string">&#x27;price&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`total: <span class="hljs-subst">$&#123;total&#125;</span>`</span>); <span class="hljs-comment">// total: 0</span><br><span class="hljs-title function_">effect</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`total: <span class="hljs-subst">$&#123;total&#125;</span>`</span>); <span class="hljs-comment">// total: 20</span><br>product.<span class="hljs-property">price</span> = <span class="hljs-number">20</span>;<br><span class="hljs-title function_">trigger</span>(<span class="hljs-string">&#x27;price&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`total: <span class="hljs-subst">$&#123;total&#125;</span>`</span>); <span class="hljs-comment">// total: 40</span><br></code></pre></td></tr></table></figure><p>这样就实现监听对象的响应式变化，在 product 对象中的属性值发生变化， total 值也会跟着更新。</p><h4 id="实现多个对象的响应式"><a href="#实现多个对象的响应式" class="headerlink" title="实现多个对象的响应式"></a>实现多个对象的响应式</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> product = &#123; <span class="hljs-attr">price</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">quantity</span>: <span class="hljs-number">2</span> &#125;, total = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">const</span> targetMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();     <span class="hljs-comment">// 1、初始化 targetMap，保存观察对象</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">effect</span> = (<span class="hljs-params"></span>) =&gt; &#123; total = product.<span class="hljs-property">price</span> * product.<span class="hljs-property">quantity</span> &#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">track</span> = (<span class="hljs-params">target, key</span>) =&gt; &#123;     <span class="hljs-comment">// 2、收集依赖</span><br>  <span class="hljs-keyword">let</span> depsMap = targetMap.<span class="hljs-title function_">get</span>(target);<br>  <span class="hljs-keyword">if</span>(!depsMap)&#123;<br>    targetMap.<span class="hljs-title function_">set</span>(target, (depsMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()));<br>  &#125;<br>  <span class="hljs-keyword">let</span> dep = depsMap.<span class="hljs-title function_">get</span>(key);<br>  <span class="hljs-keyword">if</span>(!dep) &#123;<br>    depsMap.<span class="hljs-title function_">set</span>(key, (dep = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()));<br>  &#125;<br>  dep.<span class="hljs-title function_">add</span>(effect);<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">trigger</span> = (<span class="hljs-params">target, key</span>) =&gt; &#123;  <span class="hljs-comment">// 3、执行指定对象的指定属性的所有副作用</span><br>  <span class="hljs-keyword">const</span> depsMap = targetMap.<span class="hljs-title function_">get</span>(target);<br>  <span class="hljs-keyword">if</span>(!depsMap) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">let</span> dep = depsMap.<span class="hljs-title function_">get</span>(key);<br>  <span class="hljs-keyword">if</span>(dep) &#123;<br>    dep.<span class="hljs-title function_">forEach</span>( <span class="hljs-function"><span class="hljs-params">effect</span> =&gt;</span> <span class="hljs-title function_">effect</span>() );<br>  &#125;<br>&#125;;<br><br><span class="hljs-title function_">track</span>(product, <span class="hljs-string">&#x27;price&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`total: <span class="hljs-subst">$&#123;total&#125;</span>`</span>); <span class="hljs-comment">// total: 0</span><br><span class="hljs-title function_">effect</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`total: <span class="hljs-subst">$&#123;total&#125;</span>`</span>); <span class="hljs-comment">// total: 20</span><br>product.<span class="hljs-property">price</span> = <span class="hljs-number">20</span>;<br><span class="hljs-title function_">trigger</span>(product, <span class="hljs-string">&#x27;price&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`total: <span class="hljs-subst">$&#123;total&#125;</span>`</span>); <span class="hljs-comment">// total: 40</span><br></code></pre></td></tr></table></figure><p>1、初始化一个 WeakMap 类型的 targetMap 变量，用来存储每个响应式对象；</p><p>2、创建 track() 函数，用来将需要执行的副作用保存到指定对象（ target ）的依赖中</p><p>3、创建 trigger() 函数，用来执行指定对象（ target ）中指定属性（ key ）的所有副作用；</p><p>这样就实现监听对象的响应式变化，在 product 对象中的属性值发生变化， total 值也会跟着更新。</p><h4 id="reactive-与-ref-的实现原理"><a href="#reactive-与-ref-的实现原理" class="headerlink" title="reactive 与 ref 的实现原理"></a>reactive 与 ref 的实现原理</h4><p>上面每次都需要手动出发 track 收集依赖，再通过 trigger 执行所有的副作用，vue 则是自动调用实现数据更新</p><p>Vue 3 引入了 <code>reactive</code> 和 <code>ref</code> API 来创建响应式数据。这两者的实现原理主要依赖于 JavaScript 的 Proxy 对象和 Reflect API。</p><h4 id="Proxy-对象与-Reflect-API-的使用"><a href="#Proxy-对象与-Reflect-API-的使用" class="headerlink" title="Proxy 对象与 Reflect API 的使用"></a>Proxy 对象与 Reflect API 的使用</h4><p>Vue 3 的响应式系统主要基于 JavaScript 的 Proxy 对象和 Reflect API 实现。</p><h5 id="Proxy-对象"><a href="#Proxy-对象" class="headerlink" title="Proxy 对象"></a>Proxy 对象</h5><p>Proxy 对象用于定义自定义的行为（如拦截属性访问和修改）以实现响应式特性。它可以代理对目标对象的基本操作（如读取、写入和删除属性）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> target = &#123;<br>  <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello&#x27;</span><br>&#125;;<br><br><span class="hljs-keyword">const</span> handler = &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, prop</span>) &#123;<br>    <span class="hljs-keyword">return</span> prop <span class="hljs-keyword">in</span> target ? target[prop] : <span class="hljs-string">&#x27;Property not found&#x27;</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">message</span>); <span class="hljs-comment">// 输出 &quot;Hello&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">nonExistent</span>); <span class="hljs-comment">// 输出 &quot;Property not found&quot;</span><br></code></pre></td></tr></table></figure><h5 id="Reflect-API"><a href="#Reflect-API" class="headerlink" title="Reflect API"></a>Reflect API</h5><p>Reflect API 提供了一组静态方法，用于与 Proxy 对象的方法对应，确保对目标对象的基本操作一致。Vue 使用 Reflect API 来执行默认的对象操作，同时实现响应式特性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> handler = &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, prop, receiver</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Getting <span class="hljs-subst">$&#123;prop&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, prop, receiver);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handler);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-property">message</span>); <span class="hljs-comment">// 输出 &quot;Getting message&quot; 和 &quot;Hello&quot;</span><br></code></pre></td></tr></table></figure><h5 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h5><p><code>reactive</code> 函数用于创建一个深层次的响应式对象。它使用 JavaScript 的 Proxy 对象来拦截对对象属性的访问和修改，从而实现响应式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; reactive &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">reactive</span>(&#123;<br>  <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>,<br>  <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello Vue 3&#x27;</span><br>&#125;);<br><br>state.<span class="hljs-property">count</span>++; <span class="hljs-comment">// 视图会自动更新</span><br></code></pre></td></tr></table></figure><p><strong>实现原理</strong>：</p><ol><li><strong>创建代理</strong>：当调用 <code>reactive</code> 函数时，Vue 会创建一个 Proxy 对象来代理传入的原始对象。</li><li><strong>拦截操作</strong>：Proxy 对象通过 <code>get</code> 和 <code>set</code> 等拦截器（traps）来拦截对原始对象的属性访问和修改。</li><li><strong>依赖追踪</strong>：在 <code>get</code> 拦截器中，Vue 会记录依赖关系，将当前的副作用函数（例如渲染函数）与被访问的属性关联起来。</li><li><strong>触发更新</strong>：在 <code>set</code> 拦截器中，Vue 会在属性值发生变化时，触发与该属性相关的副作用函数，更新视图。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createReactiveObject</span>(<span class="hljs-params">target, handlers</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, handlers);<br>&#125;<br><br><span class="hljs-keyword">const</span> handlers = &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) &#123;<br>    <span class="hljs-comment">// 依赖追踪</span><br>    <span class="hljs-title function_">track</span>(target, key);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver);<br>  &#125;,<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, value, receiver</span>) &#123;<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, value, receiver);<br>    <span class="hljs-comment">// 触发更新</span><br>    <span class="hljs-title function_">trigger</span>(target, key);<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">const</span> state = <span class="hljs-title function_">createReactiveObject</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;, handlers);<br></code></pre></td></tr></table></figure><h5 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h5><p><code>ref</code> 函数用于创建一个包含单个值的响应式对象。它通常用于处理基本类型的数据（如字符串、数字）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><br><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);<br><br>count.<span class="hljs-property">value</span>++; <span class="hljs-comment">// 视图会自动更新</span><br></code></pre></td></tr></table></figure><p><strong>实现原理</strong>：</p><ol><li><strong>包装值</strong>：当调用 <code>ref</code> 函数时，Vue 会将传入的值包装在一个对象的 <code>value</code> 属性中。</li><li><strong>创建代理</strong>：Vue 为该对象创建一个 Proxy 对象，拦截对 <code>value</code> 属性的访问和修改。</li><li><strong>依赖追踪</strong>：在 <code>get</code> 拦截器中，Vue 会记录依赖关系，将当前的副作用函数与 <code>value</code> 属性关联起来。</li><li><strong>触发更新</strong>：在 <code>set</code> 拦截器中，Vue 会在 <code>value</code> 属性值发生变化时，触发与其相关的副作用函数，更新视图。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ref</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">createRef</span>(value);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createRef</span>(<span class="hljs-params">rawValue</span>) &#123;<br>  <span class="hljs-keyword">const</span> r = &#123;<br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">value</span>() &#123;<br>      <span class="hljs-comment">// 依赖追踪</span><br>      <span class="hljs-title function_">track</span>(r, <span class="hljs-string">&#x27;value&#x27;</span>);<br>      <span class="hljs-keyword">return</span> rawValue;<br>    &#125;,<br>    <span class="hljs-keyword">set</span> <span class="hljs-title function_">value</span>(<span class="hljs-params">newVal</span>) &#123;<br>      rawValue = newVal;<br>      <span class="hljs-comment">// 触发更新</span><br>      <span class="hljs-title function_">trigger</span>(r, <span class="hljs-string">&#x27;value&#x27;</span>);<br>    &#125;<br>  &#125;;<br>  <span class="hljs-keyword">return</span> r;<br>&#125;<br><br><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h4 id="响应式系统中的优化策略"><a href="#响应式系统中的优化策略" class="headerlink" title="响应式系统中的优化策略"></a>响应式系统中的优化策略</h4><p>为了提高响应式系统的性能，Vue 3 采用了一些优化策略：</p><ol><li><strong>懒执行</strong>：计算属性和监听器都是惰性求值的，只有在依赖的数据实际变化时才会重新计算或执行。</li><li><strong>依赖追踪</strong>：通过追踪依赖关系，Vue 3 只会在必要的时候更新视图，避免不必要的重新渲染。</li><li><strong>分块更新</strong>：Vue 3 在内部通过任务队列和批处理机制，将多次数据变化合并为一次更新，减少性能开销。</li></ol><h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>通过这篇文章，我们深入了解了 Vue 3 的响应式原理，包括响应式系统的基本概念、<code>reactive</code> 与 <code>ref</code> 的实现原理、Proxy 对象与 Reflect API 的使用以及响应式系统中的优化策略。希望通过对这些内容的理解，你能够更好地利用 Vue 3 的响应式系统，提高开发效率和应用性能。</p>]]></content>
    
    
    <categories>
      
      <category>前端开发手册</category>
      
      <category>进阶奇妙旅程：解锁 Vue3 的高级魔法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
      <tag>vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解锁服务器端渲染 (SSR) 和静态网站生成 (SSG)</title>
    <link href="/2024/06/06/frontendGuide/vue3Advanced/staticWeb/"/>
    <url>/2024/06/06/frontendGuide/vue3Advanced/staticWeb/</url>
    
    <content type="html"><![CDATA[<h3 id="解锁服务器端渲染-SSR-和静态网站生成-SSG"><a href="#解锁服务器端渲染-SSR-和静态网站生成-SSG" class="headerlink" title="解锁服务器端渲染 (SSR) 和静态网站生成 (SSG)"></a>解锁服务器端渲染 (SSR) 和静态网站生成 (SSG)</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>随着前端技术的发展，服务器端渲染（Server-Side Rendering, SSR）、静态网站生成（Static Site Generation, SSG）、单页应用（Single Page Application, SPA）、多页应用（Multi-Page Application, MPA）和客户端渲染（Client-Side Rendering, CSR）已经成为构建高性能网页应用的重要技术手段。今天，我们将深入探讨这些概念，了解它们的工作原理、优点以及如何在项目中使用它们。</p><h4 id="多页应用-MPA"><a href="#多页应用-MPA" class="headerlink" title="多页应用 (MPA)"></a>多页应用 (MPA)</h4><p>多页应用（MPA）是传统的 Web 应用架构，每个页面都有独立的 HTML 文件。当用户在页面之间导航时，浏览器会重新加载整个页面。</p><h5 id="MPA-的优点"><a href="#MPA-的优点" class="headerlink" title="MPA 的优点"></a>MPA 的优点</h5><ul><li><strong>良好的 SEO</strong>：每个页面都有独立的 URL，搜索引擎可以轻松抓取内容。</li><li><strong>更好的初始加载性能</strong>：每个页面只加载必要的内容，初始加载时间较短。</li></ul><h5 id="MPA-的缺点"><a href="#MPA-的缺点" class="headerlink" title="MPA 的缺点"></a>MPA 的缺点</h5><ul><li><strong>用户体验较差</strong>：页面之间导航需要完全刷新，用户体验不如 SPA 流畅。</li><li><strong>服务器负担较重</strong>：每次导航都需要服务器生成和传输新的页面内容。</li></ul><h4 id="单页应用-SPA"><a href="#单页应用-SPA" class="headerlink" title="单页应用 (SPA)"></a>单页应用 (SPA)</h4><p>单页应用（SPA）是一种现代 Web 应用架构，所有页面内容都在一个 HTML 文件中加载和动态更新。用户在不同页面之间导航时，无需重新加载整个页面。</p><h5 id="SPA-的优点"><a href="#SPA-的优点" class="headerlink" title="SPA 的优点"></a>SPA 的优点</h5><ul><li><strong>流畅的用户体验</strong>：页面导航不需要完全刷新，体验更加顺畅。</li><li><strong>减少服务器负担</strong>：大部分逻辑在客户端执行，减少了服务器的压力。</li><li><strong>前后端分离</strong>：前端和后端可以独立开发和部署，提升开发效率。</li></ul><h5 id="SPA-的缺点"><a href="#SPA-的缺点" class="headerlink" title="SPA 的缺点"></a>SPA 的缺点</h5><ul><li><strong>初始加载时间较长</strong>：由于需要加载整个应用，初始加载时间可能较长。</li><li><strong>SEO 较差</strong>：由于内容动态加载，搜索引擎可能难以抓取页面内容。</li></ul><h4 id="客户端渲染-CSR"><a href="#客户端渲染-CSR" class="headerlink" title="客户端渲染 (CSR)"></a>客户端渲染 (CSR)</h4><p>客户端渲染（CSR）是一种在客户端（浏览器）执行 JavaScript 代码，生成和更新页面内容的技术。CSR 通常与 SPA 结合使用，提供动态的用户体验。</p><h5 id="CSR-的优点"><a href="#CSR-的优点" class="headerlink" title="CSR 的优点"></a>CSR 的优点</h5><ul><li><strong>灵活的交互体验</strong>：在客户端执行逻辑，可以实现复杂的交互效果。</li><li><strong>减少服务器负担</strong>：大部分渲染和逻辑在客户端完成，减轻了服务器的压力。</li></ul><h5 id="CSR-的缺点"><a href="#CSR-的缺点" class="headerlink" title="CSR 的缺点"></a>CSR 的缺点</h5><ul><li><strong>初始加载时间较长</strong>：需要加载和执行大量的 JavaScript 代码。</li><li><strong>SEO 较差</strong>：动态生成的内容，搜索引擎可能难以抓取。</li></ul><h4 id="服务器端渲染-SSR"><a href="#服务器端渲染-SSR" class="headerlink" title="服务器端渲染 (SSR)"></a>服务器端渲染 (SSR)</h4><p>服务器端渲染（SSR）是一种在服务器上生成完整 HTML 内容的技术，然后将其发送到客户端。这样，用户可以立即看到页面内容，而无需等待 JavaScript 加载和执行。这种方式可以显著提升页面的初始加载速度和 SEO 性能。</p><h5 id="SSR-的工作原理"><a href="#SSR-的工作原理" class="headerlink" title="SSR 的工作原理"></a>SSR 的工作原理</h5><ol><li><strong>请求和响应</strong>：当用户请求一个页面时，服务器接收请求并处理。</li><li><strong>渲染 HTML</strong>：服务器在接收到请求后，运行 Vue 组件并生成完整的 HTML 内容。</li><li><strong>发送 HTML</strong>：服务器将生成的 HTML 内容发送到客户端。</li><li><strong>客户端激活</strong>：客户端接收到 HTML 后，Vue 会接管页面并激活组件，使其变得互动。</li></ol><h5 id="SSR-的优点"><a href="#SSR-的优点" class="headerlink" title="SSR 的优点"></a>SSR 的优点</h5><ul><li><strong>提升初始加载速度</strong>：由于服务器生成了完整的 HTML，用户可以立即看到页面内容。</li><li><strong>增强 SEO 性能</strong>：搜索引擎可以更容易地抓取和索引完整的 HTML 内容，提高页面的搜索排名。</li><li><strong>改善用户体验</strong>：用户不需要等待 JavaScript 加载和执行，页面呈现速度更快。</li></ul><h5 id="在-Vue-3-中使用-SSR"><a href="#在-Vue-3-中使用-SSR" class="headerlink" title="在 Vue 3 中使用 SSR"></a>在 Vue 3 中使用 SSR</h5><p>使用 Vue 3 进行 SSR 开发，通常需要结合 Nuxt.js。Nuxt.js 是一个基于 Vue.js 的框架，专注于提供完善的 SSR 解决方案。</p><ol><li><p><strong>安装 Nuxt.js</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npx create-nuxt-app &lt;project-name&gt;<br></code></pre></td></tr></table></figure></li><li><p><strong>配置 SSR</strong>：在 <code>nuxt.config.js</code> 文件中，确保 <code>ssr</code> 选项为 <code>true</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">ssr</span>: <span class="hljs-literal">true</span>,<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>开发和部署</strong>：开发过程中，使用 <code>npm run dev</code> 启动开发服务器；部署时，使用 <code>npm run build</code> 进行构建，并启动生产服务器。</p></li></ol><h4 id="静态网站生成-SSG"><a href="#静态网站生成-SSG" class="headerlink" title="静态网站生成 (SSG)"></a>静态网站生成 (SSG)</h4><p>静态网站生成（SSG）是一种在构建时预先生成所有页面的 HTML 文件的技术。这些静态文件可以直接部署到静态文件服务器或 CDN 上，极大地提高了页面加载速度和性能。</p><h5 id="SSG-的工作原理"><a href="#SSG-的工作原理" class="headerlink" title="SSG 的工作原理"></a>SSG 的工作原理</h5><ol><li><strong>构建阶段生成 HTML</strong>：在构建阶段，所有页面的 HTML 文件都预先生成并存储。</li><li><strong>静态文件部署</strong>：生成的静态文件可以部署到任意静态文件服务器或 CDN 上。</li><li><strong>客户端请求静态文件</strong>：当用户请求页面时，服务器直接返回预先生成的静态 HTML 文件。</li></ol><h5 id="SSG-的优点"><a href="#SSG-的优点" class="headerlink" title="SSG 的优点"></a>SSG 的优点</h5><ul><li><strong>极快的页面加载速度</strong>：静态文件可以直接从服务器或 CDN 返回，减少了服务器的计算和响应时间。</li><li><strong>高扩展性</strong>：静态文件可以轻松扩展和分发，适应大量用户的访问需求。</li><li><strong>安全性高</strong>：没有服务器端处理逻辑，减少了潜在的安全漏洞。</li></ul><h5 id="在-Vue-3-中使用-SSG"><a href="#在-Vue-3-中使用-SSG" class="headerlink" title="在 Vue 3 中使用 SSG"></a>在 Vue 3 中使用 SSG</h5><p>使用 Vue 3 进行 SSG 开发，同样可以结合 Nuxt.js 来实现。Nuxt.js 提供了开箱即用的静态网站生成功能。</p><ol><li><p><strong>安装 Nuxt.js</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npx create-nuxt-app &lt;project-name&gt;<br></code></pre></td></tr></table></figure></li><li><p><strong>配置 SSG</strong>：在 <code>nuxt.config.js</code> 文件中，设置 <code>target</code> 为 <code>static</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;static&#x27;</span>,<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>生成静态网站</strong>：使用 <code>npm run generate</code> 命令生成静态文件，生成的文件位于 <code>dist</code> 目录中，可以直接部署到静态文件服务器或 CDN 上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm run generate<br></code></pre></td></tr></table></figure></li></ol><h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>通过这篇文章，我们详细介绍了 Vue 3 中的服务器端渲染（SSR）、静态网站生成（SSG）、单页应用（SPA）、多页应用（MPA）和客户端渲染（CSR）。这些技术在提升网页性能和用户体验方面都具有显著优势。希望通过对这些技术的深入了解，你能够在项目中充分利用它们，让你的网页应用更加高效和用户友好。</p>]]></content>
    
    
    <categories>
      
      <category>前端开发手册</category>
      
      <category>进阶奇妙旅程：解锁 Vue3 的高级魔法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
      <tag>vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3 测试指南：从单元测试到端到端测试</title>
    <link href="/2024/06/06/frontendGuide/vue3Advanced/test/"/>
    <url>/2024/06/06/frontendGuide/vue3Advanced/test/</url>
    
    <content type="html"><![CDATA[<h3 id="Vue-3-测试指南：从单元测试到端到端测试"><a href="#Vue-3-测试指南：从单元测试到端到端测试" class="headerlink" title="Vue 3 测试指南：从单元测试到端到端测试"></a>Vue 3 测试指南：从单元测试到端到端测试</h3><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>测试是确保代码质量和应用稳定性的重要环节。在 Vue 3 开发中，测试同样扮演着至关重要的角色。今天，我们将详细探讨 Vue 3 的测试方法，包括单元测试、组件测试、以及端到端测试（E2E），并介绍如何使用 Jest 和 Vue Test Utils 进行测试。</p><h4 id="单元测试与组件测试"><a href="#单元测试与组件测试" class="headerlink" title="单元测试与组件测试"></a>单元测试与组件测试</h4><h5 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h5><p>单元测试是针对代码中最小的可测试单元进行测试，通常是一个函数或一个方法。单元测试的目标是确保每个单独的单元都能按预期工作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 示例单元测试</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;adds 1 + 2 to equal 3&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">expect</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)).<span class="hljs-title function_">toBe</span>(<span class="hljs-number">3</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h5 id="组件测试"><a href="#组件测试" class="headerlink" title="组件测试"></a>组件测试</h5><p>组件测试是针对 Vue 组件的测试。与单元测试不同，组件测试会涉及到组件的模板、样式以及组件之间的交互。Vue Test Utils 是 Vue 官方提供的测试实用工具，用于方便地测试 Vue 组件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 示例组件测试</span><br><span class="hljs-keyword">import</span> &#123; mount &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@vue/test-utils&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/MyComponent.vue&#x27;</span>;<br><br><span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;renders a message&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> wrapper = <span class="hljs-title function_">mount</span>(<span class="hljs-title class_">MyComponent</span>, &#123;<br>    <span class="hljs-attr">props</span>: &#123;<br>      <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;Hello Vue 3&#x27;</span><br>    &#125;<br>  &#125;);<br>  <span class="hljs-title function_">expect</span>(wrapper.<span class="hljs-title function_">text</span>()).<span class="hljs-title function_">toContain</span>(<span class="hljs-string">&#x27;Hello Vue 3&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="使用-Jest-和-Vue-Test-Utils"><a href="#使用-Jest-和-Vue-Test-Utils" class="headerlink" title="使用 Jest 和 Vue Test Utils"></a>使用 Jest 和 Vue Test Utils</h4><h5 id="安装-Jest-和-Vue-Test-Utils"><a href="#安装-Jest-和-Vue-Test-Utils" class="headerlink" title="安装 Jest 和 Vue Test Utils"></a>安装 Jest 和 Vue Test Utils</h5><p>首先，安装 Jest 和 Vue Test Utils：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save-dev jest @vue/test-utils vue-jest<br></code></pre></td></tr></table></figure><h5 id="配置-Jest"><a href="#配置-Jest" class="headerlink" title="配置 Jest"></a>配置 Jest</h5><p>创建或更新 <code>jest.config.js</code> 文件，以配置 Jest 以支持 Vue 文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">moduleFileExtensions</span>: [<span class="hljs-string">&#x27;js&#x27;</span>, <span class="hljs-string">&#x27;json&#x27;</span>, <span class="hljs-string">&#x27;vue&#x27;</span>],<br>  <span class="hljs-attr">transform</span>: &#123;<br>    <span class="hljs-string">&#x27;^.+\\.vue$&#x27;</span>: <span class="hljs-string">&#x27;vue-jest&#x27;</span>,<br>    <span class="hljs-string">&#x27;^.+\\.js$&#x27;</span>: <span class="hljs-string">&#x27;babel-jest&#x27;</span><br>  &#125;,<br>  <span class="hljs-attr">testEnvironment</span>: <span class="hljs-string">&#x27;jsdom&#x27;</span><br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="编写测试"><a href="#编写测试" class="headerlink" title="编写测试"></a>编写测试</h5><p>使用 Jest 和 Vue Test Utils 编写和运行测试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// MyComponent.spec.js</span><br><span class="hljs-keyword">import</span> &#123; mount &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@vue/test-utils&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">MyComponent</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/MyComponent.vue&#x27;</span>;<br><br><span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;renders a message&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> wrapper = <span class="hljs-title function_">mount</span>(<span class="hljs-title class_">MyComponent</span>, &#123;<br>    <span class="hljs-attr">props</span>: &#123;<br>      <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;Hello Vue 3&#x27;</span><br>    &#125;<br>  &#125;);<br>  <span class="hljs-title function_">expect</span>(wrapper.<span class="hljs-title function_">text</span>()).<span class="hljs-title function_">toContain</span>(<span class="hljs-string">&#x27;Hello Vue 3&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>运行测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm run <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><h4 id="端到端测试（E2E）"><a href="#端到端测试（E2E）" class="headerlink" title="端到端测试（E2E）"></a>端到端测试（E2E）</h4><p>端到端测试（E2E）是从用户的角度对应用进行测试。它们通常覆盖从前端到后端的整个应用流程，以确保应用的各个部分协同工作。Cypress 是一个流行的 E2E 测试框架，简单易用且功能强大。</p><h5 id="什么是端到端测试（E2E）"><a href="#什么是端到端测试（E2E）" class="headerlink" title="什么是端到端测试（E2E）"></a>什么是端到端测试（E2E）</h5><p>端到端测试（E2E）是指对应用程序的整个流程进行测试，从用户的输入开始，到后端处理、数据库存储，再到最终的输出结果。E2E 测试的目标是模拟用户行为，确保应用程序的各个部分能够协同工作。</p><h5 id="为什么选择-Cypress-进行-E2E-测试"><a href="#为什么选择-Cypress-进行-E2E-测试" class="headerlink" title="为什么选择 Cypress 进行 E2E 测试"></a>为什么选择 Cypress 进行 E2E 测试</h5><p>Cypress 是一个功能强大的 E2E 测试工具，具有以下优点：</p><ol><li><strong>易于使用</strong>：Cypress 提供了直观的 API 和友好的界面，使得编写和运行测试变得简单。</li><li><strong>快速反馈</strong>：Cypress 具有快速的测试运行速度和实时重载功能，可以立即看到测试结果。</li><li><strong>自动截图和录制视频</strong>：在测试失败时，Cypress 会自动截取失败时的屏幕截图，并录制测试过程的视频，便于调试。</li><li><strong>丰富的插件和扩展</strong>：Cypress 提供了许多插件和扩展，可以集成到各种 CI&#x2F;CD 工具中。</li></ol><h5 id="安装-Cypress"><a href="#安装-Cypress" class="headerlink" title="安装 Cypress"></a>安装 Cypress</h5><p>首先，安装 Cypress：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save-dev cypress<br></code></pre></td></tr></table></figure><h5 id="编写-E2E-测试"><a href="#编写-E2E-测试" class="headerlink" title="编写 E2E 测试"></a>编写 E2E 测试</h5><p>创建一个 E2E 测试文件，例如 <code>cypress/integration/sample_spec.js</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">describe</span>(<span class="hljs-string">&#x27;My First Test&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;Visits the app root url&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    cy.<span class="hljs-title function_">visit</span>(<span class="hljs-string">&#x27;/&#x27;</span>);<br>    cy.<span class="hljs-title function_">contains</span>(<span class="hljs-string">&#x27;h1&#x27;</span>, <span class="hljs-string">&#x27;Welcome to Your Vue.js App&#x27;</span>);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>在这个示例中，我们定义了一个基本的测试用例，验证是否能够访问应用的根 URL，并检查页面中是否包含特定文本。</p><h5 id="运行-Cypress"><a href="#运行-Cypress" class="headerlink" title="运行 Cypress"></a>运行 Cypress</h5><p>启动 Cypress 测试运行器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npx cypress open<br></code></pre></td></tr></table></figure><p>然后选择要运行的测试文件，Cypress 会打开一个新的浏览器窗口并运行测试。</p><h5 id="编写更多复杂的-E2E-测试"><a href="#编写更多复杂的-E2E-测试" class="headerlink" title="编写更多复杂的 E2E 测试"></a>编写更多复杂的 E2E 测试</h5><p>除了基本的页面访问测试，Cypress 还可以编写更复杂的 E2E 测试。例如，测试用户登录、表单提交和数据交互等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">describe</span>(<span class="hljs-string">&#x27;User Login Test&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-title function_">it</span>(<span class="hljs-string">&#x27;Logs in the user&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    cy.<span class="hljs-title function_">visit</span>(<span class="hljs-string">&#x27;/login&#x27;</span>);<br>    cy.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;input[name=username]&#x27;</span>).<span class="hljs-title function_">type</span>(<span class="hljs-string">&#x27;myusername&#x27;</span>);<br>    cy.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;input[name=password]&#x27;</span>).<span class="hljs-title function_">type</span>(<span class="hljs-string">&#x27;mypassword&#x27;</span>);<br>    cy.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;button[type=submit]&#x27;</span>).<span class="hljs-title function_">click</span>();<br>    cy.<span class="hljs-title function_">url</span>().<span class="hljs-title function_">should</span>(<span class="hljs-string">&#x27;include&#x27;</span>, <span class="hljs-string">&#x27;/dashboard&#x27;</span>);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>在这个示例中，我们测试了用户登录功能，包括访问登录页面、输入用户名和密码、点击登录按钮，并验证重定向到仪表板页面。</p><h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>通过这篇文章，我们详细介绍了 Vue 3 的测试方法，包括单元测试、组件测试、以及端到端测试（E2E）。使用 Jest 和 Vue Test Utils 进行单元和组件测试，可以有效确保代码的质量和稳定性。而使用 Cypress 进行端到端测试，则可以从整体上验证应用的功能和用户体验。</p>]]></content>
    
    
    <categories>
      
      <category>前端开发手册</category>
      
      <category>进阶奇妙旅程：解锁 Vue3 的高级魔法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
      <tag>vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>路由管理</title>
    <link href="/2024/06/06/frontendGuide/vue3/router/"/>
    <url>/2024/06/06/frontendGuide/vue3/router/</url>
    
    <content type="html"><![CDATA[<h1 id="路由管理"><a href="#路由管理" class="headerlink" title="路由管理"></a>路由管理</h1><h2 id="路由的概念"><a href="#路由的概念" class="headerlink" title="路由的概念"></a>路由的概念</h2><p><strong>路由</strong>指的是确定如何响应应用程序的特定请求的机制。它通常将请求映射到相应的处理程序或页面。在Web开发中，路由通常涉及到根据URL路径来显示不同的内容或页面。</p><h2 id="前端路由-vs-后端路由"><a href="#前端路由-vs-后端路由" class="headerlink" title="前端路由 vs 后端路由"></a>前端路由 vs 后端路由</h2><ul><li><p><strong>后端路由</strong>：</p><ul><li>在传统的Web应用中，后端路由指的是请求发送到服务器，服务器根据请求的URL来确定返回什么内容。</li><li>后端路由通常是基于RESTful API或者其他服务器端框架（如Express.js、Django等）来处理的。</li><li>服务器端进行页面的重新加载和渲染，因此在切换页面时会导致整个页面的刷新。</li></ul></li><li><p><strong>前端路由</strong>：</p><ul><li>前端路由是在浏览器端（客户端）处理路由的一种方式。</li><li>它使用JavaScript来处理URL的变化，并在不重新加载整个页面的情况下更新视图。</li><li>前端路由通常与单页面应用程序（SPA）一起使用，SPA 可以在加载应用程序后通过JavaScript动态地更新页面内容，而不需要重新加载整个页面。</li></ul></li></ul><h2 id="为什么使用前端路由？"><a href="#为什么使用前端路由？" class="headerlink" title="为什么使用前端路由？"></a>为什么使用前端路由？</h2><p>使用前端路由（尤其是在SPA中）有以下几个优点：</p><ul><li><strong>更快的页面切换</strong>：因为不需要重新加载整个页面，只是更新部分内容，所以页面切换更加流畅。</li><li><strong>更好的用户体验</strong>：用户在导航和操作时感觉更快和更自然，因为不会看到页面的闪烁或重新加载。</li><li><strong>更少的服务器负担</strong>：大部分页面逻辑在客户端处理，减轻了服务器的负担，节约了带宽和服务器资源。</li></ul><h2 id="哈希路由-vs-History-路由"><a href="#哈希路由-vs-History-路由" class="headerlink" title="哈希路由 vs History 路由"></a>哈希路由 vs History 路由</h2><p>在前端路由中，有两种常见的实现方式：哈希路由（Hash-based routing）和历史路由（History-based routing）。</p><ul><li><p><strong>哈希路由</strong>：</p><ul><li>使用URL中的 <code>#</code> 符号来模拟路由，例如 <code>http://example.com/#/page1</code>。</li><li>浏览器在哈希符号后的变化不会导致页面重新加载，可以通过监听 <code>hashchange</code> 事件来处理路由变化。</li><li>支持老版本浏览器，但在SEO优化和URL美观性上存在一些限制。</li></ul></li><li><p><strong>History 路由</strong>：</p><ul><li>使用HTML5 History API（<code>history.pushState</code> 和 <code>history.replaceState</code>）来管理URL，例如 <code>http://example.com/page1</code>。</li><li>可以通过修改URL路径来实现路由，不需要 <code>#</code> 符号。</li><li>更好的支持SEO，因为URL更加干净和语义化。</li><li>需要浏览器支持HTML5 History API，对于不支持的浏览器需要有降级方案。</li></ul></li></ul><h2 id="Vue-Router"><a href="#Vue-Router" class="headerlink" title="Vue Router"></a>Vue Router</h2><p>Vue Router 是 Vue.js 官方的路由管理器，它使得 Vue.js 单页面应用（SPA）的开发变得简单和高效。Vue Router 4 是为 Vue 3 设计的版本，提供了更好的性能和更多的功能。本文将介绍 Vue Router 4 的基本使用、动态路由与嵌套路由、路由守卫与懒加载以及导航守卫的使用。</p><h3 id="Vue-Router-4-的基本使用"><a href="#Vue-Router-4-的基本使用" class="headerlink" title="Vue Router 4 的基本使用"></a>Vue Router 4 的基本使用</h3><h4 id="安装-Vue-Router"><a href="#安装-Vue-Router" class="headerlink" title="安装 Vue Router"></a>安装 Vue Router</h4><p>首先，安装 Vue Router：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install vue-router@4<br></code></pre></td></tr></table></figure><h4 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h4><p>在项目中配置 Vue Router：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/router.js</span><br><span class="hljs-keyword">import</span> &#123; createRouter, createWebHistory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Home</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../views/Home.vue&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">About</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../views/About.vue&#x27;</span>;<br><br><span class="hljs-keyword">const</span> routes = [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Home&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-title class_">Home</span>,<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/about&#x27;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;About&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-title class_">About</span>,<br>  &#125;,<br>];<br><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br>  <span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHistory</span>(process.<span class="hljs-property">env</span>.<span class="hljs-property">BASE_URL</span>),<br>  routes,<br>&#125;);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router;<br></code></pre></td></tr></table></figure><h4 id="使用路由"><a href="#使用路由" class="headerlink" title="使用路由"></a>使用路由</h4><p>在主应用中引入并使用路由：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/main.js</span><br><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span>;<br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span>;<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>);<br>app.<span class="hljs-title function_">use</span>(router);<br>app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>);<br></code></pre></td></tr></table></figure><p>在模板中使用 <code>&lt;router-link&gt;</code> 和 <code>&lt;router-view&gt;</code> 组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">nav</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/&quot;</span>&gt;</span>Home<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/about&quot;</span>&gt;</span>About<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">nav</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="动态路由与嵌套路由"><a href="#动态路由与嵌套路由" class="headerlink" title="动态路由与嵌套路由"></a>动态路由与嵌套路由</h3><h4 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h4><p>动态路由允许我们根据参数动态匹配路径：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/router.js</span><br><span class="hljs-keyword">const</span> routes = [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user/:id&#x27;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;User&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../views/User.vue&#x27;</span>),<br>  &#125;,<br>];<br></code></pre></td></tr></table></figure><p>在组件中获取动态路由参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/views/User.vue</span><br>&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>User ID: &#123;&#123; userId &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&lt;/template&gt;<br><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; useRoute &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> route = <span class="hljs-title function_">useRoute</span>();</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> userId = route.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>;</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      userId</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h4><p>嵌套路由允许在父路由中嵌套子路由：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/router.js</span><br><span class="hljs-keyword">const</span> routes = [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user/:id&#x27;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;User&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../views/User.vue&#x27;</span>),<br>    <span class="hljs-attr">children</span>: [<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;profile&#x27;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;UserProfile&#x27;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../views/UserProfile.vue&#x27;</span>),<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;posts&#x27;</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;UserPosts&#x27;</span>,<br>        <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../views/UserPosts.vue&#x27;</span>),<br>      &#125;,<br>    ],<br>  &#125;,<br>];<br></code></pre></td></tr></table></figure><p>在父组件中使用 <code>&lt;router-view&gt;</code> 以显示子路由组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- src/views/User.vue --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>User ID: &#123;&#123; userId &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123; name: &#x27;UserProfile&#x27;, params: &#123; id: userId &#125;&#125;&quot;</span></span><br><span class="hljs-tag">      &gt;</span>Profile&lt;/router-link<br>    &gt;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">&quot;&#123; name: &#x27;UserPosts&#x27;, params: &#123; id: userId &#125;&#125;&quot;</span></span><br><span class="hljs-tag">      &gt;</span>Posts&lt;/router-link<br>    &gt;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; useRoute &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> route = <span class="hljs-title function_">useRoute</span>();</span><br><span class="language-javascript">      <span class="hljs-keyword">const</span> userId = route.<span class="hljs-property">params</span>.<span class="hljs-property">id</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> &#123;</span><br><span class="language-javascript">        userId,</span><br><span class="language-javascript">      &#125;;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="路由守卫"><a href="#路由守卫" class="headerlink" title="路由守卫"></a>路由守卫</h3><p>路由守卫用于控制导航行为，如验证用户是否登录。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/router/index.js</span><br><span class="hljs-keyword">const</span> routes = [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/dashboard&#x27;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Dashboard&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../views/Dashboard.vue&#x27;</span>),<br>    <span class="hljs-attr">beforeEnter</span>: <span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isLoggedIn</span>()) &#123;<br>        <span class="hljs-title function_">next</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Login&#x27;</span> &#125;);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">next</span>();<br>      &#125;<br>    &#125;,<br>  &#125;,<br>];<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">isLoggedIn</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 模拟登录验证</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="守卫的使用"><a href="#守卫的使用" class="headerlink" title="守卫的使用"></a>守卫的使用</h4><h5 id="全局导航守卫"><a href="#全局导航守卫" class="headerlink" title="全局导航守卫"></a>全局导航守卫</h5><p>全局导航守卫可以在路由实例上进行配置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/router.js</span><br>router.<span class="hljs-title function_">beforeEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Navigating to <span class="hljs-subst">$&#123;to.name&#125;</span> from <span class="hljs-subst">$&#123;<span class="hljs-keyword">from</span>.name&#125;</span>`</span>);<br>  <span class="hljs-title function_">next</span>();<br>&#125;);<br><br>router.<span class="hljs-title function_">afterEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Navigated to <span class="hljs-subst">$&#123;to.name&#125;</span> from <span class="hljs-subst">$&#123;<span class="hljs-keyword">from</span>.name&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h5 id="路由独享守卫"><a href="#路由独享守卫" class="headerlink" title="路由独享守卫"></a>路由独享守卫</h5><p>路由独享守卫只对特定路由生效。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/router.js</span><br><span class="hljs-keyword">const</span> routes = [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/admin&#x27;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Admin&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../views/Admin.vue&#x27;</span>),<br>    <span class="hljs-attr">beforeEnter</span>: <span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">isAdmin</span>()) &#123;<br>        <span class="hljs-title function_">next</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Home&#x27;</span> &#125;);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">next</span>();<br>      &#125;<br>    &#125;,<br>  &#125;,<br>];<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">isAdmin</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 模拟管理员验证</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="组件内守卫"><a href="#组件内守卫" class="headerlink" title="组件内守卫"></a>组件内守卫</h5><p>组件内守卫用于在组件内部控制导航行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/views/UserProfile.vue</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">beforeRouteEnter</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;beforeRouteEnter&#x27;</span>);<br>    <span class="hljs-title function_">next</span>();<br>  &#125;,<br>  <span class="hljs-title function_">beforeRouteUpdate</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;beforeRouteUpdate&#x27;</span>);<br>    <span class="hljs-title function_">next</span>();<br>  &#125;,<br>  <span class="hljs-title function_">beforeRouteLeave</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;beforeRouteLeave&#x27;</span>);<br>    <span class="hljs-title function_">next</span>();<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li><strong>全局导航守卫</strong>：适用于需要在所有路由变化时执行逻辑的场景，例如日志记录、全局权限检查等。</li><li><strong>路由独享守卫</strong>：适用于需要特定路由进行额外验证或处理的场景，例如管理员页面的访问控制。</li><li><strong>组件内守卫</strong>：适用于需要在组件内控制导航行为的场景，例如在离开当前页面前提示用户保存未保存的更改。</li></ul><h3 id="路由懒加载"><a href="#路由懒加载" class="headerlink" title="路由懒加载"></a>路由懒加载</h3><p>路由懒加载可以减少初始加载时间，提高应用性能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/router.js</span><br><span class="hljs-keyword">const</span> routes = [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/about&#x27;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;About&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../views/About.vue&#x27;</span>),<br>  &#125;,<br>];<br></code></pre></td></tr></table></figure><p>通过以上内容，您可以在 Vue 3 中实现路由的基本使用、动态路由与嵌套路由、路由守卫与懒加载以及导航守卫的使用，从而更好地管理单页面应用的导航和访问控制。</p>]]></content>
    
    
    <categories>
      
      <category>前端开发手册</category>
      
      <category>Vue3 奇妙之旅：轻松掌握新语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
      <tag>vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>状态管理</title>
    <link href="/2024/06/06/frontendGuide/vue3/state/"/>
    <url>/2024/06/06/frontendGuide/vue3/state/</url>
    
    <content type="html"><![CDATA[<h1 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h1><p>在大型单页面应用中，管理复杂的状态变得至关重要。Vuex 是 Vue.js 的官方状态管理库，提供了集中式存储和管理应用所有组件的状态。Vuex 4 是为 Vue 3 设计的版本。本文将概述 Vuex 4，介绍 State、Getter、Mutation、Action 的使用，模块化状态管理，以及如何使用 Composition API 管理状态。</p><h2 id="Vuex-4-概述"><a href="#Vuex-4-概述" class="headerlink" title="Vuex 4 概述"></a>Vuex 4 概述</h2><p>Vuex 4 是一个专为 Vue 3 设计的状态管理库，它提供了一种集中式的方式来管理应用的所有状态。它的核心概念包括 State、Getter、Mutation 和 Action，这些概念帮助开发者以结构化和可维护的方式管理状态。</p><h3 id="安装-Vuex"><a href="#安装-Vuex" class="headerlink" title="安装 Vuex"></a>安装 Vuex</h3><p>首先，安装 Vuex：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install vuex@next<br></code></pre></td></tr></table></figure><h3 id="创建-Vuex-Store"><a href="#创建-Vuex-Store" class="headerlink" title="创建 Vuex Store"></a>创建 Vuex Store</h3><p>在项目中创建一个 Vuex Store：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/store/index.js</span><br><span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span>;<br><br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(&#123;<br>  <span class="hljs-attr">state</span>: &#123;<br>    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br>  &#125;,<br>  <span class="hljs-attr">getters</span>: &#123;<br>    <span class="hljs-attr">doubleCount</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">count</span> * <span class="hljs-number">2</span><br>  &#125;,<br>  <span class="hljs-attr">mutations</span>: &#123;<br>    <span class="hljs-title function_">increment</span>(<span class="hljs-params">state</span>) &#123;<br>      state.<span class="hljs-property">count</span>++;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">actions</span>: &#123;<br>    <span class="hljs-title function_">incrementAsync</span>(<span class="hljs-params">&#123; commit &#125;</span>) &#123;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;increment&#x27;</span>);<br>      &#125;, <span class="hljs-number">1000</span>);<br>    &#125;<br>  &#125;<br>&#125;);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store;<br></code></pre></td></tr></table></figure><h3 id="使用-Vuex-Store"><a href="#使用-Vuex-Store" class="headerlink" title="使用 Vuex Store"></a>使用 Vuex Store</h3><p>在主应用中引入并使用 Vuex Store：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/main.js</span><br><span class="hljs-keyword">import</span> &#123; createApp &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span>;<br><span class="hljs-keyword">import</span> store <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./store&#x27;</span>;<br><br><span class="hljs-keyword">const</span> app = <span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>);<br>app.<span class="hljs-title function_">use</span>(store);<br>app.<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>);<br></code></pre></td></tr></table></figure><h2 id="State、Getter、Mutation、Action-的使用"><a href="#State、Getter、Mutation、Action-的使用" class="headerlink" title="State、Getter、Mutation、Action 的使用"></a>State、Getter、Mutation、Action 的使用</h2><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>State 用于存储应用的状态数据。可以通过 <code>store.state</code> 访问状态。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/store/index.js</span><br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(&#123;<br>  <span class="hljs-attr">state</span>: &#123;<br>    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>在组件中访问 State：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Count: &#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; useStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">useStore</span>();</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>);</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123; count &#125;;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h3><p>Getters 用于从 State 中派生出一些状态，可以认为是 State 的计算属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/store/index.js</span><br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(&#123;<br>  <span class="hljs-attr">state</span>: &#123;<br>    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br>  &#125;,<br>  <span class="hljs-attr">getters</span>: &#123;<br>    <span class="hljs-attr">doubleCount</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">count</span> * <span class="hljs-number">2</span><br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>在组件中访问 Getter：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Double Count: &#123;&#123; doubleCount &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; useStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">useStore</span>();</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> doubleCount = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">getters</span>.<span class="hljs-property">doubleCount</span>);</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123; doubleCount &#125;;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h3><p>Mutations 用于更改 State，它是 Vuex 唯一改变状态的方法。通过 <code>commit</code> 方法来触发 Mutation。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/store/index.js</span><br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(&#123;<br>  <span class="hljs-attr">state</span>: &#123;<br>    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br>  &#125;,<br>  <span class="hljs-attr">mutations</span>: &#123;<br>    <span class="hljs-title function_">increment</span>(<span class="hljs-params">state</span>) &#123;<br>      state.<span class="hljs-property">count</span>++;<br>    &#125;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>在组件中提交 Mutation：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Count: &#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment&quot;</span>&gt;</span>Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; useStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">useStore</span>();</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>);</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">      store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;increment&#x27;</span>);</span><br><span class="language-javascript">    &#125;;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123; count, increment &#125;;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>Actions 类似于 Mutations，但它是用于处理异步操作。通过 <code>dispatch</code> 方法来触发 Action。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/store/index.js</span><br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(&#123;<br>  <span class="hljs-attr">state</span>: &#123;<br>    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br>  &#125;,<br>  <span class="hljs-attr">mutations</span>: &#123;<br>    <span class="hljs-title function_">increment</span>(<span class="hljs-params">state</span>) &#123;<br>      state.<span class="hljs-property">count</span>++;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">actions</span>: &#123;<br>    <span class="hljs-title function_">incrementAsync</span>(<span class="hljs-params">&#123; commit &#125;</span>) &#123;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;increment&#x27;</span>);<br>      &#125;, <span class="hljs-number">1000</span>);<br>    &#125;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>在组件中分发 Action：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Count: &#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;incrementAsync&quot;</span>&gt;</span>Increment Async<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; useStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">useStore</span>();</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>);</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> <span class="hljs-title function_">incrementAsync</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">      store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;incrementAsync&#x27;</span>);</span><br><span class="language-javascript">    &#125;;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123; count, incrementAsync &#125;;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="模块化状态管理"><a href="#模块化状态管理" class="headerlink" title="模块化状态管理"></a>模块化状态管理</h2><p>当应用变得越来越复杂时，可以将 Store 拆分成模块，每个模块具有自己的 State、Getter、Mutation 和 Action。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/store/modules/counter.js</span><br><span class="hljs-keyword">const</span> counter = &#123;<br>  <span class="hljs-attr">state</span>: <span class="hljs-function">() =&gt;</span> (&#123;<br>    <span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br>  &#125;),<br>  <span class="hljs-attr">getters</span>: &#123;<br>    <span class="hljs-attr">doubleCount</span>: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.<span class="hljs-property">count</span> * <span class="hljs-number">2</span><br>  &#125;,<br>  <span class="hljs-attr">mutations</span>: &#123;<br>    <span class="hljs-title function_">increment</span>(<span class="hljs-params">state</span>) &#123;<br>      state.<span class="hljs-property">count</span>++;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">actions</span>: &#123;<br>    <span class="hljs-title function_">incrementAsync</span>(<span class="hljs-params">&#123; commit &#125;</span>) &#123;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;increment&#x27;</span>);<br>      &#125;, <span class="hljs-number">1000</span>);<br>    &#125;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> counter;<br></code></pre></td></tr></table></figure><p>在主 Store 中引入模块：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// src/store/index.js</span><br><span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span>;<br><span class="hljs-keyword">import</span> counter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./modules/counter&#x27;</span>;<br><br><span class="hljs-keyword">const</span> store = <span class="hljs-title function_">createStore</span>(&#123;<br>  <span class="hljs-attr">modules</span>: &#123;<br>    counter<br>  &#125;<br>&#125;);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store;<br></code></pre></td></tr></table></figure><h2 id="使用-Composition-API-管理状态"><a href="#使用-Composition-API-管理状态" class="headerlink" title="使用 Composition API 管理状态"></a>使用 Composition API 管理状态</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Count: &#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment&quot;</span>&gt;</span>Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;incrementAsync&quot;</span>&gt;</span>Increment Async<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; useStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> store = <span class="hljs-title function_">useStore</span>();</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> store.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>);</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> <span class="hljs-title function_">increment</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">      store.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;increment&#x27;</span>);</span><br><span class="language-javascript">    &#125;;</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> <span class="hljs-title function_">incrementAsync</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">      store.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;incrementAsync&#x27;</span>);</span><br><span class="language-javascript">    &#125;;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span> &#123; count, increment, incrementAsync &#125;;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="使用-Options-API-管理状态"><a href="#使用-Options-API-管理状态" class="headerlink" title="使用 Options API 管理状态"></a>使用 Options API 管理状态</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Count: &#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment&quot;</span>&gt;</span>Increment<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;incrementAsync&quot;</span>&gt;</span>Increment Async<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">// options api</span></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">computed</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">count</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span>;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-title function_">doubleCount</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-property">getters</span>.<span class="hljs-property">doubleCount</span>;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">commit</span>(<span class="hljs-string">&#x27;increment&#x27;</span>);</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-title function_">incrementAsync</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">$store</span>.<span class="hljs-title function_">dispatch</span>(<span class="hljs-string">&#x27;incrementAsync&#x27;</span>);</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">&#125;; </span><br></code></pre></td></tr></table></figure><p>通过以上内容，您可以在 Vue 3 中使用 Vuex 4 管理应用状态，包括 State、Getter、Mutation、Action 的使用，模块化状态管理，以及结合 Composition API 来管理状态。这将使得您的应用更具结构化、可维护性和扩展性。</p>]]></content>
    
    
    <categories>
      
      <category>前端开发手册</category>
      
      <category>Vue3 奇妙之旅：轻松掌握新语法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
      <tag>vue3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一节：项目搭建</title>
    <link href="/2024/06/06/frontendGuide/actualCombat/project/leason-01/"/>
    <url>/2024/06/06/frontendGuide/actualCombat/project/leason-01/</url>
    
    <content type="html"><![CDATA[<h1 id="第一节：项目搭建"><a href="#第一节：项目搭建" class="headerlink" title="第一节：项目搭建"></a>第一节：项目搭建</h1><p>大家好，当你点进这个标题，开始阅读本章的时候，说明你对 Vue.js 是充满好奇心和求知欲的。 正如其官网介绍的“易用，灵活和高效”那样。其实框架是 Vue.js 的本质，而真正了解它的人则会把它当成一件作品来欣赏。</p><p>Vue.js 作为一门轻量级、易上手的前端框架，从入门难度和学习曲线上相对其他框架来说算是占据优势的，越来越多的人开始投入 Vue.js 的怀抱，走进 Vue.js 的世界。那么接下来屏幕前的你不妨一起来和我从零开始构建一个 Vue 项目，体会一下 Vue.js 的精彩绝伦。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>在构建一个 Vue 项目前，我们先要确保你本地安装了 Node 环境以及包管理工具 npm，打开终端运行：</p><h4 id="查看-node-版本"><a href="#查看-node-版本" class="headerlink" title="查看 node 版本"></a>查看 node 版本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">node -v<br></code></pre></td></tr></table></figure><h4 id="查看-npm-版本"><a href="#查看-npm-版本" class="headerlink" title="查看 npm 版本"></a>查看 npm 版本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm -v<br></code></pre></td></tr></table></figure><p>如果成功打印出版本号，说明你本地具备了 <code>node</code> 的运行环境，我们可以使用 npm 来安装管理项目的依赖，而如果没有或报错，则你需要去 <a href="https://nodejs.org/en/download/package-manager">node 官网</a> 进行 node 的下载及安装，如图：</p><p><img src="/../../img/frontendGuide/actualCombat/project/x-0005.png" alt="MACOS"></p><p><img src="/../../img/frontendGuide/actualCombat/project/x-0006.png" alt="WINDOWS"></p><p>这里建议大家安装最新的  <code>node</code>  稳定版进行开发，实际开发时需要提前了解项目所使用<code>node</code>版本需要进行相关版本安装。接下来的示例采用Node<code>v18.18.0</code>版本, 为顺利进行后续示例调试，推荐大家使用<code>v18.18.0+</code>版本。</p><h4 id="用pnpm替代npm"><a href="#用pnpm替代npm" class="headerlink" title="用pnpm替代npm"></a>用pnpm替代npm</h4><p>本次我们使用pnpm替代Node环境自带的依赖管理工具npm。所以需要全局安装pnpm。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g pnpm<br></code></pre></td></tr></table></figure><p>安装时可能需要必要系统权限 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># MACOS用户需要使用sudo命令</span><br>sudo npm install -g pnpm<br><br><span class="hljs-comment"># Windows用户需要管理员权限</span><br><span class="hljs-comment"># 管理员权限打开命令行窗口</span><br>npm install -g pnpm<br></code></pre></td></tr></table></figure><p>查看 pnpm 版本, 如果成功打印出版本号，说明你本地的全局pnpm工具已成功安装。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm -v<br></code></pre></td></tr></table></figure><h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>执行以下命令创建新项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm create vite my-vue-app --template vue-ts<br></code></pre></td></tr></table></figure><p><img src="/../../img/frontendGuide/actualCombat/project/001.png"></p><p>进入项目目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> my-vue-app<br></code></pre></td></tr></table></figure><p>项目初始化目录如下</p><p><img src="/../../img/frontendGuide/actualCombat/project/x-0001.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash">├── .vscode  // 编辑器配置<br>├── node_modules // 项目安装依赖包集合文件夹<br>├── README.md // 项目手册<br>├── index.html // 项目主入口HTML <br>├── package.json // 依赖配置文件<br>├── public // 公共静态文件夹, 纯静态资源（文件、图片等） 打包构建时，vite不会做任何处理<br>│   └── vite.svg // 页签图标文件<br>├── src // 项目核心文件夹（包括项目源码，各种静态资源）<br>│   ├── App.vue<br>│   ├── assets // 资源文件夹，后续出台<br>│   │   └── vue.svg<br>│   ├── components // 公共组件文件夹<br>│   │   └── HelloWorld.vue // 示例组件文件<br>│   ├── main.ts // vue实例化入口文件，也是整个应用的入口<br>│   ├── style.css // 基础样式文件<br>│   └── vite-env.d.ts // TypeScript的智能提示（环境变量）<br>├── tsconfig.app.json// TypeScript 项目的配置文件<br>├── tsconfig.json // TypeScript 项目的配置文件<br>├── tsconfig.node.json // TypeScript 项目的配置文件<br>└── vite.config.ts // vite项目配置文件(本地开发服务器或者构建等相关配置)<br></code></pre></td></tr></table></figure><h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm install<br></code></pre></td></tr></table></figure><p><img src="/../../img/frontendGuide/actualCombat/project/002.png"></p><h2 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm run dev<br></code></pre></td></tr></table></figure><p><img src="/../../img/frontendGuide/actualCombat/project/x-0002.png"></p><p>浏览器打开  <a href="http://localhost:5173/">http://localhost:5173</a>  即可看到项目启动成功</p><p><img src="/../../img/frontendGuide/actualCombat/project/x-0003.png"></p><h2 id="本地开发基础配置"><a href="#本地开发基础配置" class="headerlink" title="本地开发基础配置"></a>本地开发基础配置</h2><h4 id="设置本地开发服务器端口号"><a href="#设置本地开发服务器端口号" class="headerlink" title="设置本地开发服务器端口号"></a>设置本地开发服务器端口号</h4><p>在 <code>vite.config.ts</code>  中设置本地开发启动端口号，比如如下调整为3000端口。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// vite.config.ts</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">vue</span>()],<br>  <span class="hljs-attr">server</span>: &#123;<br>    <span class="hljs-attr">port</span>: <span class="hljs-number">3000</span> <span class="hljs-comment">// vue3 本地项目启动端口号设置</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>保存完配置文件后，使用<code>pnpm run dev</code>重新启动后，浏览器打开 <a href="http://localhost:3000/">http://localhost:3000</a> 即可看到新端口访问打开的项目页面。</p><p><img src="/../../img/frontendGuide/actualCombat/project/x-0007.png"></p><p><img src="/../../img/frontendGuide/actualCombat/project/x-0008.png"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本节课程结束了，恭喜你成功创建了一个基于 Vue 3、Vite 和 TypeScript 的前端项目，并完成了基本的端口配置。接下来，我们将继续深入学习，快速上手项目开发。最终，我们将一起完成一个常见的检索表格功能（如下图所示）。本节完整源码可在 <a href="http://gitlab.it.5i5j.com/fex/my-vue-app/tree/leason-01">gitlab</a> 查看。</p><p><img src="/../../img/frontendGuide/actualCombat/project/x-0004.png"></p>]]></content>
    
    
    <categories>
      
      <category>前端开发手册</category>
      
      <category>从零开始：手把手教你打造炫酷新页面</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发手册</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第二节：页面搭建</title>
    <link href="/2024/06/06/frontendGuide/actualCombat/project/leason-02/"/>
    <url>/2024/06/06/frontendGuide/actualCombat/project/leason-02/</url>
    
    <content type="html"><![CDATA[<h1 id="第二节：页面搭建"><a href="#第二节：页面搭建" class="headerlink" title="第二节：页面搭建"></a>第二节：页面搭建</h1><p>大家好，欢迎来到第二节课。在第一节课中，我们已经完成了项目的初始化。接下来，我们将开始搭建页面。在上一节的结尾，我们明确了课程的最终目标，即完成一个检索列表页面（如下图所示）：</p><p><img src="/../../img/frontendGuide/actualCombat/project/x-0004.png"></p><p>页面布局上包括标题、检索表单、检索结果列表和分页器等部分，接下来我们将开始搭建页面，并完成以上目标。</p><h2 id="初始化页面"><a href="#初始化页面" class="headerlink" title="初始化页面"></a>初始化页面</h2><h3 id="1-创建列表页面"><a href="#1-创建列表页面" class="headerlink" title="1. 创建列表页面"></a>1. 创建列表页面</h3><p>在 <code>src</code> 目录下创建 <code>pages</code> 目录，并在 <code>pages</code> 目录下创建 <code>list.vue</code> 文件，作为检索列表页面的入口文件。</p><p>在<code>src/pages/list.vue</code> 文件内模版代码， 如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>      列表页面<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>  <br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-添加页面路由"><a href="#2-添加页面路由" class="headerlink" title="2. 添加页面路由"></a>2. 添加页面路由</h3><h4 id="安装-vue-router"><a href="#安装-vue-router" class="headerlink" title="安装 vue-router"></a>安装 <code>vue-router</code></h4><blockquote><p><code>vue-router</code> 是 <code>Vue</code>官方的客户端路由解决方案。</p></blockquote><p>在项目根目录下执行以下命令，安装 <code>vue-router</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm install vue-router<br></code></pre></td></tr></table></figure><p><img src="/../../img/frontendGuide/actualCombat/project/x-0009.png" alt="vue-router安装"></p><p>安装成功后package.json内依赖会同步增加vue-router项</p><p><img src="/../../img/frontendGuide/actualCombat/project/x-0010.png" alt="package.json"></p><h4 id="配置路由"><a href="#配置路由" class="headerlink" title="配置路由"></a>配置路由</h4><p>a. 在 <code>src</code> 目录下创建 <code>router</code> 目录，并在 <code>router</code> 目录下创建 <code>index.ts</code> 文件，作为路由配置文件。</p><p> <code>src/router/index.ts</code> 文件中添加list页面路由（PS：之后新增页面访问路由在此文件添加即可）：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">//src/router/index.ts </span><br><span class="hljs-keyword">import</span> &#123; createWebHistory, createRouter, <span class="hljs-title class_">RouteRecordRaw</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><br><span class="hljs-comment">// 定义路由（路由懒加载组件）</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">routes</span>: <span class="hljs-title class_">RouteRecordRaw</span>[] = [<br>  &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Home&#x27;</span>, <span class="hljs-attr">redirect</span>: <span class="hljs-string">&#x27;/list&#x27;</span> &#125;, <span class="hljs-comment">// 根路径重定向到/list页面</span><br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/list&#x27;</span>, <span class="hljs-comment">// 页面路径</span><br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;List&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../pages/list.vue&#x27;</span>), <span class="hljs-comment">// 页面组件</span><br>  &#125;,<br>]<br><br><span class="hljs-comment">// 创建路由的实例对象</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br>  <span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHistory</span>(),<br>  routes,<br>&#125;)<br><br><span class="hljs-comment">// 向外共享路由的实例对象</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router<br></code></pre></td></tr></table></figure><p>b. 在 <code>src/main.ts</code> 入口文件中引入路由配置</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// src/main.ts</span><br>...<br><br><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span><br><br><span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)<br>  .<span class="hljs-title function_">use</span>(router)<br>  .<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="/../../img/frontendGuide/actualCombat/project/x-0011.png" alt="src/main.ts"></p><p>c. 修改 <code>src/app.vue</code> 文件代码，加入 <code>RotuerView</code>组件，用来渲染路由组件。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>d. 修改 <code>src/style.css</code> 文件代码，重置元素默认样式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">html</span>, <span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>&#125;<br><span class="hljs-selector-id">#app</span> &#123;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> auto;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#fff</span>;<br>  <span class="hljs-attribute">overflow-x</span>: hidden;<br>  <span class="hljs-attribute">overflow-y</span>: auto;<br>  <span class="hljs-attribute">box-sizing</span>: border-box;<br>&#125;<br></code></pre></td></tr></table></figure><p>至此我们初始化页面已经基本完成，浏览器打开 <a href="http://localhost:3000/list">http://localhost:3000/list</a> 即可看到我们新添加的检索列表页。</p><p><img src="/../../img/frontendGuide/actualCombat/project/x-0012.png"></p><h2 id="使用基础组件库"><a href="#使用基础组件库" class="headerlink" title="使用基础组件库"></a>使用基础组件库</h2><p>一般组件库 为 <code>Web应用</code> 提供了丰富的基础 UI 组件，如 <code>Element Plus</code>、<code>Ant Design Vue</code> 等，能够提高开发效率和保持项目风格一致性，本节我们使用 <code>Ant Design Vue</code> 组件库进行示范。相关组件细节和API可到 <a href="https://antdv.com/docs/vue/introduce-cn">Ant Design Vue官网</a> 查看。</p><p>a. 安装 <code>Ant Design Vue</code> 组件库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm install ant-design-vue@4.x<br></code></pre></td></tr></table></figure><p><img src="/../../img/frontendGuide/actualCombat/project/x-0013.png"></p><p>安装成功后package.json内依赖会同步增加ant-design-vue项</p><p><img src="/../../img/frontendGuide/actualCombat/project/x-0014.png" alt="package.json"></p><p>b. 在 <code>src/main.ts</code> 入口文件中引入 <code>Ant Design Vue</code> 组件库</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// src/main.ts</span><br><span class="hljs-comment">// 全局完整注册</span><br>...<br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Antd</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;ant-design-vue&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;ant-design-vue/dist/reset.css&#x27;</span><br><br><span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>)<br>  .<span class="hljs-title function_">use</span>(router)<br>  .<span class="hljs-title function_">use</span>(<span class="hljs-title class_">Antd</span>)<br>  .<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure><p>c. 在 <code>src/pages/list.vue</code> 中使用 <code>Ant Design Vue</code> 组件库</p><p>增加 <code>a-button</code>按钮组件代码， 测试<code>Ant Design Vue</code>是否已成功全局注册</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>      列表页面<br>      <span class="hljs-tag">&lt;<span class="hljs-name">a-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span>&gt;</span>Primary Button<span class="hljs-tag">&lt;/<span class="hljs-name">a-button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>浏览器打开 <a href="http://localhost:3000/list">http://localhost:3000/list</a> 在检索列表页，看到页面上有了一枚蓝色按钮，恭喜你 <code>Ant Design Vue</code> 组件库可以正常使用了。</p><p><img src="/../../img/frontendGuide/actualCombat/project/x-0015.png"></p><p>d. 设置全局国际化配置为中文</p><p><code>Ant Design Vue</code> 目前的默认文案是英文, 我们为了应用到中文系统开发中需要使用 <a href="https://antdv.com/docs/vue/i18n-cn/#LocaleProvider">LocaleProvider</a> 方案设置全局国际化配置为中文。</p><p><code>Ant Design Vue</code> 提供了一个 Vue 组件 ConfigProvider 用于全局配置国际化文案。ConfigProvider 不包含时间类组件的国际化，你需要额外引入时间库(dayjs、momentjs、date-fns 等)的国际化文件，以下我们以 <code>dayjs</code> 为例。</p><p>这里涉及到使用 <code>dayjs</code> 作为日期处理工具库，然而我们项目现在还未添加过此库的依赖，所以我们现在先安装下 <code>dayjs</code> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装dayjs</span><br>pnpm install dayjs<br></code></pre></td></tr></table></figure><p><code>dayjs</code> 成功安装完成后，我们就可以在<code>src/app.vue</code>内加入如下国际化配置代码了， 这样后续我们使用<code>Ant Design Vue</code>（含时间类组件）就能正常按照中文文案和格式展示了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a-config-provider</span> <span class="hljs-attr">:locale</span>=<span class="hljs-string">&quot;zhCN&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">a-config-provider</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> zhCN <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;ant-design-vue/es/locale/zh_CN&#x27;</span></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> dayjs <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;dayjs&#x27;</span></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;dayjs/locale/zh-cn&#x27;</span></span><br><span class="language-javascript">  dayjs.<span class="hljs-title function_">locale</span>(<span class="hljs-string">&#x27;zh-cn&#x27;</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="使用less替代css"><a href="#使用less替代css" class="headerlink" title="使用less替代css"></a>使用less替代css</h2><blockquote><p>Less是一种由Alexis Sellier设计的动态层叠样式表语言, Less 扩充了CSS 语言，增加了诸如变量、混合（mixin）、运算、函数等功能。 Less 既可以运行在服务器端（Node.js 和Rhino 平台）也可以运行在客户端（浏览器）。</p></blockquote><p>安装 <code>less</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm install -D less<br></code></pre></td></tr></table></figure><h2 id="检索列表页面编写"><a href="#检索列表页面编写" class="headerlink" title="检索列表页面编写"></a>检索列表页面编写</h2><p>进行到现在，我们的准备工作就完成了，接下来就开始进行页面的功能编写了。<br>想要实现的检索列表页面，主要包含标题、检索表单和结果分页列表三部分，下边我们将按照这三部分逐步进行。 </p><h3 id="标题模块编写"><a href="#标题模块编写" class="headerlink" title="标题模块编写"></a>标题模块编写</h3><p>我们拆解下标题模块功能, 其包含的部分比较简单，主要包含标题文案展示和可控折叠下侧包裹的检索表单。</p><p>首先去先前引用的<code>Ant Design Vue</code>文档查找相关的组件，发现<code>a-collapse</code>组件可以满足我们的需求，具体使用方式可以参考<a href="https://www.antdv.com/components/collapse-cn/">Ant Design Vue Collapse</a>。</p><p>a. 按照组件库代码示例，在 <code>src/pages/list.vue</code> 中添加标题模块代码，增加必要的标题文案，如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a-collapse</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a-collapse-panel</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;1&quot;</span> <span class="hljs-attr">header</span>=<span class="hljs-string">&quot;合同检索列表&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>检索表单内容展位<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">a-collapse-panel</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a-collapse</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>访问 <a href="http://localhost:3000/list">http://localhost:3000/list</a> ， 查看展示如下，检查基础折叠功能和标题展示正常，不过也预期有差距，我们接下来进行相关属性配置和调整。</p><p><img src="/../../img/frontendGuide/actualCombat/project/x-0016.png"></p><p>b. 根据预期效果，我们需要调整下属性和折叠样式，修改 <code>src/pages/list.vue</code> 代码如下：</p><p>主要增加以下调整：</p><ul><li>设置当前折叠为展开 <code>const activeKey = ref([&#39;1&#39;])</code></li><li>开启ghost属性，去掉现有边框和背景色样式</li><li>定制化重置折叠collapse组件部分样式</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;search-list&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 折叠标题-包裹检索表单 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a-collapse</span></span><br><span class="hljs-tag">      <span class="hljs-attr">v-model:activeKey</span>=<span class="hljs-string">&quot;activeKey&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">:ghost</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a-collapse-panel</span></span><br><span class="hljs-tag">        <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;1&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">header</span>=<span class="hljs-string">&quot;合同检索列表&quot;</span></span><br><span class="hljs-tag">      &gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>检索表单占位内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">a-collapse-panel</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a-collapse</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">// 设置当前折叠为展开</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> activeKey = <span class="hljs-title function_">ref</span>([<span class="hljs-string">&#x27;1&#x27;</span>])</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;less&quot;</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-comment">/** 定制化重置折叠collapse组件部分样式 </span></span><br><span class="hljs-comment"><span class="language-css">    * :deep用于穿透当前页面样式作用域（scoped），覆盖引用基础组件默认样式</span></span><br><span class="hljs-comment"><span class="language-css">  */</span></span><br><span class="language-css">  </span><br><span class="language-css">  :<span class="hljs-built_in">deep</span>(.ant-collapse-item) &#123;</span><br><span class="language-css">    <span class="hljs-selector-class">.ant-collapse-header</span>&#123;</span><br><span class="language-css">      <span class="hljs-attribute">font-weight</span>: bold;</span><br><span class="language-css">      <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span> <span class="hljs-number">15px</span> <span class="hljs-meta">!important</span>;</span><br><span class="language-css">      <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f2f2f2</span>;</span><br><span class="language-css">      <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">0</span> <span class="hljs-meta">!important</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>调整完，再访问 <a href="http://localhost:3000/list">http://localhost:3000/list</a> ，查看展示如下，现在已完成标题模块编写<br><img src="/../../img/frontendGuide/actualCombat/project/x-0017.png"></p><h3 id="检索表单编写"><a href="#检索表单编写" class="headerlink" title="检索表单编写"></a>检索表单编写</h3><p>我接下来们开始检索表单的编写，首先我们拆解下模块功能如下：</p><p><img src="/../../img/frontendGuide/actualCombat/project/x-0019.png" alt="检索表单模块效果图"></p><p><img src="/../../img/frontendGuide/actualCombat/project/x-0018.png" alt="检索表单模块功能"></p><h4 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h4><p>我们将要实现的检索表单是我们日常常见的表单功能，首先想到的是先实现此种布局，在<code>Ant Design Vue</code>提供了 <a href="https://antdv.com/components/grid-cn">24等分的栅格化系统</a>，基于行（row）和列（col）来定义信息区块的外部框架，以保证页面的每个区域能够稳健地排布起来。所以我们采用<code>Row</code>和<code>Col</code>组件实现检索表单布局如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a-row</span> <span class="hljs-attr">:gutter</span>=<span class="hljs-string">&quot;[20, 10]&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a-col</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;gutter-row&quot;</span> <span class="hljs-attr">:span</span>=<span class="hljs-string">&quot;8&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;gutter-box&quot;</span>&gt;</span>col-8<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a-col</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a-col</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;gutter-row&quot;</span> <span class="hljs-attr">:span</span>=<span class="hljs-string">&quot;8&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;gutter-box&quot;</span>&gt;</span>col-8<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a-col</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a-col</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;gutter-row&quot;</span> <span class="hljs-attr">:span</span>=<span class="hljs-string">&quot;8&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;gutter-box&quot;</span>&gt;</span>col-8<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a-col</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a-col</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;gutter-row&quot;</span> <span class="hljs-attr">:span</span>=<span class="hljs-string">&quot;8&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;gutter-box&quot;</span>&gt;</span>col-8<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a-col</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a-col</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;gutter-row&quot;</span> <span class="hljs-attr">:span</span>=<span class="hljs-string">&quot;8&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;gutter-box&quot;</span>&gt;</span>col-8<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a-col</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a-col</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;gutter-row&quot;</span> <span class="hljs-attr">:span</span>=<span class="hljs-string">&quot;24&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;gutter-box&quot;</span>&gt;</span>col-24<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a-col</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">a-row</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">a-row</span> <span class="hljs-attr">justify</span>=<span class="hljs-string">&quot;center&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;margin-top: 15px&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span>&gt;</span>查询<span class="hljs-tag">&lt;/<span class="hljs-name">a-button</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a-button</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;margin-left: 15px&quot;</span>&gt;</span>重置<span class="hljs-tag">&lt;/<span class="hljs-name">a-button</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">a-row</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.gutter-box</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">background</span>: <span class="hljs-number">#0092ff</span>;</span><br><span class="language-css">  <span class="hljs-attribute">padding</span>: <span class="hljs-number">8px</span> <span class="hljs-number">0</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/../../img/frontendGuide/actualCombat/project/x-0020.png" alt="概念布局"></p><h4 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h4><p>主要的表单内容部分使用 <a href="https://antdv.com/components/form-cn">Form组件</a>实现，各个表单项使用嵌套子组件 <code>FormItem</code> 实现。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  ...<br>  <span class="hljs-tag">&lt;<span class="hljs-name">a-form</span></span><br><span class="hljs-tag">        <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;formRef&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">:model</span>=<span class="hljs-string">&quot;formData&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a-row</span></span><br><span class="hljs-tag">          <span class="hljs-attr">:gutter</span>=<span class="hljs-string">&quot;[50, 20]&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">a-col</span> <span class="hljs-attr">:span</span>=<span class="hljs-string">&quot;8&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a-form-item</span></span><br><span class="hljs-tag">              <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;合同场景&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;contractScene&quot;</span>&gt;</span><br>              合同场景占位<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">a-form-item</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">a-col</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">a-col</span> <span class="hljs-attr">:span</span>=<span class="hljs-string">&quot;8&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a-form-item</span></span><br><span class="hljs-tag">              <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;合同编号&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;contractNo&quot;</span>&gt;</span><br>              合同编号占位<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">a-form-item</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">a-col</span>&gt;</span><br>          ...<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">a-row</span>&gt;</span><br>        ...<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">a-form</span>&gt;</span>  <br>  ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript">  <span class="hljs-keyword">import</span>&#123; <span class="hljs-title class_">Form</span> &#125;<span class="hljs-keyword">from</span> <span class="hljs-string">&quot;ant-design-vue&quot;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">  ...</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">// 表单数据类型定义</span></span><br><span class="language-javascript">  interface <span class="hljs-title class_">FormData</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">contractScene</span>: number | <span class="hljs-literal">null</span></span><br><span class="language-javascript">    <span class="hljs-attr">auditStatus</span>: string[]</span><br><span class="language-javascript">    <span class="hljs-attr">contractNo</span>: string</span><br><span class="language-javascript">    <span class="hljs-attr">contractType</span>: string</span><br><span class="language-javascript">    <span class="hljs-attr">trackingPeopleName</span>: string</span><br><span class="language-javascript">    <span class="hljs-attr">ownerName</span>: string</span><br><span class="language-javascript">    <span class="hljs-attr">contractDate</span>: string[]</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">// 表单数据</span></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> formData = ref&lt;<span class="hljs-title class_">FormData</span>&gt;(&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">contractScene</span>: <span class="hljs-literal">null</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">auditStatus</span>: [],</span><br><span class="language-javascript">    <span class="hljs-attr">contractNo</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">contractType</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">trackingPeopleName</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">ownerName</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">contractDate</span>: []</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">// 表单组件实例</span></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> formRef = ref&lt;<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Form</span> | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">  ...</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="表单项-合同场景和跟单人-（select组件）"><a href="#表单项-合同场景和跟单人-（select组件）" class="headerlink" title="表单项 - 合同场景和跟单人 （select组件）"></a>表单项 - 合同场景和跟单人 （select组件）</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  ...<br>  <span class="hljs-tag">&lt;<span class="hljs-name">a-form-item</span></span><br><span class="hljs-tag">    <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;跟单人&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;trackingPeopleName&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">        v-model:value 绑定数据值到formData.trackingPeopleName</span><br><span class="hljs-comment">        options下拉项数据设置为users</span><br><span class="hljs-comment">        field-names设置数据源和选择内容数据key值映射 &#123;label: &#x27;userName&#x27;, value: &#x27;userName&#x27;&#125;</span><br><span class="hljs-comment">        show-search 可搜索</span><br><span class="hljs-comment">        allow-clear 允许展示清空ICON按钮</span><br><span class="hljs-comment">      --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a-select</span></span><br><span class="hljs-tag">      <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;full-width&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">v-model:value</span>=<span class="hljs-string">&quot;formData.trackingPeopleName&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请选择跟单人&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">:options</span>=<span class="hljs-string">&quot;users&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">:field-names</span>=<span class="hljs-string">&quot;&#123;label: &#x27;userName&#x27;, value: &#x27;userName&#x27;&#125;&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">:show-search</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">:allow-clear</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">    &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a-select</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">a-form-item</span>&gt;</span><br>  ...<br>  <span class="hljs-tag">&lt;<span class="hljs-name">a-form-item</span></span><br><span class="hljs-tag">    <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;合同场景&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;contractScene&quot;</span>&gt;</span><br>     <span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">        v-model:value 绑定数据值到formData.contractScene</span><br><span class="hljs-comment">        options下拉项数据设置为contractSceneOptions</span><br><span class="hljs-comment">      --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a-select</span></span><br><span class="hljs-tag">      <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;full-width&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">v-model:value</span>=<span class="hljs-string">&quot;formData.contractScene&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">:options</span>=<span class="hljs-string">&quot;contractSceneOptions&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请选择合同场景&quot;</span></span><br><span class="hljs-tag">    &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a-select</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">a-form-item</span>&gt;</span><br>  ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  ...</span><br><span class="language-javascript">    <span class="hljs-comment">// 合同场景筛选项枚举</span></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> contractSceneOptions = [</span><br><span class="language-javascript">      &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">value</span>: <span class="hljs-literal">null</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;全部&#x27;</span>,</span><br><span class="language-javascript">      &#125;,</span><br><span class="language-javascript">      &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">value</span>: <span class="hljs-number">1</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;线上&#x27;</span>,</span><br><span class="language-javascript">      &#125;,</span><br><span class="language-javascript">      &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;APP&#x27;</span>,</span><br><span class="language-javascript">      &#125;,</span><br><span class="language-javascript">      &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;电签&#x27;</span>,</span><br><span class="language-javascript">      &#125;</span><br><span class="language-javascript">    ]</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> users = [&#123;</span><br><span class="language-javascript">      <span class="hljs-attr">userName</span>: <span class="hljs-string">&#x27;章三&#x27;</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">userId</span>: <span class="hljs-number">10001</span></span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">userName</span>: <span class="hljs-string">&#x27;里斯&#x27;</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">userId</span>: <span class="hljs-number">10002</span></span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">userName</span>: <span class="hljs-string">&#x27;王五&#x27;</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">userId</span>: <span class="hljs-number">10002</span></span><br><span class="language-javascript">    &#125;]</span><br><span class="language-javascript"></span><br><span class="language-javascript">  ...</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;less&quot;</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-comment">/** </span></span><br><span class="hljs-comment"><span class="language-css">    * 用于设置select或者range-picker等组件继承父元素宽度</span></span><br><span class="hljs-comment"><span class="language-css">   */</span></span><br><span class="language-css">  <span class="hljs-selector-class">.full-width</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span> <span class="hljs-meta">!important</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css">  ...</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="表单项-合同编号和业主姓名-（input组件）"><a href="#表单项-合同编号和业主姓名-（input组件）" class="headerlink" title="表单项 - 合同编号和业主姓名 （input组件）"></a>表单项 - 合同编号和业主姓名 （input组件）</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>   ...<br>   <span class="hljs-tag">&lt;<span class="hljs-name">a-form-item</span></span><br><span class="hljs-tag">     <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;合同编号&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;contractNo&quot;</span>&gt;</span><br>     <span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">         v-model:value 绑定数据值到formData.contractNo</span><br><span class="hljs-comment">       --&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">a-input</span></span><br><span class="hljs-tag">       <span class="hljs-attr">v-model:value</span>=<span class="hljs-string">&quot;formData.contractNo&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入合同编号&quot;</span>/&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">a-form-item</span>&gt;</span><br>   ...<br>   <span class="hljs-tag">&lt;<span class="hljs-name">a-form-item</span></span><br><span class="hljs-tag">     <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;业主姓名&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ownerName&quot;</span>&gt;</span><br>     <span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">         v-model:value 绑定数据值到formData.ownerName</span><br><span class="hljs-comment">     --&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">a-input</span></span><br><span class="hljs-tag">       <span class="hljs-attr">v-model:value</span>=<span class="hljs-string">&quot;formData.ownerName&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入业主姓名&quot;</span> /&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">a-form-item</span>&gt;</span><br>   ...<br> <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="表单项-合同录入日期-（range-picker组件）"><a href="#表单项-合同录入日期-（range-picker组件）" class="headerlink" title="表单项 - 合同录入日期 （range-picker组件）"></a>表单项 - 合同录入日期 （range-picker组件）</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>   ...<br>   <span class="hljs-tag">&lt;<span class="hljs-name">a-form-item</span></span><br><span class="hljs-tag">     <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;合同录入日期&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;contractDate&quot;</span>&gt;</span><br>     <span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">         v-model:value 绑定数据值到formData.contractDate</span><br><span class="hljs-comment">         valueFormat 日选择结果格式</span><br><span class="hljs-comment">       --&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">a-range-picker</span></span><br><span class="hljs-tag">       <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;full-width&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">v-model:value</span>=<span class="hljs-string">&quot;formData.contractDate&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">valueFormat</span>=<span class="hljs-string">&quot;YYYY-MM-DD&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">:placeholder</span>=<span class="hljs-string">&quot;[&#x27;开始日期&#x27;, &#x27;结束日期&#x27;]&quot;</span> /&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">a-form-item</span>&gt;</span><br>   ...<br> <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="表单项-合同状态-（checkbox组件）"><a href="#表单项-合同状态-（checkbox组件）" class="headerlink" title="表单项 - 合同状态 （checkbox组件）"></a>表单项 - 合同状态 （checkbox组件）</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>   ...<br>   <span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">       v-model:value 绑定数据值到formData.auditStatus</span><br><span class="hljs-comment">       options 复选框数据设置为auditStatusOptions</span><br><span class="hljs-comment">     --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">a-form-item</span></span><br><span class="hljs-tag">     <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;合同状态&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;auditStatus&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">a-checkbox-group</span></span><br><span class="hljs-tag">       <span class="hljs-attr">v-model:value</span>=<span class="hljs-string">&quot;formData.auditStatus&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;checkboxgroup&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">:options</span>=<span class="hljs-string">&quot;auditStatusOptions&quot;</span> /&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">a-form-item</span>&gt;</span><br>   ...<br> <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">   ...</span><br><span class="language-javascript">   <span class="hljs-keyword">const</span> auditStatusOptions = [</span><br><span class="language-javascript">     &#123;</span><br><span class="language-javascript">       <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;23&#x27;</span>,</span><br><span class="language-javascript">       <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;录入中&#x27;</span>,</span><br><span class="language-javascript">     &#125;,</span><br><span class="language-javascript">     &#123;</span><br><span class="language-javascript">       <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;24&#x27;</span>,</span><br><span class="language-javascript">       <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;已录入&#x27;</span>,</span><br><span class="language-javascript">     &#125;,</span><br><span class="language-javascript">     &#123;</span><br><span class="language-javascript">       <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;22&#x27;</span>,</span><br><span class="language-javascript">       <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;折扣已提交&#x27;</span>,</span><br><span class="language-javascript">     &#125;,</span><br><span class="language-javascript">     &#123;</span><br><span class="language-javascript">       <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;6&#x27;</span>,</span><br><span class="language-javascript">       <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;合同已打印&#x27;</span>,</span><br><span class="language-javascript">     &#125;,</span><br><span class="language-javascript">     &#123;</span><br><span class="language-javascript">       <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;20&#x27;</span>,</span><br><span class="language-javascript">       <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;草签作废&#x27;</span>,</span><br><span class="language-javascript">     &#125;,</span><br><span class="language-javascript">     &#123;</span><br><span class="language-javascript">       <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;96&#x27;</span>,</span><br><span class="language-javascript">       <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;已签字&#x27;</span>,</span><br><span class="language-javascript">     &#125;,</span><br><span class="language-javascript">   ]</span><br><span class="language-javascript">   ...</span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="查询和重置"><a href="#查询和重置" class="headerlink" title="查询和重置"></a>查询和重置</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>   ...<br>   <span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">       v-model:value 绑定数据值到formData.auditStatus</span><br><span class="hljs-comment">       options 复选框数据设置为auditStatusOptions</span><br><span class="hljs-comment">     --&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">a-row</span></span><br><span class="hljs-tag">     <span class="hljs-attr">justify</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">a-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleSerch&quot;</span>&gt;</span>查询<span class="hljs-tag">&lt;/<span class="hljs-name">a-button</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">a-button</span>  <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;margin-left: 10px&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleReset&quot;</span>&gt;</span>重置<span class="hljs-tag">&lt;/<span class="hljs-name">a-button</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">a-row</span>&gt;</span><br>   ...<br> <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">   <span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript">   <span class="hljs-keyword">import</span>&#123; <span class="hljs-title class_">Form</span> &#125;<span class="hljs-keyword">from</span> <span class="hljs-string">&quot;ant-design-vue&quot;</span></span><br><span class="language-javascript">   </span><br><span class="language-javascript">   ...</span><br><span class="language-javascript">   </span><br><span class="language-javascript">   <span class="hljs-comment">// 表单组件实例</span></span><br><span class="language-javascript">   <span class="hljs-keyword">const</span> formRef = ref&lt;<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Form</span> | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">   <span class="hljs-comment">/**</span></span><br><span class="hljs-comment"><span class="language-javascript">    * handleSerch</span></span><br><span class="hljs-comment"><span class="language-javascript">    * <span class="hljs-doctag">@description</span> 查询数据</span></span><br><span class="hljs-comment"><span class="language-javascript">    */</span></span><br><span class="language-javascript">   <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleSerch</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;🚀 ~ handleSerch ~ formData.value:&quot;</span>, formData.<span class="hljs-property">value</span>)</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">   <span class="hljs-comment">/**</span></span><br><span class="hljs-comment"><span class="language-javascript">    * handleReset</span></span><br><span class="hljs-comment"><span class="language-javascript">    * <span class="hljs-doctag">@description</span> 重置查询</span></span><br><span class="hljs-comment"><span class="language-javascript">    */</span></span><br><span class="language-javascript">   <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleReset</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">     <span class="hljs-keyword">if</span> (formRef.<span class="hljs-property">value</span>) &#123;</span><br><span class="language-javascript">       <span class="hljs-comment">// 调用Form组件实例提供的resetFields方法重置表单项到默认值</span></span><br><span class="language-javascript">       formRef.<span class="hljs-property">value</span>.<span class="hljs-title function_">resetFields</span>()</span><br><span class="language-javascript">       <span class="hljs-title function_">handleSerch</span>()</span><br><span class="language-javascript">     &#125;</span><br><span class="language-javascript">   &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">   ...</span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>调试查询和重置功能正常，如下图：</p><p><img src="/../../img/frontendGuide/actualCombat/project/x-0021.png"></p><p>到现在检索表单项功能基本实现完成，完整代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br></pre></td><td class="code"><pre><code class="hljs html">  <span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;search-list&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 折叠标题-包裹检索表单 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a-collapse</span></span><br><span class="hljs-tag">      <span class="hljs-attr">v-model:activeKey</span>=<span class="hljs-string">&quot;activeKey&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">:ghost</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a-collapse-panel</span></span><br><span class="hljs-tag">        <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;1&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">header</span>=<span class="hljs-string">&quot;合同检索列表&quot;</span></span><br><span class="hljs-tag">      &gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">a-form</span></span><br><span class="hljs-tag">        <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;formRef&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">:model</span>=<span class="hljs-string">&quot;formData&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a-row</span></span><br><span class="hljs-tag">          <span class="hljs-attr">:gutter</span>=<span class="hljs-string">&quot;[50, 20]&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">a-col</span> <span class="hljs-attr">:span</span>=<span class="hljs-string">&quot;8&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a-form-item</span></span><br><span class="hljs-tag">              <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;合同场景&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;contractScene&quot;</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">a-select</span></span><br><span class="hljs-tag">                <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;full-width&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">v-model:value</span>=<span class="hljs-string">&quot;formData.contractScene&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">:options</span>=<span class="hljs-string">&quot;contractSceneOptions&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请选择合同场景&quot;</span></span><br><span class="hljs-tag">              &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a-select</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">a-form-item</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">a-col</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">a-col</span> <span class="hljs-attr">:span</span>=<span class="hljs-string">&quot;8&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a-form-item</span></span><br><span class="hljs-tag">              <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;合同编号&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;contractNo&quot;</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">a-input</span></span><br><span class="hljs-tag">                <span class="hljs-attr">v-model:value</span>=<span class="hljs-string">&quot;formData.contractNo&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入合同编号&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">a-form-item</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">a-col</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">a-col</span> <span class="hljs-attr">:span</span>=<span class="hljs-string">&quot;8&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a-form-item</span></span><br><span class="hljs-tag">              <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;合同录入日期&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;contractDate&quot;</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">a-range-picker</span></span><br><span class="hljs-tag">                <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;full-width&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">v-model:value</span>=<span class="hljs-string">&quot;formData.contractDate&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">valueFormat</span>=<span class="hljs-string">&quot;YYYY-MM-DD&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">:placeholder</span>=<span class="hljs-string">&quot;[&#x27;开始日期&#x27;, &#x27;结束日期&#x27;]&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">a-form-item</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">a-col</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">a-col</span> <span class="hljs-attr">:span</span>=<span class="hljs-string">&quot;8&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a-form-item</span></span><br><span class="hljs-tag">              <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;业主姓名&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ownerName&quot;</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">a-input</span></span><br><span class="hljs-tag">                <span class="hljs-attr">v-model:value</span>=<span class="hljs-string">&quot;formData.ownerName&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入业主姓名&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">a-form-item</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">a-col</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">a-col</span> <span class="hljs-attr">:span</span>=<span class="hljs-string">&quot;8&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a-form-item</span></span><br><span class="hljs-tag">              <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;跟单人&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;trackingPeopleName&quot;</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">a-select</span></span><br><span class="hljs-tag">                <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;full-width&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">v-model:value</span>=<span class="hljs-string">&quot;formData.trackingPeopleName&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请选择跟单人&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">:options</span>=<span class="hljs-string">&quot;users&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">:field-names</span>=<span class="hljs-string">&quot;&#123;label: &#x27;userName&#x27;, value: &#x27;userName&#x27;&#125;&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">:show-search</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">:allow-clear</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">              &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a-select</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">a-form-item</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">a-col</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">a-col</span> <span class="hljs-attr">:span</span>=<span class="hljs-string">&quot;24&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a-form-item</span></span><br><span class="hljs-tag">              <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;合同状态&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;auditStatus&quot;</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">a-checkbox-group</span></span><br><span class="hljs-tag">                <span class="hljs-attr">v-model:value</span>=<span class="hljs-string">&quot;formData.auditStatus&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;checkboxgroup&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">:options</span>=<span class="hljs-string">&quot;auditStatusOptions&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">a-form-item</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">a-col</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">a-row</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a-row</span></span><br><span class="hljs-tag">          <span class="hljs-attr">justify</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">a-button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleSerch&quot;</span>&gt;</span>查询<span class="hljs-tag">&lt;/<span class="hljs-name">a-button</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">a-button</span>  <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;margin-left: 10px&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleReset&quot;</span>&gt;</span>重置<span class="hljs-tag">&lt;/<span class="hljs-name">a-button</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">a-row</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">a-form</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a-collapse-panel</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">a-collapse</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">import</span>&#123; <span class="hljs-title class_">Form</span> &#125;<span class="hljs-keyword">from</span> <span class="hljs-string">&quot;ant-design-vue&quot;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">// 设置当前折叠为展开</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> activeKey = <span class="hljs-title function_">ref</span>([<span class="hljs-string">&#x27;1&#x27;</span>])</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> contractSceneOptions = [</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">value</span>: <span class="hljs-literal">null</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;全部&#x27;</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">value</span>: <span class="hljs-number">1</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;线上&#x27;</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;APP&#x27;</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;电签&#x27;</span>,</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">]</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> auditStatusOptions = [</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;23&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;录入中&#x27;</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;24&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;已录入&#x27;</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;22&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;折扣已提交&#x27;</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;6&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;合同已打印&#x27;</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;20&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;草签作废&#x27;</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;96&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;已签字&#x27;</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">]</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> users = [&#123;</span><br><span class="language-javascript">  <span class="hljs-attr">userName</span>: <span class="hljs-string">&#x27;章三&#x27;</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">userId</span>: <span class="hljs-number">10001</span></span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript">&#123;</span><br><span class="language-javascript">  <span class="hljs-attr">userName</span>: <span class="hljs-string">&#x27;里斯&#x27;</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">userId</span>: <span class="hljs-number">10002</span></span><br><span class="language-javascript">&#125;,</span><br><span class="language-javascript">&#123;</span><br><span class="language-javascript">  <span class="hljs-attr">userName</span>: <span class="hljs-string">&#x27;王五&#x27;</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">userId</span>: <span class="hljs-number">10002</span></span><br><span class="language-javascript">&#125;]</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">// 表单数据类型定义</span></span><br><span class="language-javascript">interface <span class="hljs-title class_">FormData</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">contractScene</span>: number | <span class="hljs-literal">null</span></span><br><span class="language-javascript">  <span class="hljs-attr">auditStatus</span>: string[]</span><br><span class="language-javascript">  <span class="hljs-attr">contractNo</span>: string</span><br><span class="language-javascript">  <span class="hljs-attr">contractType</span>: string</span><br><span class="language-javascript">  <span class="hljs-attr">trackingPeopleName</span>: string</span><br><span class="language-javascript">  <span class="hljs-attr">ownerName</span>: string</span><br><span class="language-javascript">  <span class="hljs-attr">contractDate</span>: string[]</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">// 表单数据</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> formData = ref&lt;<span class="hljs-title class_">FormData</span>&gt;(&#123;</span><br><span class="language-javascript">  <span class="hljs-attr">contractScene</span>: <span class="hljs-literal">null</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">auditStatus</span>: [],</span><br><span class="language-javascript">  <span class="hljs-attr">contractNo</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">contractType</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">trackingPeopleName</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">ownerName</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">contractDate</span>: []</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">// 表单组件实例</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> formRef = ref&lt;<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Form</span> | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">/**</span></span><br><span class="hljs-comment"><span class="language-javascript"> * handleSerch</span></span><br><span class="hljs-comment"><span class="language-javascript"> * <span class="hljs-doctag">@description</span> 查询数据</span></span><br><span class="hljs-comment"><span class="language-javascript"> */</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleSerch</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;🚀 ~ handleSerch ~ formData.value:&quot;</span>, formData.<span class="hljs-property">value</span>)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">/**</span></span><br><span class="hljs-comment"><span class="language-javascript"> * handleReset</span></span><br><span class="hljs-comment"><span class="language-javascript"> * <span class="hljs-doctag">@description</span> 重置查询</span></span><br><span class="hljs-comment"><span class="language-javascript"> */</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleReset</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">  <span class="hljs-keyword">if</span> (formRef.<span class="hljs-property">value</span>) &#123;</span><br><span class="language-javascript">    formRef.<span class="hljs-property">value</span>.<span class="hljs-title function_">resetFields</span>()</span><br><span class="language-javascript">    <span class="hljs-title function_">handleSerch</span>()</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">scoped</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;less&quot;</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.full-width</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span> <span class="hljs-meta">!important</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css">  <span class="hljs-comment">/** 定制化重置折叠collapse组件部分样式 </span></span><br><span class="hljs-comment"><span class="language-css">    * :deep用于穿透当前页面样式作用域（scoped），覆盖引用基础组件默认样式</span></span><br><span class="hljs-comment"><span class="language-css">  */</span></span><br><span class="language-css">  :<span class="hljs-built_in">deep</span>(.ant-collapse-item) &#123;</span><br><span class="language-css">    <span class="hljs-selector-class">.ant-collapse-header</span>&#123;</span><br><span class="language-css">      <span class="hljs-attribute">font-weight</span>: bold;</span><br><span class="language-css">      <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;</span><br><span class="language-css">      <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span> <span class="hljs-number">15px</span> <span class="hljs-meta">!important</span>;</span><br><span class="language-css">      <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f2f2f2</span>;</span><br><span class="language-css">      <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">0</span> <span class="hljs-meta">!important</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="结果分页列表编写"><a href="#结果分页列表编写" class="headerlink" title="结果分页列表编写"></a>结果分页列表编写</h3><p>接下来我们继续，开始编写结果分页列表内容, 首先添加基础表格代码：</p><h4 id="基础表格"><a href="#基础表格" class="headerlink" title="基础表格"></a>基础表格</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  ...<br>  <span class="hljs-tag">&lt;<span class="hljs-name">a-table</span></span><br><span class="hljs-tag">    <span class="hljs-attr">:columns</span>=<span class="hljs-string">&quot;columns&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">:data-source</span>=<span class="hljs-string">&quot;listData&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a-table</span>&gt;</span><br>  ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  ...</span><br><span class="language-javascript"><span class="hljs-keyword">import</span> type &#123; <span class="hljs-title class_">TableColumnsType</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;ant-design-vue&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">// 结果列表列配置</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-attr">columns</span>:<span class="hljs-title class_">TableColumnsType</span> = [</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;合同编号&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">dataIndex</span>: <span class="hljs-string">&#x27;contractNo&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">width</span>: <span class="hljs-number">200</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;合同场景&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">dataIndex</span>: <span class="hljs-string">&#x27;isContractBlank&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">width</span>: <span class="hljs-number">150</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;合同录入日期&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">dataIndex</span>: <span class="hljs-string">&#x27;crtDttmFormate&#x27;</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;业主姓名&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">dataIndex</span>: <span class="hljs-string">&#x27;ownerName&#x27;</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;跟单人&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">dataIndex</span>: <span class="hljs-string">&#x27;trackingPeopleName&#x27;</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;合同状态&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">dataIndex</span>: <span class="hljs-string">&#x27;auditStatusName&#x27;</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;操作&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;action&#x27;</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">]</span><br><span class="language-javascript"></span><br><span class="language-javascript">interface <span class="hljs-title class_">ContractData</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">isContractBlank</span>: number | <span class="hljs-literal">null</span></span><br><span class="language-javascript">  <span class="hljs-attr">auditStatus</span>: string</span><br><span class="language-javascript">  <span class="hljs-attr">auditStatusName</span>: string</span><br><span class="language-javascript">  <span class="hljs-attr">conId</span>: number</span><br><span class="language-javascript">  <span class="hljs-attr">contractNo</span>: string</span><br><span class="language-javascript">  <span class="hljs-attr">trackingPeopleName</span>: string</span><br><span class="language-javascript">  <span class="hljs-attr">ownerName</span>: string</span><br><span class="language-javascript">  <span class="hljs-attr">crtDttmFormate</span>: string</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">// 合同MOCK源数据</span></span><br><span class="language-javascript"><span class="hljs-comment">// 合同MOCK源数据</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-attr">contractList</span>: <span class="hljs-title class_">ContractData</span>[] = [</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">auditStatus</span>: <span class="hljs-string">&#x27;24&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">auditStatusName</span>: <span class="hljs-string">&#x27;已录入&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">isContractBlank</span>: <span class="hljs-number">1</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">conId</span>: <span class="hljs-number">501042270</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">contractNo</span>: <span class="hljs-string">&#x27;JZL202407240004WA&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">trackingPeopleName</span>: <span class="hljs-string">&#x27;章三&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">ownerName</span>: <span class="hljs-string">&#x27;的需1&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">crtDttmFormate</span>: <span class="hljs-string">&#x27;2024-07-24 14:26:43&#x27;</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">auditStatus</span>: <span class="hljs-string">&#x27;24&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">auditStatusName</span>: <span class="hljs-string">&#x27;已录入&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">isContractBlank</span>: <span class="hljs-number">3</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">conId</span>: <span class="hljs-number">501042271</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">contractNo</span>: <span class="hljs-string">&#x27;JZL202407240005WA&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">trackingPeopleName</span>: <span class="hljs-string">&#x27;章三&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">ownerName</span>: <span class="hljs-string">&#x27;的需2&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">crtDttmFormate</span>: <span class="hljs-string">&#x27;2024-07-10 10:16:40&#x27;</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">auditStatus</span>: <span class="hljs-string">&#x27;6&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">auditStatusName</span>: <span class="hljs-string">&#x27;合同已打印&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">isContractBlank</span>: <span class="hljs-number">2</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">conId</span>: <span class="hljs-number">501042272</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">contractNo</span>: <span class="hljs-string">&#x27;JZL202407240006WA&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">trackingPeopleName</span>: <span class="hljs-string">&#x27;章三&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">ownerName</span>: <span class="hljs-string">&#x27;的需3&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">crtDttmFormate</span>: <span class="hljs-string">&#x27;2024-07-05 23:22:43&#x27;</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">auditStatus</span>: <span class="hljs-string">&#x27;6&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">auditStatusName</span>: <span class="hljs-string">&#x27;合同已打印&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">isContractBlank</span>: <span class="hljs-number">1</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">conId</span>: <span class="hljs-number">501042273</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">contractNo</span>: <span class="hljs-string">&#x27;JZL20240724007WA&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">trackingPeopleName</span>: <span class="hljs-string">&#x27;里斯&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">ownerName</span>: <span class="hljs-string">&#x27;的需4&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">crtDttmFormate</span>: <span class="hljs-string">&#x27;2024-07-24 18:23:03&#x27;</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">auditStatus</span>: <span class="hljs-string">&#x27;96&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">auditStatusName</span>: <span class="hljs-string">&#x27;已签字&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">isContractBlank</span>: <span class="hljs-number">1</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">conId</span>: <span class="hljs-number">501042274</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">contractNo</span>: <span class="hljs-string">&#x27;JZL202407240008WA&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">trackingPeopleName</span>: <span class="hljs-string">&#x27;王五&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">ownerName</span>: <span class="hljs-string">&#x27;的需&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">crtDttmFormate</span>: <span class="hljs-string">&#x27;2024-07-25 19:26:46&#x27;</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">auditStatus</span>: <span class="hljs-string">&#x27;96&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">auditStatusName</span>: <span class="hljs-string">&#x27;已签字&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">isContractBlank</span>: <span class="hljs-number">1</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">conId</span>: <span class="hljs-number">501042275</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">contractNo</span>: <span class="hljs-string">&#x27;JZL202407240009WA&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">trackingPeopleName</span>: <span class="hljs-string">&#x27;王五&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">ownerName</span>: <span class="hljs-string">&#x27;的需5&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">crtDttmFormate</span>: <span class="hljs-string">&#x27;2024-07-25 04:12:56&#x27;</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">auditStatus</span>: <span class="hljs-string">&#x27;96&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">auditStatusName</span>: <span class="hljs-string">&#x27;已签字&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">isContractBlank</span>: <span class="hljs-number">1</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">conId</span>: <span class="hljs-number">501042276</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">contractNo</span>: <span class="hljs-string">&#x27;JZL202407240010WA&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">trackingPeopleName</span>: <span class="hljs-string">&#x27;里斯&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">ownerName</span>: <span class="hljs-string">&#x27;的需6&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">crtDttmFormate</span>: <span class="hljs-string">&#x27;2024-07-24 20:22:49&#x27;</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">auditStatus</span>: <span class="hljs-string">&#x27;96&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">auditStatusName</span>: <span class="hljs-string">&#x27;已签字&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">isContractBlank</span>: <span class="hljs-number">3</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">conId</span>: <span class="hljs-number">501042275</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">contractNo</span>: <span class="hljs-string">&#x27;JZL202407240009WA&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">trackingPeopleName</span>: <span class="hljs-string">&#x27;王五&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">ownerName</span>: <span class="hljs-string">&#x27;的需7&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">crtDttmFormate</span>: <span class="hljs-string">&#x27;2024-07-24 13:25:22&#x27;</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">auditStatus</span>: <span class="hljs-string">&#x27;20&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">auditStatusName</span>: <span class="hljs-string">&#x27;合同作废&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">isContractBlank</span>: <span class="hljs-number">1</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">conId</span>: <span class="hljs-number">501042276</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">contractNo</span>: <span class="hljs-string">&#x27;JZL202407240011WA&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">trackingPeopleName</span>: <span class="hljs-string">&#x27;里斯&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">ownerName</span>: <span class="hljs-string">&#x27;的需8&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">crtDttmFormate</span>: <span class="hljs-string">&#x27;2024-07-26 12:26:00&#x27;</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">]</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">// 列表数据</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> listData = <span class="hljs-title function_">ref</span>(contractList)</span><br><span class="language-javascript"></span><br><span class="language-javascript">  ...</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/../../img/frontendGuide/actualCombat/project/x-0022.png" alt="基本表格访问效果"></p><h4 id="设置分页"><a href="#设置分页" class="headerlink" title="设置分页"></a>设置分页</h4><p>接下来设置表格的分页器，由于现在使用的是MOCK数据，所以最终实现前端分页功能。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  ...<br>  <span class="hljs-tag">&lt;<span class="hljs-name">a-table</span></span><br><span class="hljs-tag">    <span class="hljs-attr">:columns</span>=<span class="hljs-string">&quot;columns&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">:data-source</span>=<span class="hljs-string">&quot;listData&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">:pagination</span>=<span class="hljs-string">&quot;pagination&quot;</span></span><br><span class="hljs-tag">    @<span class="hljs-attr">change</span>=<span class="hljs-string">&quot;handleTableChange&quot;</span> &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a-table</span>&gt;</span><br>  ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">...</span><br><span class="language-javascript"><span class="hljs-keyword">import</span> type &#123; <span class="hljs-title class_">TableColumnsType</span>, <span class="hljs-title class_">TableProps</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;ant-design-vue&#x27;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref, computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript"></span><br><span class="language-javascript">...</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">// 列表分页默认值</span></span><br><span class="language-javascript">enum <span class="hljs-variable constant_">PAGINATION_DEFAULT</span>  &#123;</span><br><span class="language-javascript">  <span class="hljs-variable constant_">PAGE</span> = <span class="hljs-number">1</span>,</span><br><span class="language-javascript">  <span class="hljs-variable constant_">PAGE_SIZE</span> = <span class="hljs-number">5</span>,</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> current = <span class="hljs-title function_">ref</span>(<span class="hljs-variable constant_">PAGINATION_DEFAULT</span>.<span class="hljs-property">PAGE</span>)</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> pageSize = <span class="hljs-title function_">ref</span>(<span class="hljs-variable constant_">PAGINATION_DEFAULT</span>.<span class="hljs-property">PAGE_SIZE</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">// 列表分页配置</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> pagination = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> (&#123;</span><br><span class="language-javascript">  <span class="hljs-attr">current</span>: current.<span class="hljs-property">value</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">pageSize</span>: pageSize.<span class="hljs-property">value</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">total</span>: listData.<span class="hljs-property">value</span>.<span class="hljs-property">length</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">showQuickJumper</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">showSizeChanger</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">showTitle</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">pageSizeOptions</span>: [<span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">50</span>],</span><br><span class="language-javascript">  <span class="hljs-attr">showTotal</span>: <span class="hljs-function">(<span class="hljs-params">total: number</span>) =&gt;</span> <span class="hljs-string">`共 <span class="hljs-subst">$&#123;total&#125;</span> 条`</span>,</span><br><span class="language-javascript">&#125;))</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">/**</span></span><br><span class="hljs-comment"><span class="language-javascript"> * handleTableChange</span></span><br><span class="hljs-comment"><span class="language-javascript"> * <span class="hljs-doctag">@description</span> 表格变动回调函数</span></span><br><span class="hljs-comment"><span class="language-javascript"> * <span class="hljs-doctag">@param</span> &#123;<span class="hljs-type"></span>&#125; pag 分页数据</span></span><br><span class="hljs-comment"><span class="language-javascript"> */</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-attr">handleTableChange</span>:<span class="hljs-title class_">TableProps</span>[<span class="hljs-string">&#x27;onChange&#x27;</span>] = <span class="hljs-function">(<span class="hljs-params">pag</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">  current.<span class="hljs-property">value</span> = pag.<span class="hljs-property">current</span> || <span class="hljs-variable constant_">PAGINATION_DEFAULT</span>.<span class="hljs-property">PAGE</span></span><br><span class="language-javascript">  pageSize.<span class="hljs-property">value</span> = pag.<span class="hljs-property">pageSize</span> || <span class="hljs-variable constant_">PAGINATION_DEFAULT</span>.<span class="hljs-property">PAGE_SIZE</span></span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">...</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/../../img/frontendGuide/actualCombat/project/x-0023.png" alt="分页器访问效果"></p><h4 id="增加表格列自定义渲染"><a href="#增加表格列自定义渲染" class="headerlink" title="增加表格列自定义渲染"></a>增加表格列自定义渲染</h4><p>我们主要进行了以下改进：</p><ul><li>合同编号列：渲染为超链接样式并支持跳转功能。</li><li>合同场景列：将枚举值转换为名称展示。</li><li>操作列：实现了详情按钮和删除按钮的功能。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs html">  <span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  ...<br>  <span class="hljs-tag">&lt;<span class="hljs-name">a-table</span></span><br><span class="hljs-tag">    <span class="hljs-attr">:columns</span>=<span class="hljs-string">&quot;columns&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">:data-source</span>=<span class="hljs-string">&quot;listData&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">:pagination</span>=<span class="hljs-string">&quot;pagination&quot;</span></span><br><span class="hljs-tag">    @<span class="hljs-attr">change</span>=<span class="hljs-string">&quot;handleTableChange&quot;</span> &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">bodyCell</span>=<span class="hljs-string">&quot;&#123; column, record, text, index &#125;&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;column.dataIndex === &#x27;contractNo&#x27;&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleJumpDetail(record)&quot;</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;column.dataIndex === &#x27;isContractBlank&#x27;&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123; convertSceneName(text) &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;column.key === &#x27;action&#x27;&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a-space</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">a-button</span></span><br><span class="hljs-tag">            <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;small&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">ghost</span></span><br><span class="hljs-tag">            @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleJumpDetail(record)&quot;</span>&gt;</span>详情<span class="hljs-tag">&lt;/<span class="hljs-name">a-button</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">a-button</span></span><br><span class="hljs-tag">            <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;small&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">danger</span></span><br><span class="hljs-tag">            <span class="hljs-attr">ghost</span></span><br><span class="hljs-tag">            @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleDelete(index)&quot;</span>&gt;</span>删除<span class="hljs-tag">&lt;/<span class="hljs-name">a-button</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">a-space</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">a-table</span>&gt;</span><br>  ...<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">import</span> &#123; ref, computed &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript">    <span class="hljs-keyword">import</span> type &#123; <span class="hljs-title class_">TableColumnsType</span>, <span class="hljs-title class_">TableProps</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;ant-design-vue&#x27;</span>;</span><br><span class="language-javascript">    <span class="hljs-keyword">import</span>&#123; <span class="hljs-title class_">Form</span>, message, <span class="hljs-title class_">Modal</span> &#125;<span class="hljs-keyword">from</span> <span class="hljs-string">&quot;ant-design-vue&quot;</span></span><br><span class="language-javascript">    ...</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">/**</span></span><br><span class="hljs-comment"><span class="language-javascript">     * convertSceneName</span></span><br><span class="hljs-comment"><span class="language-javascript">     * <span class="hljs-doctag">@description</span> 合同场景名称转换</span></span><br><span class="hljs-comment"><span class="language-javascript">     * <span class="hljs-doctag">@param</span> code 合同场景编码</span></span><br><span class="hljs-comment"><span class="language-javascript">     */</span></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> <span class="hljs-title function_">convertSceneName</span> = (<span class="hljs-params">code: number</span>) =&gt; &#123;</span><br><span class="language-javascript">      <span class="hljs-keyword">return</span> contractSceneOptions.<span class="hljs-title function_">find</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.<span class="hljs-property">value</span> === code)?.<span class="hljs-property">label</span> || <span class="hljs-string">&#x27;&#x27;</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">/**</span></span><br><span class="hljs-comment"><span class="language-javascript">     * handleJumpDetail</span></span><br><span class="hljs-comment"><span class="language-javascript">     * <span class="hljs-doctag">@description</span> 跳转详情页</span></span><br><span class="hljs-comment"><span class="language-javascript">     * <span class="hljs-doctag">@param</span> record 当前行数据</span></span><br><span class="hljs-comment"><span class="language-javascript">     */</span></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleJumpDetail</span> = (<span class="hljs-params">record: ContractData</span>) =&gt; &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">open</span>(<span class="hljs-string">`https://uat-beijing.cbs.bacic5i5j.com/sign/sign-new/lease-sign-detail.htm?conid=<span class="hljs-subst">$&#123;record.conId&#125;</span>`</span>)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">/**</span></span><br><span class="hljs-comment"><span class="language-javascript">     * handleDelete</span></span><br><span class="hljs-comment"><span class="language-javascript">     * <span class="hljs-doctag">@description</span> 删除当前行</span></span><br><span class="hljs-comment"><span class="language-javascript">     * <span class="hljs-doctag">@param</span> index 当前行当前分页索引</span></span><br><span class="hljs-comment"><span class="language-javascript">     */</span></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleDelete</span> = (<span class="hljs-params">index: number</span>) =&gt; &#123;</span><br><span class="language-javascript">      <span class="hljs-title class_">Modal</span>.<span class="hljs-title function_">confirm</span>(&#123;</span><br><span class="language-javascript">        <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;提示&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">content</span>: <span class="hljs-string">&#x27;确认删除当前行数据吗？&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">okText</span>: <span class="hljs-string">&#x27;确认&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">cancelText</span>: <span class="hljs-string">&#x27;取消&#x27;</span>,</span><br><span class="language-javascript">        <span class="hljs-attr">centered</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">        <span class="hljs-title function_">onOk</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">          listData.<span class="hljs-property">value</span>.<span class="hljs-title function_">splice</span>(index + (current.<span class="hljs-property">value</span> - <span class="hljs-number">1</span>) * pageSize.<span class="hljs-property">value</span>, <span class="hljs-number">1</span>)</span><br><span class="language-javascript">          message.<span class="hljs-title function_">success</span>(<span class="hljs-string">&#x27;删除成功！&#x27;</span>)</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">      &#125;)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>...<br></code></pre></td></tr></table></figure><p><img src="/../../img/frontendGuide/actualCombat/project/x-0024.png" alt="自定义渲染列访问效果"></p><h4 id="实现与检索表单联动的查询功能（纯前端模拟实现）"><a href="#实现与检索表单联动的查询功能（纯前端模拟实现）" class="headerlink" title="实现与检索表单联动的查询功能（纯前端模拟实现）"></a>实现与检索表单联动的查询功能（纯前端模拟实现）</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  ...</span><br><span class="language-javascript">  <span class="hljs-comment">/**</span></span><br><span class="hljs-comment"><span class="language-javascript">   * handleSerch</span></span><br><span class="hljs-comment"><span class="language-javascript">   * <span class="hljs-doctag">@description</span> 查询数据</span></span><br><span class="hljs-comment"><span class="language-javascript">   */</span></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleSerch</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> &#123; contractNo, contractScene, <span class="hljs-attr">contractDate</span>: [startDate=<span class="hljs-string">&#x27;&#x27;</span>, endDate=<span class="hljs-string">&#x27;&#x27;</span>], ownerName, trackingPeopleName, auditStatus &#125; = formData.<span class="hljs-property">value</span> </span><br><span class="language-javascript"></span><br><span class="language-javascript">    listData.<span class="hljs-property">value</span> = contractList.<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> </span><br><span class="language-javascript">      item.<span class="hljs-property">contractNo</span>.<span class="hljs-title function_">includes</span>(contractNo) </span><br><span class="language-javascript">      &amp;&amp; (contractScene === <span class="hljs-literal">null</span> || item.<span class="hljs-property">isContractBlank</span> === contractScene)</span><br><span class="language-javascript">      &amp;&amp; ((startDate === <span class="hljs-string">&#x27;&#x27;</span> || <span class="hljs-title function_">dayjs</span>(startDate).<span class="hljs-title function_">startOf</span>(<span class="hljs-string">&#x27;date&#x27;</span>).<span class="hljs-title function_">valueOf</span>() &lt;= <span class="hljs-title function_">dayjs</span>(item.<span class="hljs-property">crtDttmFormate</span>).<span class="hljs-title function_">valueOf</span>()) &amp;&amp; (endDate === <span class="hljs-string">&#x27;&#x27;</span> || <span class="hljs-title function_">dayjs</span>(endDate).<span class="hljs-title function_">endOf</span>(<span class="hljs-string">&#x27;date&#x27;</span>).<span class="hljs-title function_">valueOf</span>() &gt;= <span class="hljs-title function_">dayjs</span>(item.<span class="hljs-property">crtDttmFormate</span>).<span class="hljs-title function_">valueOf</span>()))</span><br><span class="language-javascript">      &amp;&amp; item.<span class="hljs-property">ownerName</span>.<span class="hljs-title function_">includes</span>(ownerName)</span><br><span class="language-javascript">      &amp;&amp; (trackingPeopleName === <span class="hljs-string">&#x27;&#x27;</span> || item.<span class="hljs-property">trackingPeopleName</span> === trackingPeopleName)</span><br><span class="language-javascript">      &amp;&amp; (!auditStatus.<span class="hljs-property">length</span> || auditStatus.<span class="hljs-title function_">includes</span>(item.<span class="hljs-property">auditStatus</span>))</span><br><span class="language-javascript">      )</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-comment">/**</span></span><br><span class="hljs-comment"><span class="language-javascript">   * handleReset</span></span><br><span class="hljs-comment"><span class="language-javascript">   * <span class="hljs-doctag">@description</span> 重置查询</span></span><br><span class="hljs-comment"><span class="language-javascript">   */</span></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleReset</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">if</span> (formRef.<span class="hljs-property">value</span>) &#123;</span><br><span class="language-javascript">      formRef.<span class="hljs-property">value</span>.<span class="hljs-title function_">resetFields</span>()</span><br><span class="language-javascript">      <span class="hljs-title function_">handleSerch</span>()</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本节我们主要学习了如何使用 <code>Vue</code> 创建页面、配置路由，以及使用 <code>Ant Design Vue</code> 组件库。通过这些知识，我们完成了一个纯前端实现的检索列表页面。在日常开发中，前端页面与后端的交互是数据展示和数据流转的关键环节。下一节我们将深入探讨如何调用接口，实现前后端的完整联通，从而使我们在本节完成的页面功能更加完善。本节完整源码可在 <a href="http://gitlab.it.5i5j.com/fex/my-vue-app/tree/leason-02">gitlab</a> 查看。</p>]]></content>
    
    
    <categories>
      
      <category>前端开发手册</category>
      
      <category>从零开始：手把手教你打造炫酷新页面</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发手册</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第三节：接口调用</title>
    <link href="/2024/06/06/frontendGuide/actualCombat/project/leason-03/"/>
    <url>/2024/06/06/frontendGuide/actualCombat/project/leason-03/</url>
    
    <content type="html"><![CDATA[<h1 id="第三节：接口调用"><a href="#第三节：接口调用" class="headerlink" title="第三节：接口调用"></a>第三节：接口调用</h1><p>欢迎回来！在上一节课中，我们基本完成了检索列表页面的数据检索与展示功能。目前，我们的数据获取和处理都是在前端完成的，这显然无法满足日常业务需求。因此，接下来的任务是将页面的数据与后端接口贯通，实现前后端数据的实时交互。</p><h2 id="Axios-安装与使用"><a href="#Axios-安装与使用" class="headerlink" title="Axios 安装与使用"></a>Axios 安装与使用</h2><p>首先，我们在<code>vue</code>项目调用接口一般用 <code>Axios</code> 库实现，详细API可在<a href="https://www.axios-http.cn/docs/intro">官网</a>查看。</p><p>Axios 是一个基于 Promise 的 HTTP 客户端，用于浏览器和 Node.js，在浏览端中使用 XMLHttpRequests实现。它支持多种请求方式，如 GET、POST、PUT、DELETE 等，并且可以处理各种类型的请求和响应数据。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>在项目中安装 Axios：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm install axios<br></code></pre></td></tr></table></figure><p><img src="/../../img/frontendGuide/actualCombat/project/x-0025.png"></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>在 Vue 组件中使用时，如下方式引入 Axios 即可：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br></code></pre></td></tr></table></figure><p>然后在<code>src/pages/list.vue</code>文件内增加如下代码，发送一个 <code>GET</code> 请求测试：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&#x27;ts&#x27;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;https://jsonplaceholder.typicode.com/todos/1&#x27;</span>)</span><br><span class="language-javascript">  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;🚀 ~ response:&quot;</span>, response)</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript">  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;🚀 ~ error:&quot;</span>, error)</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>然后浏览器访问项目，看到一条GET请求发送并返回了数据， 我们的<code>axios</code>可以正常使用了</p><p><img src="/../../img/frontendGuide/actualCombat/project/x-0026.png" alt="页面请求"></p><p><img src="/../../img/frontendGuide/actualCombat/project/x-0027.png" alt="同时控制台打印数据"></p><h2 id="检索列表的接口改造"><a href="#检索列表的接口改造" class="headerlink" title="检索列表的接口改造"></a>检索列表的接口改造</h2><p>回到主线任务，继续改造检索列表，把之前mock的前端数据和逻辑用axios实现。</p><h3 id="检索项【跟单人】的远程搜索"><a href="#检索项【跟单人】的远程搜索" class="headerlink" title="检索项【跟单人】的远程搜索"></a>检索项【跟单人】的远程搜索</h3><p>上节实现的检索表单里，我们仔细想一下，跟单人这类业务需求中搜索选择经纪人的功能，是不可能前端mock数据的，人员信息千千万想想就可怕。一般当用户输入经纪人名称时，需要根据输入的名称去远程搜索经纪人，然后展示给用户选择。</p><p>跟单人表单项调整代码如下，支持远程接口查询。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    ...<br>    <span class="hljs-tag">&lt;<span class="hljs-name">a-form-item</span></span><br><span class="hljs-tag">        <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;跟单人&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;trackingPeopleName&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a-select</span></span><br><span class="hljs-tag">        <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;full-width&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">v-model:value</span>=<span class="hljs-string">&quot;formData.trackingPeopleName&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">:default-active-first-option</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请选择跟单人&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">:options</span>=<span class="hljs-string">&quot;users&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">:filter-option</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">:not-found-content</span>=<span class="hljs-string">&quot;userFetching ? undefined : null&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">:field-names</span>=<span class="hljs-string">&quot;&#123;label: &#x27;userName&#x27;, value: &#x27;userName&#x27;&#125;&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">show-search</span></span><br><span class="hljs-tag">        <span class="hljs-attr">:allow-clear</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">        @<span class="hljs-attr">search</span>=<span class="hljs-string">&quot;handleUserSearch&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;userFetching&quot;</span> #<span class="hljs-attr">notFoundContent</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a-spin</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;small&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">a-select</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a-form-item</span>&gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lange</span>=<span class="hljs-string">&#x27;ts&#x27;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    ...</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> users = <span class="hljs-title function_">ref</span>([])</span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> userFetching = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">/**</span></span><br><span class="hljs-comment"><span class="language-javascript">     * handleUserSearch</span></span><br><span class="hljs-comment"><span class="language-javascript">     * <span class="hljs-doctag">@description</span> 检索人员</span></span><br><span class="hljs-comment"><span class="language-javascript">     * <span class="hljs-doctag">@param</span> queryName 查询名字</span></span><br><span class="hljs-comment"><span class="language-javascript">     */</span></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleUserSearch</span> = (<span class="hljs-params">queryName: string</span>) =&gt; &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">if</span> (!queryName) &#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">return</span></span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        users.<span class="hljs-property">value</span> = []</span><br><span class="language-javascript">        userFetching.<span class="hljs-property">value</span> = <span class="hljs-literal">true</span></span><br><span class="language-javascript">        axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;https://sign2mock.usemock.com/users&#x27;</span>, &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">params</span>: &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">userName</span>: queryName</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;</span><br><span class="language-javascript">            userFetching.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span></span><br><span class="language-javascript">            <span class="hljs-keyword">if</span> (res?.<span class="hljs-property">data</span>.<span class="hljs-property">code</span> === <span class="hljs-number">0</span>) &#123;</span><br><span class="language-javascript">            users.<span class="hljs-property">value</span> = res?.<span class="hljs-property">data</span>.<span class="hljs-property">data</span> || []</span><br><span class="language-javascript">            &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="language-javascript">            message.<span class="hljs-title function_">error</span>(res?.<span class="hljs-property">data</span>.<span class="hljs-property">msg</span> || <span class="hljs-string">&#x27;请求失败&#x27;</span>)</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">            </span><br><span class="language-javascript">        &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">            userFetching.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span></span><br><span class="language-javascript">        &#125;)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    ...</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>现在人员可以正常远程检索了，但是发现有一个问题就是输入键入一个值就会立即调用一次，太频繁了。我们希望尽量在用户连续输入完成后才去调用查询接口，减少非必要的请求开销。<br>这里我们使用 <a href="https://www.lodashjs.com/">lodash</a> 函数库的 <code>debounce</code> 防抖函数处理一下。</p><h4 id="更进一步-防抖"><a href="#更进一步-防抖" class="headerlink" title="更进一步-防抖"></a>更进一步-防抖</h4><p>安装lodash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm install lodash-es<br></code></pre></td></tr></table></figure><p>安装类型定义</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm install -D  @types/lodash-es<br></code></pre></td></tr></table></figure><h4 id="修改代码"><a href="#修改代码" class="headerlink" title="修改代码"></a>修改代码</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lange</span>=<span class="hljs-string">&#x27;ts&#x27;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">...</span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; debounce &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;lodash-es&quot;</span></span><br><span class="language-javascript">...</span><br><span class="language-javascript"><span class="hljs-comment">/**</span></span><br><span class="hljs-comment"><span class="language-javascript"> * handleUserSearch</span></span><br><span class="hljs-comment"><span class="language-javascript"> * <span class="hljs-doctag">@description</span> 检索人员</span></span><br><span class="hljs-comment"><span class="language-javascript"> * <span class="hljs-doctag">@param</span> queryName 查询名字</span></span><br><span class="hljs-comment"><span class="language-javascript"> */</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> handleUserSearch = <span class="hljs-title function_">debounce</span>(<span class="hljs-function">(<span class="hljs-params">queryName: string</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-keyword">if</span> (!queryName) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span></span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">  users.<span class="hljs-property">value</span> = []</span><br><span class="language-javascript">  userFetching.<span class="hljs-property">value</span> = <span class="hljs-literal">true</span></span><br><span class="language-javascript">  axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;https://sign2mock.usemock.com/users&#x27;</span>, &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">params</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">userName</span>: queryName</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;</span><br><span class="language-javascript">    userFetching.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span></span><br><span class="language-javascript">    <span class="hljs-keyword">if</span> (res?.<span class="hljs-property">data</span>.<span class="hljs-property">code</span> === <span class="hljs-number">0</span>) &#123;</span><br><span class="language-javascript">      users.<span class="hljs-property">value</span> = res?.<span class="hljs-property">data</span>.<span class="hljs-property">data</span> || []</span><br><span class="language-javascript">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="language-javascript">      message.<span class="hljs-title function_">error</span>(res?.<span class="hljs-property">data</span>.<span class="hljs-property">msg</span> || <span class="hljs-string">&#x27;请求失败&#x27;</span>)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">    </span><br><span class="language-javascript">  &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">    userFetching.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span></span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript">&#125;, <span class="hljs-number">300</span>)</span><br><span class="language-javascript">...</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/../../img/frontendGuide/actualCombat/project/x-0028.png" alt="连续输入123456请求一次"></p><h3 id="改造列表查询"><a href="#改造列表查询" class="headerlink" title="改造列表查询"></a>改造列表查询</h3><p>此后使用基于Node服务的一套列表相关接口进行演示，为解决本地开发跨域问题，设置vite开发服务器代理配置。</p><h4 id="vite代理配置"><a href="#vite代理配置" class="headerlink" title="vite代理配置"></a>vite代理配置</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// vite.config.ts</span><br><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span><br><span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@vitejs/plugin-vue&#x27;</span><br><br><span class="hljs-comment">// https://vitejs.dev/config/</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">vue</span>()],<br>  <span class="hljs-attr">server</span>: &#123;<br>    <span class="hljs-attr">port</span>: <span class="hljs-number">3000</span>, <span class="hljs-comment">// vue3 本地项目启动端口号设置</span><br>    <span class="hljs-attr">proxy</span>: &#123;<br>      <span class="hljs-string">&quot;/api&quot;</span>: &#123;<br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&quot;http://122.51.19.40:8080&quot;</span>,<br>        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">rewrite</span>: <span class="hljs-function">(<span class="hljs-params">path</span>) =&gt;</span> path.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^\/api/</span>, <span class="hljs-string">&quot;/api&quot;</span>),<br>      &#125;,<br>    &#125;,<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="修改代码-1"><a href="#修改代码-1" class="headerlink" title="修改代码"></a>修改代码</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lange</span>=<span class="hljs-string">&#x27;ts&#x27;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">...</span><br><span class="language-javascript"><span class="hljs-comment">/**</span></span><br><span class="hljs-comment"><span class="language-javascript"> * handleSerch</span></span><br><span class="hljs-comment"><span class="language-javascript"> * <span class="hljs-doctag">@description</span> 查询数据</span></span><br><span class="hljs-comment"><span class="language-javascript"> */</span></span><br><span class="language-javascript"> <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleSerch</span> = (<span class="hljs-params">page?: number</span>) =&gt; &#123;</span><br><span class="language-javascript">  current.<span class="hljs-property">value</span> = page ?? current.<span class="hljs-property">value</span></span><br><span class="language-javascript">  <span class="hljs-keyword">const</span> &#123; contractNo, contractScene, <span class="hljs-attr">contractDate</span>: [startDate=<span class="hljs-string">&#x27;&#x27;</span>, endDate=<span class="hljs-string">&#x27;&#x27;</span>], ownerName, trackingPeopleName, contractStatus &#125; = formData.<span class="hljs-property">value</span> </span><br><span class="language-javascript">  searchLoading.<span class="hljs-property">value</span> = <span class="hljs-literal">true</span></span><br><span class="language-javascript">  axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/api/contracts&#x27;</span>, &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">params</span>: &#123;</span><br><span class="language-javascript">      contractNo,</span><br><span class="language-javascript">      contractScene,</span><br><span class="language-javascript">      startDate,</span><br><span class="language-javascript">      endDate,</span><br><span class="language-javascript">      ownerName,</span><br><span class="language-javascript">      trackingPeopleName,</span><br><span class="language-javascript">      contractStatus,</span><br><span class="language-javascript">      <span class="hljs-attr">limit</span>: pageSize.<span class="hljs-property">value</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">page</span>: current.<span class="hljs-property">value</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;</span><br><span class="language-javascript">    listData.<span class="hljs-property">value</span> = res?.<span class="hljs-property">data</span>?.<span class="hljs-property">contracts</span> || []</span><br><span class="language-javascript">    total.<span class="hljs-property">value</span> = res?.<span class="hljs-property">data</span>?.<span class="hljs-property">totalCount</span></span><br><span class="language-javascript">    searchLoading.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span></span><br><span class="language-javascript">  &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">    message.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;请求失败&#x27;</span>)</span><br><span class="language-javascript">    searchLoading.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span></span><br><span class="language-javascript">  &#125;)  </span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">...</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="实现数据行删除"><a href="#实现数据行删除" class="headerlink" title="实现数据行删除"></a>实现数据行删除</h3><h4 id="修改代码-2"><a href="#修改代码-2" class="headerlink" title="修改代码"></a>修改代码</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lange</span>=<span class="hljs-string">&#x27;ts&#x27;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">...</span><br><span class="language-javascript"><span class="hljs-comment">/**</span></span><br><span class="hljs-comment"><span class="language-javascript"> * handleDelete</span></span><br><span class="hljs-comment"><span class="language-javascript"> * <span class="hljs-doctag">@description</span> 删除当前行</span></span><br><span class="hljs-comment"><span class="language-javascript"> * <span class="hljs-doctag">@param</span> index 当前行当前分页索引</span></span><br><span class="hljs-comment"><span class="language-javascript"> */</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">handleDelete</span> = (<span class="hljs-params">index: number</span>) =&gt; &#123;</span><br><span class="language-javascript">  <span class="hljs-title class_">Modal</span>.<span class="hljs-title function_">confirm</span>(&#123;</span><br><span class="language-javascript">    <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;提示&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">content</span>: <span class="hljs-string">&#x27;确认删除当前行数据吗？&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">okText</span>: <span class="hljs-string">&#x27;确认&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">cancelText</span>: <span class="hljs-string">&#x27;取消&#x27;</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">centered</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">    <span class="hljs-title function_">onOk</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      axios.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/api/contracts/delete&#x27;</span>, &#123;</span><br><span class="language-javascript">       <span class="hljs-attr">id</span>: record.<span class="hljs-property">contractId</span>,</span><br><span class="language-javascript">      &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">        message.<span class="hljs-title function_">success</span>(<span class="hljs-string">&#x27;删除成功！&#x27;</span>)</span><br><span class="language-javascript">        <span class="hljs-title function_">handleSerch</span>()</span><br><span class="language-javascript">      &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">        message.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;请求失败&#x27;</span>)</span><br><span class="language-javascript">      &#125;)  </span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript">...</span><br><span class="language-javascript">&lt;/scrip&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/../../img/frontendGuide/actualCombat/project/x-0029.gif" alt="基本演示"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>在本节中，我们完成了 Axios 的安装与配置，并通过实际操作展示了如何使用 Axios 进行列表数据的查询和删除操作。我们成功地将前端页面的数据与后端接口贯通，实现了基本的数据交互功能。这使得我们的检索列表页面能够实时展示后端的数据，并提供了删除功能，提升了应用的实用性和互动性。</p><p>下一节中，我们将进一步完善我们的项目，在组件封装的基础上实现新增、编辑和详情功能。通过这些操作，用户将能够更全面地管理和操作数据，使我们的应用更加完善和功能丰富。敬请期待！</p>]]></content>
    
    
    <categories>
      
      <category>前端开发手册</category>
      
      <category>从零开始：手把手教你打造炫酷新页面</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发手册</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第四节：组件封装</title>
    <link href="/2024/06/06/frontendGuide/actualCombat/project/leason-04/"/>
    <url>/2024/06/06/frontendGuide/actualCombat/project/leason-04/</url>
    
    <content type="html"><![CDATA[<h1 id="第四节：组件封装"><a href="#第四节：组件封装" class="headerlink" title="第四节：组件封装"></a>第四节：组件封装</h1><p>上一节中，我们使用 Axios 实现了检索列表页面中的查询和删除功能，使得前端页面能够与后端接口进行数据交互。接下来，我们将继续完善项目，增加详情、新增和编辑页面的功能。通过这些功能，用户将能够更全面地管理和操作数据，提升应用的实用性和用户体验。我们最终实现的页面效果如下：</p><p><img src="/../../img/frontendGuide/actualCombat/project/x-0030.png" alt="列表页"><br><img src="/../../img/frontendGuide/actualCombat/project/x-0031.png" alt="新增页"><br><img src="/../../img/frontendGuide/actualCombat/project/x-0032.png" alt="详情页"><br><img src="/../../img/frontendGuide/actualCombat/project/x-0033.png" alt="编辑页"></p><h2 id="添加详情、新增和编辑页面"><a href="#添加详情、新增和编辑页面" class="headerlink" title="添加详情、新增和编辑页面"></a>添加详情、新增和编辑页面</h2><h3 id="新增页面Vue文件"><a href="#新增页面Vue文件" class="headerlink" title="新增页面Vue文件"></a>新增页面<code>Vue</code>文件</h3><p>观察上边我们要实现的这三个页面的效果，我们发现，这三个页面中，新增页面和编辑页面中的表单部分和操作功能（保存、返回）是基本一致的，中间实现只涉及新增与编辑接口地址不一致的区别，所以新增和编辑页面可以共用一个<code>Vue</code>文件，在<code>src/router/index.ts</code>中定义不同的路由地址即可。针对详情页面单独增加一个<code>Vue</code>文件，对应添加详情页的访问路由配置。</p><h4 id="a-新建页面Vue文件"><a href="#a-新建页面Vue文件" class="headerlink" title="a.新建页面Vue文件"></a>a.新建页面<code>Vue</code>文件</h4><p>在<code>src/pages</code>目录下新增<code>detail.vue</code>和<code>edit.vue</code>文件</p><h4 id="b-配置访问路由"><a href="#b-配置访问路由" class="headerlink" title="b.配置访问路由"></a>b.配置访问路由</h4><p>在<code>src/router/index.ts</code>文件内修改代码如下：<br>因为详情页和编辑需要一个合同ID，以供获取详情数据回显，所以在路由上配置命名为<code>id</code>的<code>params</code>参数。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs ts">    <span class="hljs-keyword">import</span> &#123; createWebHistory, createRouter, <span class="hljs-title class_">RouteRecordRaw</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><br>    <span class="hljs-comment">// 定义路由（路由懒加载组件）</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-attr">routes</span>: <span class="hljs-title class_">RouteRecordRaw</span>[] = [<br>        &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Home&#x27;</span>, <span class="hljs-attr">redirect</span>: <span class="hljs-string">&#x27;/list&#x27;</span> &#125;, <span class="hljs-comment">// 根路径重定向到/list页面</span><br>        &#123;<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/list&#x27;</span>,<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;List&#x27;</span>,<br>            <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../pages/list.vue&#x27;</span>),<br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/detail/:id&#x27;</span>,<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Detail&#x27;</span>,<br>            <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../pages/detail.vue&#x27;</span>),<br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/edit/:id&#x27;</span>,<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Edit&#x27;</span>,<br>            <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../pages/edit.vue&#x27;</span>),<br>        &#125;,<br>        &#123;<br>            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/create&#x27;</span>,<br>            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Create&#x27;</span>,<br>            <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../pages/edit.vue&#x27;</span>),<br>        &#125;,<br>    ]<br><br><span class="hljs-comment">// 创建路由的实例对象</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-title function_">createRouter</span>(&#123;<br>  <span class="hljs-attr">history</span>: <span class="hljs-title function_">createWebHistory</span>(),<br>  routes,<br>&#125;)<br><br><span class="hljs-comment">// 向外共享路由的实例对象</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router<br><br></code></pre></td></tr></table></figure><h3 id="抽离合同信息表单组件"><a href="#抽离合同信息表单组件" class="headerlink" title="抽离合同信息表单组件"></a>抽离合同信息表单组件</h3><p>观察上边我们要实现的这三个页面的效果, 发现他们有一个共同的合同信息表单,所以我们可以抽离出来一个合同信息表单组件,在三个页面中引用,这样代码复用性更高,也方便维护。</p><p>在<code>src/components</code>目录下创建一个<code>ContractInfo.vue</code>文件,代码如下:</p><p>组件提供两个可供传入的属性值：</p><ul><li>contractId 合同ID 页面根据是否传入contractId属性值，若有则调用详情接口获取数据回显表单</li><li>readonly 是都只读 页面根据传入readonly值做页面表单不可编辑限制</li></ul><p>组件提供一个可供外侧通过引入组件实例访问的方法：</p><ul><li>getFormData 校验表单结果，当表单数据校验通过后返回当前表单数据供外侧使用。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a-form</span></span><br><span class="hljs-tag">        <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;formRef&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">:label-col</span>=<span class="hljs-string">&quot;&#123; span: 6 &#125;&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">:wrapper-col</span>=<span class="hljs-string">&quot;&#123; span: 18 &#125;&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">:model</span>=<span class="hljs-string">&quot;formData&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a-form-item</span></span><br><span class="hljs-tag">              <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;合同场景&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;contractScene&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">:rules</span>=<span class="hljs-string">&quot;[&#123; required: true, message: &#x27;请选择合同场景!&#x27; &#125;]&quot;</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">a-select</span></span><br><span class="hljs-tag">                <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;full-width&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">v-model:value</span>=<span class="hljs-string">&quot;formData.contractScene&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">:options</span>=<span class="hljs-string">&quot;contractSceneOptions&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请选择合同场景&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">:disabled</span>=<span class="hljs-string">&quot;readonly&quot;</span></span><br><span class="hljs-tag">              &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a-select</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">a-form-item</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a-form-item</span></span><br><span class="hljs-tag">              <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;合同录入日期&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;contractDate&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">:rules</span>=<span class="hljs-string">&quot;[&#123; required: true, message: &#x27;请选择合同录入日期!&#x27; &#125;]&quot;</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">a-date-picker</span></span><br><span class="hljs-tag">                <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;full-width&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">v-model:value</span>=<span class="hljs-string">&quot;formData.contractDate&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">valueFormat</span>=<span class="hljs-string">&quot;YYYY-MM-DD&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请选择合同录入日期&quot;</span> </span><br><span class="hljs-tag">                <span class="hljs-attr">:disabled</span>=<span class="hljs-string">&quot;readonly&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">a-form-item</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a-form-item</span></span><br><span class="hljs-tag">              <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;业主姓名&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;ownerName&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">:rules</span>=<span class="hljs-string">&quot;[&#123; required: true, message: &#x27;请输入业主姓名!&#x27; &#125;]&quot;</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">a-input</span></span><br><span class="hljs-tag">                <span class="hljs-attr">v-model:value</span>=<span class="hljs-string">&quot;formData.ownerName&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入业主姓名&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">:disabled</span>=<span class="hljs-string">&quot;readonly&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">a-form-item</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a-form-item</span></span><br><span class="hljs-tag">              <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;跟单人&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;trackingPeopleName&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">:rules</span>=<span class="hljs-string">&quot;[&#123; required: true, message: &#x27;请选择跟单人!&#x27; &#125;]&quot;</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">a-select</span></span><br><span class="hljs-tag">                <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;full-width&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">v-model:value</span>=<span class="hljs-string">&quot;formData.trackingPeopleName&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">:default-active-first-option</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请选择跟单人&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">:options</span>=<span class="hljs-string">&quot;users&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">:filter-option</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">:not-found-content</span>=<span class="hljs-string">&quot;userFetching ? undefined : null&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">:field-names</span>=<span class="hljs-string">&quot;&#123;label: &#x27;userName&#x27;, value: &#x27;userName&#x27;&#125;&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">show-search</span></span><br><span class="hljs-tag">                <span class="hljs-attr">:allow-clear</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">                @<span class="hljs-attr">search</span>=<span class="hljs-string">&quot;handleUserSearch&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">:disabled</span>=<span class="hljs-string">&quot;readonly&quot;</span>&gt;</span><br>                 <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;userFetching&quot;</span> #<span class="hljs-attr">notFoundContent</span>&gt;</span><br>                  <span class="hljs-tag">&lt;<span class="hljs-name">a-spin</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;small&quot;</span> /&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br>                 <span class="hljs-tag">&lt;/<span class="hljs-name">a-select</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">a-form-item</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a-form-item</span></span><br><span class="hljs-tag">              <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;合同状态&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;contractStatus&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">:rules</span>=<span class="hljs-string">&quot;[&#123; required: true, message: &#x27;请选择合同状态!&#x27; &#125;]&quot;</span>&gt;</span><br>              <span class="hljs-tag">&lt;<span class="hljs-name">a-select</span></span><br><span class="hljs-tag">                <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;full-width&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">v-model:value</span>=<span class="hljs-string">&quot;formData.contractStatus&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">:options</span>=<span class="hljs-string">&quot;contractStatusOptions&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请选择合同状态&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">:disabled</span>=<span class="hljs-string">&quot;readonly&quot;</span></span><br><span class="hljs-tag">              &gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a-select</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">a-form-item</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">a-form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">import</span>&#123; message, <span class="hljs-title class_">Form</span> &#125;<span class="hljs-keyword">from</span> <span class="hljs-string">&quot;ant-design-vue&quot;</span></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123; debounce &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;lodash-es&quot;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">interface <span class="hljs-title class_">Props</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">contractId</span>: string</span><br><span class="language-javascript">  readonly?: boolean</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> props = <span class="hljs-title function_">withDefaults</span>(defineProps&lt;<span class="hljs-title class_">Props</span>&gt;(), &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">readonly</span>: <span class="hljs-literal">false</span></span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> contractSceneOptions = [</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">value</span>: <span class="hljs-number">1</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;线上&#x27;</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;APP&#x27;</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">value</span>: <span class="hljs-number">3</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;电签&#x27;</span>,</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">]</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> contractStatusOptions = [</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">value</span>: <span class="hljs-number">1</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;录入中&#x27;</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;已录入&#x27;</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">value</span>: <span class="hljs-number">3</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;折扣已提交&#x27;</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">value</span>: <span class="hljs-number">4</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;合同已打印&#x27;</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">value</span>: <span class="hljs-number">5</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;草签作废&#x27;</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">value</span>: <span class="hljs-number">6</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">label</span>: <span class="hljs-string">&#x27;已签字&#x27;</span>,</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">]</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">// 表单数据类型定义</span></span><br><span class="language-javascript">interface <span class="hljs-title class_">FormData</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-attr">contractScene</span>: number | string</span><br><span class="language-javascript">  <span class="hljs-attr">contractStatus</span>: number | string</span><br><span class="language-javascript">  <span class="hljs-attr">trackingPeopleName</span>: string</span><br><span class="language-javascript">  <span class="hljs-attr">ownerName</span>: string</span><br><span class="language-javascript">  <span class="hljs-attr">contractDate</span>: string</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">// 表单数据</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> formData = ref&lt;<span class="hljs-title class_">FormData</span>&gt;(&#123;</span><br><span class="language-javascript">  <span class="hljs-attr">contractScene</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">contractStatus</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">trackingPeopleName</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">ownerName</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">contractDate</span>: <span class="hljs-string">&#x27;&#x27;</span></span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">/**</span></span><br><span class="hljs-comment"><span class="language-javascript"> * getContractDetail</span></span><br><span class="hljs-comment"><span class="language-javascript"> * 根据合同id获取合同详情</span></span><br><span class="hljs-comment"><span class="language-javascript"> */</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getContractDetail</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">    axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">`/api/contracts/<span class="hljs-subst">$&#123;props.contractId&#125;</span>`</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;</span><br><span class="language-javascript">      formData.<span class="hljs-property">value</span> = res.<span class="hljs-property">data</span></span><br><span class="language-javascript">    &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">        message.<span class="hljs-title function_">error</span>(<span class="hljs-string">&#x27;请求失败&#x27;</span>)</span><br><span class="language-javascript">    &#125;) </span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">if</span>(props.<span class="hljs-property">contractId</span>) &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">getContractDetail</span>()</span><br><span class="language-javascript">&#125;    </span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> users = <span class="hljs-title function_">ref</span>([])</span><br><span class="language-javascript"><span class="hljs-keyword">const</span> userFetching = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">/**</span></span><br><span class="hljs-comment"><span class="language-javascript"> * handleUserSearch</span></span><br><span class="hljs-comment"><span class="language-javascript"> * <span class="hljs-doctag">@description</span> 检索人员</span></span><br><span class="hljs-comment"><span class="language-javascript"> * <span class="hljs-doctag">@param</span> queryName 查询名字</span></span><br><span class="hljs-comment"><span class="language-javascript"> */</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> handleUserSearch = <span class="hljs-title function_">debounce</span>(<span class="hljs-function">(<span class="hljs-params">queryName: string</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-keyword">if</span> (!queryName) &#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span></span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">  users.<span class="hljs-property">value</span> = []</span><br><span class="language-javascript">  userFetching.<span class="hljs-property">value</span> = <span class="hljs-literal">true</span></span><br><span class="language-javascript">  axios.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;https://sign2mock.usemock.com/users&#x27;</span>, &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">params</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">userName</span>: queryName</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;</span><br><span class="language-javascript">    userFetching.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span></span><br><span class="language-javascript">    <span class="hljs-keyword">if</span> (res?.<span class="hljs-property">data</span>.<span class="hljs-property">code</span> === <span class="hljs-number">0</span>) &#123;</span><br><span class="language-javascript">      users.<span class="hljs-property">value</span> = res?.<span class="hljs-property">data</span>.<span class="hljs-property">data</span> || []</span><br><span class="language-javascript">    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="language-javascript">      message.<span class="hljs-title function_">error</span>(res?.<span class="hljs-property">data</span>.<span class="hljs-property">msg</span> || <span class="hljs-string">&#x27;请求失败&#x27;</span>)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">    userFetching.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span></span><br><span class="language-javascript">  &#125;)</span><br><span class="language-javascript">&#125;, <span class="hljs-number">300</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">// 表单组件实例</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> formRef = ref&lt;<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">Form</span> | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-comment">/**</span></span><br><span class="hljs-comment"><span class="language-javascript"> * getFormData</span></span><br><span class="hljs-comment"><span class="language-javascript"> * <span class="hljs-doctag">@description</span> 获取表单数据</span></span><br><span class="hljs-comment"><span class="language-javascript"> */</span></span><br><span class="language-javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getFormData</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> formRef.<span class="hljs-property">value</span>?.<span class="hljs-title function_">validate</span>()</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-title function_">defineExpose</span>(&#123;</span><br><span class="language-javascript">  getFormData</span><br><span class="language-javascript">&#125;)</span><br><span class="language-javascript"></span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;less&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span><br><span class="language-css"><span class="hljs-selector-class">.full-width</span> &#123;</span><br><span class="language-css">  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span> <span class="hljs-meta">!important</span>;</span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="实现详情页"><a href="#实现详情页" class="headerlink" title="实现详情页"></a>实现详情页</h3><p>修改<code>src/pages/detail.vue</code>文件，引入<code>ContractInfo</code>组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a-row</span></span><br><span class="hljs-tag">     <span class="hljs-attr">justify</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span>合同详情<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a-row</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a-row</span></span><br><span class="hljs-tag">        <span class="hljs-attr">justify</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">contract-info</span></span><br><span class="hljs-tag">                <span class="hljs-attr">readonly</span></span><br><span class="hljs-tag">                <span class="hljs-attr">:contractId</span>=<span class="hljs-string">&quot;contractId&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a-row</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a-row</span></span><br><span class="hljs-tag">        <span class="hljs-attr">justify</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a-space</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a-button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleGoback&quot;</span>&gt;</span>返回列表<span class="hljs-tag">&lt;/<span class="hljs-name">a-button</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">a-space</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a-row</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">import</span> <span class="hljs-title class_">ContractInfo</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/ContractInfo.vue&#x27;</span></span><br><span class="language-javascript">    <span class="hljs-keyword">import</span> &#123; useRoute, useRouter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> route = <span class="hljs-title function_">useRoute</span>()</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> contractId = route.<span class="hljs-property">params</span>.<span class="hljs-property">id</span> <span class="hljs-keyword">as</span> string</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> router = <span class="hljs-title function_">useRouter</span>()</span><br><span class="language-javascript">    <span class="hljs-comment">/**</span></span><br><span class="hljs-comment"><span class="language-javascript">     * handleGoback</span></span><br><span class="hljs-comment"><span class="language-javascript">     * <span class="hljs-doctag">@description</span> 返回列表</span></span><br><span class="hljs-comment"><span class="language-javascript">     */</span></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleGoback</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">        router.<span class="hljs-title function_">push</span>(&#123;</span><br><span class="language-javascript">            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/list&#x27;</span></span><br><span class="language-javascript">        &#125;)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;less&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css">  </span><br><span class="language-css">    <span class="hljs-selector-class">.title</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">font-size</span>: <span class="hljs-number">18px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">line-height</span>: <span class="hljs-number">32px</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.container</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">900px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">20px</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="实现创建和编辑页"><a href="#实现创建和编辑页" class="headerlink" title="实现创建和编辑页"></a>实现创建和编辑页</h3><p>修改<code>src/pages/edit.vue</code>文件，引入<code>ContractInfo</code>组件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a-row</span></span><br><span class="hljs-tag">     <span class="hljs-attr">justify</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a-row</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a-row</span></span><br><span class="hljs-tag">        <span class="hljs-attr">justify</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">contract-info</span></span><br><span class="hljs-tag">                <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;contractInfoRef&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">:contractId</span>=<span class="hljs-string">&quot;contractId&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a-row</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a-row</span></span><br><span class="hljs-tag">        <span class="hljs-attr">justify</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a-space</span> <span class="hljs-attr">align</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a-button</span></span><br><span class="hljs-tag">                <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;primary&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">:loading</span>=<span class="hljs-string">&quot;saveLoading&quot;</span></span><br><span class="hljs-tag">                @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleSave&quot;</span>&gt;</span>保存<span class="hljs-tag">&lt;/<span class="hljs-name">a-button</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">a-button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleGoback&quot;</span>&gt;</span>返回列表<span class="hljs-tag">&lt;/<span class="hljs-name">a-button</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">a-space</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">a-row</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">import</span> &#123; ref &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span><br><span class="language-javascript">    <span class="hljs-keyword">import</span> <span class="hljs-title class_">ContractInfo</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../components/ContractInfo.vue&#x27;</span></span><br><span class="language-javascript">    <span class="hljs-keyword">import</span> &#123; useRoute, useRouter &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span></span><br><span class="language-javascript">    <span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span></span><br><span class="language-javascript">    <span class="hljs-keyword">import</span>&#123; message &#125;<span class="hljs-keyword">from</span> <span class="hljs-string">&quot;ant-design-vue&quot;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> route = <span class="hljs-title function_">useRoute</span>()</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> contractId = route.<span class="hljs-property">params</span>.<span class="hljs-property">id</span> <span class="hljs-keyword">as</span> string || <span class="hljs-string">&#x27;&#x27;</span></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> routName = route.<span class="hljs-property">name</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> isEdit = routName === <span class="hljs-string">&#x27;Edit&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> title = isEdit ? <span class="hljs-string">&#x27;编辑合同&#x27;</span> : <span class="hljs-string">&#x27;新增合同&#x27;</span></span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 合同信息表单组件实例</span></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> contractInfoRef = ref&lt;<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">ContractInfo</span> | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> saveLoading = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>)</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">/**</span></span><br><span class="hljs-comment"><span class="language-javascript">     * handleSave</span></span><br><span class="hljs-comment"><span class="language-javascript">     * <span class="hljs-doctag">@description</span> 保存合同信息</span></span><br><span class="hljs-comment"><span class="language-javascript">     */</span></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleSave</span> = <span class="hljs-keyword">async</span> (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">       <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> contractInfoRef.<span class="hljs-property">value</span>?.<span class="hljs-title function_">getFormData</span>()</span><br><span class="language-javascript">       saveLoading.<span class="hljs-property">value</span> = <span class="hljs-literal">true</span></span><br><span class="language-javascript">       <span class="hljs-keyword">const</span> savePath = isEdit ? <span class="hljs-string">&#x27;/api/contracts/update&#x27;</span> : <span class="hljs-string">&#x27;/api/contracts&#x27;</span></span><br><span class="language-javascript">       axios.<span class="hljs-title function_">post</span>(savePath, &#123; </span><br><span class="language-javascript">            ...data,</span><br><span class="language-javascript">            <span class="hljs-attr">id</span>: contractId ?? <span class="hljs-literal">null</span></span><br><span class="language-javascript">         &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">            saveLoading.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span></span><br><span class="language-javascript">            message.<span class="hljs-title function_">success</span>(<span class="hljs-string">&#x27;保存成功！&#x27;</span>)</span><br><span class="language-javascript">        &#125;).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;</span><br><span class="language-javascript">            saveLoading.<span class="hljs-property">value</span> = <span class="hljs-literal">false</span></span><br><span class="language-javascript">            message.<span class="hljs-title function_">error</span>(error.<span class="hljs-property">response</span>.<span class="hljs-property">data</span>?.<span class="hljs-property">message</span>)</span><br><span class="language-javascript">        &#125;)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> router = <span class="hljs-title function_">useRouter</span>()</span><br><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">/**</span></span><br><span class="hljs-comment"><span class="language-javascript">     * handleGoback</span></span><br><span class="hljs-comment"><span class="language-javascript">     * <span class="hljs-doctag">@description</span> 返回列表</span></span><br><span class="hljs-comment"><span class="language-javascript">     */</span></span><br><span class="language-javascript">    <span class="hljs-keyword">const</span> <span class="hljs-title function_">handleGoback</span> = (<span class="hljs-params"></span>) =&gt; &#123;</span><br><span class="language-javascript">        router.<span class="hljs-title function_">push</span>(&#123;</span><br><span class="language-javascript">            <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/list&#x27;</span></span><br><span class="language-javascript">        &#125;)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;less&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-css"></span><br><span class="language-css">    <span class="hljs-selector-class">.title</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">font-size</span>: <span class="hljs-number">18px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">line-height</span>: <span class="hljs-number">32px</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css">    <span class="hljs-selector-class">.container</span>&#123;</span><br><span class="language-css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">900px</span>;</span><br><span class="language-css">        <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">20px</span>;</span><br><span class="language-css">    &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="/../../img/frontendGuide/actualCombat/project/x-0034.png" alt="结构示意"></p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>本节结束，恭喜已经完整从项目初始化一步一步实现了列表的增删改查页面和功能，其中我们了解了项目配置、路由配置、组件库使用、Vue页面编写、组件抽离和接口调用等方面，希望对你有所帮助。</p>]]></content>
    
    
    <categories>
      
      <category>前端开发手册</category>
      
      <category>从零开始：手把手教你打造炫酷新页面</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发手册</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS：让你的代码不再一团糟的神奇法则！</title>
    <link href="/2024/06/05/frontendGuide/webBase/css/"/>
    <url>/2024/06/05/frontendGuide/webBase/css/</url>
    
    <content type="html"><![CDATA[<h1 id="CSS-开发规范"><a href="#CSS-开发规范" class="headerlink" title="CSS 开发规范"></a>CSS 开发规范</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ol><li><a href="#css">CSS 的基本语法</a></li><li><a href="#css">选择器、属性和值</a><ul><li><a href="#selector">选择器</a></li><li><a href="#value">属性和值</a></li></ul></li><li><a href="#box">盒模型</a></li><li><a href="#layout">布局</a><ul><li><a href="#float">浮动布局</a></li><li><a href="#position">定位布局</a></li><li><a href="#flex">弹性布局</a></li><li><a href="#grid">网格布局</a></li></ul></li><li><a href="#css3">CSS3 新特性</a></li><li><a href="#media">响应式设计和媒体查询</a></li><li><a href="#precss">预处理器</a><ul><li><a href="#sass">sass</a></li><li><a href="#less">less</a></li></ul></li></ol><p><a name="css"></a></p><h2 id="1-css-的基本语法"><a href="#1-css-的基本语法" class="headerlink" title="1.css 的基本语法"></a>1.css 的基本语法</h2><ul><li>CSS 规则由两个主要的部分构成：选择器，以及一条或多条声明；</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">选择器 &#123;<br>  属性: 值;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>选择器</strong>：用于选择 HTML 元素。</li><li><strong>属性</strong>：要设置的样式属性，如颜色、字体大小等。</li><li><strong>值</strong>：属性的具体值。</li></ul><ul><li>在这个例子中，h1 是选择器，color 和 font-size 是属性，red 和 14px 是值。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">h1</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>css 结构拆解图：<br><img src="/../../img/frontendGuide/css-1.png" alt="alt text"></p><p><a name="css"></a></p><h3 id="2-选择器、属性和值"><a href="#2-选择器、属性和值" class="headerlink" title="2. 选择器、属性和值"></a>2. 选择器、属性和值</h3><p><a name="selector"></a></p><h4 id="2-1-选择器"><a href="#2-1-选择器" class="headerlink" title="2.1. 选择器"></a>2.1. 选择器</h4><h4 id="2-1-1-id-选择器"><a href="#2-1-1-id-选择器" class="headerlink" title="2.1.1 id 选择器"></a>2.1.1 id 选择器</h4><ul><li>id 选择器可以为标有特定 id 的 HTML 元素指定特定的样式。</li><li>id 选择器以 “#” 来定义。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#red</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br><span class="hljs-selector-id">#green</span> &#123;<br>  <span class="hljs-attribute">color</span>: green;<br>&#125;<br>** 派生选择器 通过依据元素在其位置的上下文关系来定义样式 * <span class="hljs-selector-id">#sidebar</span> <span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">font-style</span>: italic;<br>  <span class="hljs-attribute">text-align</span>: right;<br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">0.5em</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;red&quot;</span>&gt;</span>这个段落是红色。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-1-2-类-选择器"><a href="#2-1-2-类-选择器" class="headerlink" title="2.1.2 类 选择器"></a>2.1.2 类 选择器</h4><ul><li>class 选择器可以为标有特定 class 的 HTML 元素指定特定的样式。</li><li>class 选择器以 “.” 来定义。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">text-align</span>: center;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>这个标题将居中<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center&quot;</span>&gt;</span>这个段落将居中<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-1-3-元素选择器"><a href="#2-1-3-元素选择器" class="headerlink" title="2.1.3 元素选择器"></a>2.1.3 元素选择器</h4><ul><li>CSS 2 引入了属性选择器。</li><li>属性选择器可以根据元素的属性及属性值来选择元素。</li><li>如果希望选择有某个属性的元素，而不论属性值是什么，可以使用简单属性选择器。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css">// 把包含标题（title）的所有元素变为红色<br>*<span class="hljs-selector-attr">[title]</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br>//对有 href 属性的锚（<span class="hljs-selector-tag">a</span> 元素）应用样式<br><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href]</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-1-4-后代选择器"><a href="#2-1-4-后代选择器" class="headerlink" title="2.1.4 后代选择器"></a>2.1.4 后代选择器</h4><ul><li>后代选择器（descendant selector）又称为包含选择器。</li><li>后代选择器可以选择作为某元素后代的元素。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">// 对 <span class="hljs-selector-tag">h1</span> 元素中的 <span class="hljs-selector-tag">em</span> 元素应用样式<br><span class="hljs-selector-tag">h1</span> <span class="hljs-selector-tag">em</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>这是一个 <span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>重要的<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span> 头部<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一个 <span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>重要的<span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span> 段落.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="2-1-5-子元素选择器"><a href="#2-1-5-子元素选择器" class="headerlink" title="2.1.5 子元素选择器"></a>2.1.5 子元素选择器</h5><ul><li>如果您不希望选择任意的后代元素，而是希望缩小范围，只选择某个元素的子元素，请使用子元素选择器（Child selector）。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">// 作为 <span class="hljs-selector-tag">h1</span> 元素子元素的 <span class="hljs-selector-tag">strong</span> 元素<br><span class="hljs-selector-tag">h1</span> &gt; <span class="hljs-selector-tag">strong</span> &#123;<br>  <span class="hljs-attribute">color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html">// 这个规则会把第一个 h1 下面的两个 strong 元素变为红色，但是第二个 h1 中的<br>strong 不受影响：<br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>This is <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>very<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>very<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span> important.<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><br>  This is <span class="hljs-tag">&lt;<span class="hljs-name">em</span>&gt;</span>really <span class="hljs-tag">&lt;<span class="hljs-name">strong</span>&gt;</span>very<span class="hljs-tag">&lt;/<span class="hljs-name">strong</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">em</span>&gt;</span> important.<br><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="2-1-6-相邻选择器"><a href="#2-1-6-相邻选择器" class="headerlink" title="2.1.6 相邻选择器"></a>2.1.6 相邻选择器</h5><ul><li>相邻兄弟选择器（Adjacent sibling selector）可选择紧接在另一元素后的元素，且二者有相同父元素。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">// 要增加紧接在 <span class="hljs-selector-tag">h1</span> 元素后出现的段落的上边距<br><span class="hljs-selector-tag">h1</span> + <span class="hljs-selector-tag">p</span> &#123;<br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">50px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a name="value"></a></p><h4 id="2-2-属性和值"><a href="#2-2-属性和值" class="headerlink" title="2.2. 属性和值"></a>2.2. 属性和值</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 设置颜色 */</span><br><span class="hljs-attribute">color</span>: red;<br><br><span class="hljs-comment">/* 设置字体大小 */</span><br><span class="hljs-attribute">font-size</span>: <span class="hljs-number">14px</span>;<br><br><span class="hljs-comment">/* 设置边距 */</span><br><span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span>;<br><br><span class="hljs-comment">/* 设置背景颜色 */</span><br><span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f0f0f0</span>;<br><br><span class="hljs-comment">/* 设置宽度 */</span><br><span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br></code></pre></td></tr></table></figure><p><a name="box"></a></p><h2 id="3-盒模型"><a href="#3-盒模型" class="headerlink" title="3. 盒模型"></a>3. 盒模型</h2><p>当对一个文档进行布局（layout）的时候，浏览器的渲染引擎会根据标准之一的 CSS 基础框盒模型（CSS basic box model），将所有元素表示为一个个矩形的盒子（box）<br>一个盒子由四个部分组成：content、padding、border、margin<br><img src="/../../img/frontendGuide/css-2.png" alt="alt text"><br>content，即实际内容，显示文本和图像</p><h2 id="3-盒模型-1"><a href="#3-盒模型-1" class="headerlink" title="3. 盒模型"></a>3. 盒模型</h2><p>padding，即内边距，清除内容周围的区域，内边距是透明的，取值不能为负，受盒子的 background 属性影响</p><p>margin，即外边距，在元素外创建额外的空白，空白通常指不能放其他元素的区域</p><h4 id="下面来段代码："><a href="#下面来段代码：" class="headerlink" title="下面来段代码："></a>下面来段代码：</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"></span><br><span class="language-css">  <span class="hljs-selector-class">.box</span> &#123;</span><br><span class="language-css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="language-css">    <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span>;</span><br><span class="language-css">  &#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span>盒子模型<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当我们在浏览器查看元素时，却发现元素的大小变成了 240px</p><p>这是因为，在 CSS 中，盒子模型可以分成：</p><ul><li>W3C 标准盒子模型</li><li>IE 怪异盒子模型</li><li>默认情况下，盒子模型为 W3C 标准盒子模型</li></ul><h4 id="W3C-标准盒子模型"><a href="#W3C-标准盒子模型" class="headerlink" title="W3C 标准盒子模型"></a>W3C 标准盒子模型</h4><ul><li>元素的 width、height 只包含 content，不包含 padding 和 border 值</li><li>盒子实际大小取决于 width+padding+border</li></ul><h3 id="W3C-标准盒子模型-1"><a href="#W3C-标准盒子模型-1" class="headerlink" title="W3C 标准盒子模型"></a>W3C 标准盒子模型</h3><h4 id="IE-怪异盒子模型"><a href="#IE-怪异盒子模型" class="headerlink" title="IE 怪异盒子模型"></a>IE 怪异盒子模型</h4><ul><li>元素的 width、height 不仅包括 Content，还包括 padding 和 border 值</li><li>盒子实际的大小取决于 width</li></ul><p><img src="/../../img/frontendGuide/css-3.png" alt="alt text"></p><blockquote><p>css3 中引入了 box-sizing 属性，box-sizing:content-box 表示标准盒子模型，box-sizing:border-box 表示 IE 盒子模型<br><a name="layout"></a></p></blockquote><h2 id="4-布局"><a href="#4-布局" class="headerlink" title="4. 布局"></a>4. 布局</h2><p><a name="float"></a></p><h3 id="4-1-浮动布局"><a href="#4-1-浮动布局" class="headerlink" title="4.1 浮动布局"></a>4.1 浮动布局</h3><p>使用 <code>float</code> 属性可以让元素浮动。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.float-container</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">50%</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>浮动元素会脱离文档流，其他内容将环绕浮动元素。</p><h3 id="4-2-定位布局"><a href="#4-2-定位布局" class="headerlink" title="4.2 定位布局"></a>4.2 定位布局</h3><p>使用 <code>position</code> 属性可以对元素进行定位。</p><ul><li><strong>static</strong>：默认值，无定位。</li><li><strong>relative</strong>：相对定位，相对于其正常位置进行定位。</li><li><strong>absolute</strong>：绝对定位，相对于最近的已定位祖先元素进行定位。</li><li><strong>fixed</strong>：固定定位，相对于浏览器窗口进行定位。</li><li><strong>sticky</strong>：粘性定位，在 <code>relative</code> 和 <code>fixed</code> 之间切换。</li></ul><p>示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.relative</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><a name="flex"></a></p><h3 id="4-3-弹性布局（Flexbox）"><a href="#4-3-弹性布局（Flexbox）" class="headerlink" title="4.3 弹性布局（Flexbox）"></a>4.3 弹性布局（Flexbox）</h3><p>Flexbox 是一种用于布局的强大工具。</p><h4 id="4-3-1-Flex-容器属性"><a href="#4-3-1-Flex-容器属性" class="headerlink" title="4.3.1 Flex 容器属性"></a>4.3.1 Flex 容器属性</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.flex-container</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">justify-content</span>: center;<br>  <span class="hljs-attribute">align-items</span>: center;<br>  <span class="hljs-attribute">flex-wrap</span>: wrap;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>display: flex</strong>：定义一个 flex 容器。</li><li><strong>justify-content</strong>：定义主轴（水平轴）上的对齐方式。</li><li><strong>align-items</strong>：定义交叉轴（垂直轴）上的对齐方式。</li><li><strong>flex-wrap</strong>：定义是否换行。</li></ul><h4 id="4-3-2-Flex-项目属性"><a href="#4-3-2-Flex-项目属性" class="headerlink" title="4.3.2 Flex 项目属性"></a>4.3.2 Flex 项目属性</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.flex-item</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">order</span>: <span class="hljs-number">2</span>;<br>  <span class="hljs-attribute">align-self</span>: flex-start;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>flex</strong>：定义项目的伸缩能力。</li><li><strong>order</strong>：定义项目的排列顺序。</li><li><strong>align-self</strong>：覆盖容器的 <code>align-items</code> 属性。</li></ul><h3 id="4-4-网格布局（Grid）"><a href="#4-4-网格布局（Grid）" class="headerlink" title="4.4 网格布局（Grid）"></a>4.4 网格布局（Grid）</h3><p>Grid 提供了二维布局的能力。</p><h4 id="4-4-1-Grid-容器属性"><a href="#4-4-1-Grid-容器属性" class="headerlink" title="4.4.1 Grid 容器属性"></a>4.4.1 Grid 容器属性</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.grid-container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>fr);<br>  <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">100px</span> <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">gap</span>: <span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>display: grid</strong>：定义一个 grid 容器。</li><li><strong>grid-template-columns</strong>：定义列的数量和宽度。</li><li><strong>grid-template-rows</strong>：定义行的数量和高度。</li><li><strong>gap</strong>：定义网格项之间的间距。</li></ul><h4 id="4-4-2-Grid-项目属性"><a href="#4-4-2-Grid-项目属性" class="headerlink" title="4.4.2 Grid 项目属性"></a>4.4.2 Grid 项目属性</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.grid-item</span> &#123;<br>  <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span> / span <span class="hljs-number">2</span>;<br>  <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span> / <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>grid-column</strong>：定义项目在列中的位置。</li><li><strong>grid-row</strong>：定义项目在行中的位置。</li></ul><p><a name="css3"></a></p><h2 id="5-CSS3-新特性"><a href="#5-CSS3-新特性" class="headerlink" title="5. CSS3 新特性"></a>5. CSS3 新特性</h2><p>CSS3 引入了许多新特性，包括：</p><h3 id="5-1-圆角"><a href="#5-1-圆角" class="headerlink" title="5.1 圆角"></a>5.1 圆角</h3><p>使用 <code>border-radius</code> 属性可以创建圆角。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.rounded</span> &#123;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">10px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-阴影"><a href="#5-2-阴影" class="headerlink" title="5.2 阴影"></a>5.2 阴影</h3><p>使用 <code>box-shadow</code> 和 <code>text-shadow</code> 属性可以添加阴影效果。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.shadow</span> &#123;<br>  <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">2px</span> <span class="hljs-number">2px</span> <span class="hljs-number">5px</span> <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.3</span>);<br>  <span class="hljs-attribute">text-shadow</span>: <span class="hljs-number">1px</span> <span class="hljs-number">1px</span> <span class="hljs-number">2px</span> black;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-3-渐变"><a href="#5-3-渐变" class="headerlink" title="5.3 渐变"></a>5.3 渐变</h3><p>使用 <code>linear-gradient</code> 和 <code>radial-gradient</code> 属性可以创建渐变背景。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.gradient</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">linear-gradient</span>(to right, red, yellow);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-4-过渡"><a href="#5-4-过渡" class="headerlink" title="5.4 过渡"></a>5.4 过渡</h3><p>使用 <code>transition</code> 属性可以创建平滑的过渡效果。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.transition</span> &#123;<br>  <span class="hljs-attribute">transition</span>: all <span class="hljs-number">0.3s</span> ease-in-out;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-5-动画"><a href="#5-5-动画" class="headerlink" title="5.5 动画"></a>5.5 动画</h3><p>使用 <code>@keyframes</code> 和 <code>animation</code> 属性可以创建动画。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@keyframes</span> example &#123;<br>  <span class="hljs-selector-tag">from</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: red;<br>  &#125;<br>  <span class="hljs-selector-tag">to</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: yellow;<br>  &#125;<br>&#125;<br><br><span class="hljs-selector-class">.animation</span> &#123;<br>  <span class="hljs-attribute">animation</span>: example <span class="hljs-number">5s</span> infinite;<br>&#125;<br></code></pre></td></tr></table></figure><p><a name="media"></a></p><h2 id="6-响应式设计和媒体查询"><a href="#6-响应式设计和媒体查询" class="headerlink" title="6. 响应式设计和媒体查询"></a>6. 响应式设计和媒体查询</h2><p>响应式设计旨在创建在各种设备上都能良好显示的网页。使用媒体查询可以根据不同的屏幕尺寸应用不同的样式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">600px</span>) &#123;<br>  <span class="hljs-selector-class">.responsive</span> &#123;<br>    <span class="hljs-attribute">background-color</span>: lightblue;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a name="precss"></a></p><h2 id="7-预处理器"><a href="#7-预处理器" class="headerlink" title="7. 预处理器"></a>7. 预处理器</h2><p>预处理器允许使用更复杂的语法，生成标准的 CSS 文件。常见的预处理器包括 Sass 和 Less。</p><p><a name="sass"></a></p><h3 id="7-1-SASS-介绍"><a href="#7-1-SASS-介绍" class="headerlink" title="7.1 SASS 介绍"></a>7.1 SASS 介绍</h3><h4 id="7-1-1-什么是-SASS？"><a href="#7-1-1-什么是-SASS？" class="headerlink" title="7.1.1 什么是 SASS？"></a>7.1.1 什么是 SASS？</h4><p>SASS（Syntactically Awesome Stylesheets）是一种扩展 CSS 的预处理语言，增加了变量、嵌套、混合、继承等功能，帮助开发者更有效地管理和编写样式代码。</p><h4 id="7-1-2-SASS-文件扩展名"><a href="#7-1-2-SASS-文件扩展名" class="headerlink" title="7.1.2 SASS 文件扩展名"></a>7.1.2 SASS 文件扩展名</h4><ul><li><code>.sass</code>：缩进语法（Indented Syntax）</li><li><code>.scss</code>：Sassy CSS 语法（类似于 CSS 的语法）</li></ul><h4 id="7-1-3-SASS-特性"><a href="#7-1-3-SASS-特性" class="headerlink" title="7.1.3 SASS 特性"></a>7.1.3 SASS 特性</h4><h4 id="7-1-4-变量-Variables"><a href="#7-1-4-变量-Variables" class="headerlink" title="7.1.4 变量 (Variables)"></a>7.1.4 变量 (Variables)</h4><p>SASS 允许使用变量存储值，如颜色、字体或任何 CSS 值，这使得样式更加灵活和易于维护。</p><p><code>示例</code>：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 定义变量</span><br><span class="hljs-variable">$primary-color</span>: <span class="hljs-number">#3498db</span>;<br><span class="hljs-variable">$font-stack</span>: Helvetica, sans-serif;<br><br><span class="hljs-comment">// 使用变量</span><br><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-variable">$primary-color</span>;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-variable">$font-stack</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-1-5-嵌套-Nesting"><a href="#7-1-5-嵌套-Nesting" class="headerlink" title="7.1.5 嵌套 (Nesting)"></a>7.1.5 嵌套 (Nesting)</h4><p>SASS 允许将 CSS 选择器嵌套在一起，这样可以更清晰地表示层级结构。</p><p><code>示例</code>：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">nav</span> &#123;<br>  <span class="hljs-selector-tag">ul</span> &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">list-style</span>: none;<br>  &#125;<br><br>  <span class="hljs-selector-tag">li</span> &#123;<br>    <span class="hljs-attribute">display</span>: inline-block;<br>  &#125;<br><br>  <span class="hljs-selector-tag">a</span> &#123;<br>    <span class="hljs-attribute">text-decoration</span>: none;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-variable">$primary-color</span>;<br><br>    &amp;<span class="hljs-selector-pseudo">:hover</span> &#123;<br>      <span class="hljs-attribute">color</span>: <span class="hljs-built_in">darken</span>(<span class="hljs-variable">$primary-color</span>, <span class="hljs-number">10%</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-1-6-混合-Mixins"><a href="#7-1-6-混合-Mixins" class="headerlink" title="7.1.6 混合 (Mixins)"></a>7.1.6 混合 (Mixins)</h4><p>混合是可重用的样式块，可以带参数。它们类似于函数，可以在多个地方调用，减少重复代码。</p><p><code>示例</code>：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 定义混合</span><br><span class="hljs-keyword">@mixin</span> border-radius(<span class="hljs-variable">$radius</span>) &#123;<br>  -webkit-<span class="hljs-attribute">border-radius</span>: <span class="hljs-variable">$radius</span>;<br>  -moz-<span class="hljs-attribute">border-radius</span>: <span class="hljs-variable">$radius</span>;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-variable">$radius</span>;<br>&#125;<br><br><span class="hljs-comment">// 使用混合</span><br><span class="hljs-selector-class">.button</span> &#123;<br>  <span class="hljs-keyword">@include</span> border-radius(<span class="hljs-number">10px</span>);<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-variable">$primary-color</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-1-6-继承-Inheritance"><a href="#7-1-6-继承-Inheritance" class="headerlink" title="7.1.6 继承 (Inheritance)"></a>7.1.6 继承 (Inheritance)</h4><p>SASS 允许一个选择器继承另一个选择器的样式，从而减少重复代码。</p><p><code>示例</code>：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 基础样式</span><br>%<span class="hljs-selector-tag">button</span>-style &#123;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span> <span class="hljs-number">20px</span>;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;<br>  <span class="hljs-attribute">color</span>: white;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-variable">$primary-color</span>;<br>&#125;<br><br><span class="hljs-comment">// 继承样式</span><br><span class="hljs-selector-class">.button</span> &#123;<br>  <span class="hljs-keyword">@extend</span> %button-style;<br>  <span class="hljs-attribute">border</span>: none;<br>  <span class="hljs-attribute">cursor</span>: pointer;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-1-7-部件-Partials-和-导入-Import"><a href="#7-1-7-部件-Partials-和-导入-Import" class="headerlink" title="7.1.7 部件 (Partials) 和 导入 (Import)"></a>7.1.7 部件 (Partials) 和 导入 (Import)</h4><p>SASS 允许将样式分成多个文件，并在主文件中导入，便于管理和维护。</p><p><code>示例</code>：<br>&#x2F;&#x2F; _variables.scss</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-variable">$primary-color</span>: <span class="hljs-number">#3498db</span>;<br><span class="hljs-variable">$font-stack</span>: Helvetica, sans-serif;<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F; _base.scss</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-variable">$font-stack</span>;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-variable">$primary-color</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F; main.scss</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;variables&quot;</span>;<br><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;base&quot;</span>;<br></code></pre></td></tr></table></figure><h4 id="7-1-8-函数-Functions"><a href="#7-1-8-函数-Functions" class="headerlink" title="7.1.8 函数 (Functions)"></a>7.1.8 函数 (Functions)</h4><p>SASS 提供了一些内置函数，并允许开发者定义自己的函数，用于计算和处理值。</p><p><code>示例</code>：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">// 定义函数</span><br><span class="hljs-keyword">@function</span> calculate-rem(<span class="hljs-variable">$size</span>, <span class="hljs-variable">$base</span>: <span class="hljs-number">16px</span>) &#123;<br>  <span class="hljs-keyword">@return</span> <span class="hljs-variable">$size</span> / <span class="hljs-variable">$base</span> * <span class="hljs-number">1rem</span>;<br>&#125;<br><br><span class="hljs-comment">// 使用函数</span><br><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">font-size</span>: <span class="hljs-built_in">calculate-rem</span>(<span class="hljs-number">18px</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-1-9-运算-Operations"><a href="#7-1-9-运算-Operations" class="headerlink" title="7.1.9 运算 (Operations)"></a>7.1.9 运算 (Operations)</h4><p>SASS 支持在样式中进行数学运算，如加减乘除。</p><p><code>示例</code>：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span> - <span class="hljs-number">20px</span>;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span> + <span class="hljs-number">5px</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">20px</span> / <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-2-0-SASS-编译"><a href="#7-2-0-SASS-编译" class="headerlink" title="7.2.0 SASS 编译"></a>7.2.0 SASS 编译</h4><p>SASS 文件需要编译成标准的 CSS 文件才能在网页中使用。可以使用以下工具进行编译：</p><ul><li>命令行工具（sass）</li><li>任务运行器（如 Gulp、Grunt）</li><li>模块打包器（如 Webpack）</li></ul><h4 id="命令行编译示例："><a href="#命令行编译示例：" class="headerlink" title="命令行编译示例："></a>命令行编译示例：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sass input.scss output.css<br></code></pre></td></tr></table></figure><p><a name="less"></a></p><h2 id="7-2-Less-介绍"><a href="#7-2-Less-介绍" class="headerlink" title="7.2 Less 介绍"></a>7.2 Less 介绍</h2><p>Less 也是一种流行的 CSS 预处理器，具有类似于 Sass 的功能。</p><p>LESS（Leaner Style Sheets）是一种动态样式表语言，扩展了 CSS，增加了变量、混合、嵌套规则和函数等功能，使 CSS 更加灵活和易于维护。LESS 由 JavaScript 编写，可以在客户端和服务器端运行。以下是 LESS 的基础教程。</p><h4 id="7-2-1-环境配置"><a href="#7-2-1-环境配置" class="headerlink" title="7.2.1 环境配置"></a>7.2.1 环境配置</h4><h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><ol><li><p>下载并引入 LESS 库：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet/less&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;styles.less&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/less@4.1.1/dist/less.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>使用 <code>.less</code> 文件编写样式，浏览器会自动编译。</p></li></ol><h5 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h5><ol><li><p>安装 LESS 编译器：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">npm install -g less<br></code></pre></td></tr></table></figure></li><li><p>编译 LESS 文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">lessc styles.less styles.css<br></code></pre></td></tr></table></figure></li></ol><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><p>LESS 允许使用变量来存储值，如颜色、字体大小、边距等。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@primary-color:</span> <span class="hljs-number">#4caf50</span>;<br><span class="hljs-variable">@padding:</span> <span class="hljs-number">10px</span>;<br><br><span class="hljs-selector-class">.button</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-variable">@primary-color</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-variable">@padding</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="嵌套规则"><a href="#嵌套规则" class="headerlink" title="嵌套规则"></a>嵌套规则</h5><p>嵌套规则使得层级结构更加清晰。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-class">.navbar</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#333</span>;<br>  <span class="hljs-selector-class">.nav-item</span> &#123;<br>    <span class="hljs-attribute">color</span>: <span class="hljs-number">#fff</span>;<br>    <span class="hljs-selector-tag">&amp;</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>      <span class="hljs-attribute">color</span>: <span class="hljs-variable">@primary-color</span>;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="混合-Mixins"><a href="#混合-Mixins" class="headerlink" title="混合 (Mixins)"></a>混合 (Mixins)</h5><p>混合允许将一组 CSS 声明重用到多个选择器中。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-class">.border-radius</span>(<span class="hljs-variable">@radius</span>) &#123;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-variable">@radius</span>;<br>  -webkit-<span class="hljs-attribute">border-radius</span>: <span class="hljs-variable">@radius</span>;<br>  -moz-<span class="hljs-attribute">border-radius</span>: <span class="hljs-variable">@radius</span>;<br>&#125;<br><br><span class="hljs-selector-class">.button</span> &#123;<br>  <span class="hljs-selector-class">.border-radius</span>(<span class="hljs-number">5px</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="继承-Extend"><a href="#继承-Extend" class="headerlink" title="继承 (Extend)"></a>继承 (Extend)</h5><p>继承允许一个选择器继承另一个选择器的样式。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-class">.message</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-number">#333</span>;<br>&#125;<br><br><span class="hljs-selector-class">.success</span> &#123;<br>  <span class="hljs-selector-tag">&amp;</span>:<span class="hljs-selector-tag">extend</span>(.message);<br>  <span class="hljs-attribute">border-color</span>: green;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h5><p>LESS 支持数学运算和颜色操作。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@width:</span> <span class="hljs-number">100px</span>;<br><span class="hljs-variable">@height:</span> <span class="hljs-variable">@width</span> + <span class="hljs-number">50px</span>;<br><br><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-variable">@width</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-variable">@height</span>;<br>  <span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">lighten</span>(<span class="hljs-variable">@primary-color</span>, <span class="hljs-number">20%</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h5><p>LESS 提供了许多内置函数，如 <code>darken</code>、<code>lighten</code>、<code>fade</code> 等。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@base-color:</span> <span class="hljs-number">#000</span>;<br><br><span class="hljs-selector-class">.header</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-built_in">lighten</span>(<span class="hljs-variable">@base-color</span>, <span class="hljs-number">20%</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h5><p>LESS 允许将一个 LESS 文件导入到另一个文件中。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;variables.less&quot;</span>;<br><span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;mixins.less&quot;</span>;<br><br><span class="hljs-selector-tag">body</span> &#123;<br>  <span class="hljs-attribute">color</span>: <span class="hljs-variable">@text-color</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端开发手册</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS开发规范</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript 探险记：类型安全的奥秘</title>
    <link href="/2024/06/05/frontendGuide/typescript/"/>
    <url>/2024/06/05/frontendGuide/typescript/</url>
    
    <content type="html"><![CDATA[<h4 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h4><p>类型注解的 TypeScript 与 JavaScript 完全一致</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;spencer&#x27;</span>;<br></code></pre></td></tr></table></figure><p>只需要将变量后面添加: 类型注解就可以了，如下代码所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> <span class="hljs-attr">name</span>: string = <span class="hljs-string">&#x27;spencer&#x27;</span>;<br></code></pre></td></tr></table></figure><h4 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h4><p>JavaScript原始类型：string、number、bigint、boolean、undefined 和 symbol  </p><p><strong>注意事项：</strong></p><ul><li>虽然<code>number</code>和<code>bigint</code>都表示数字，但是这两个类型不兼容。</li><li>TypeScript 还包含 Number、String、Boolean、Symbol 等类型（注意区分大小写），不要将它们和小写格式对应的 number、string、boolean、symbol 进行等价</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> <span class="hljs-attr">name</span>: <span class="hljs-title class_">String</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&#x27;spencer&#x27;</span>);<br><span class="hljs-keyword">let</span> <span class="hljs-attr">name2</span>: string = <span class="hljs-string">&#x27;spencer&#x27;</span>; <br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(name === name2); <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><h4 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h4><p>我们可以通过[]的方式定义数组类型，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">//子元素是数字类型的数组</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">arrayAge</span>: number[] = [<span class="hljs-number">28</span>, <span class="hljs-number">29</span>, <span class="hljs-number">30</span>];<br><span class="hljs-comment">//子元素是字符串类型的数组</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">arrayName</span>: string[] = [<span class="hljs-string">&#x27;spencer&#x27;</span>, <span class="hljs-string">&#x27;peter&#x27;</span>, <span class="hljs-string">&#x27;john&#x27;</span>];<br><br></code></pre></td></tr></table></figure><p>也可以通过Array泛型的方式定义数组类型，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-comment">//子元素是数字类型的数组</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">arrayAge</span>: <span class="hljs-title class_">Array</span>&lt;number&gt; = [<span class="hljs-number">28</span>, <span class="hljs-number">29</span>, <span class="hljs-number">30</span>];<br><span class="hljs-comment">//子元素是字符串类型的数组</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">arrayName</span>: <span class="hljs-title class_">Array</span>&lt;string&gt; = [<span class="hljs-string">&#x27;spencer&#x27;</span>, <span class="hljs-string">&#x27;peter&#x27;</span>, <span class="hljs-string">&#x27;john&#x27;</span>];<br><br></code></pre></td></tr></table></figure><p>为了避免与JSX产生语法冲突，推荐使用[]的方式</p><h4 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h4><p><strong>1、any</strong></p><p>any是指一个任意类型，用来选择性绕过静态类型检测。并且any 类型会在对象的调用链中进行传导，即所有 any 类型的任意属性的类型都是 any。</p><p>any是一个坏习惯，除非有充足的理由，否则应该尽量避免使用any</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> <span class="hljs-attr">anything</span>: any = &#123;&#125;;<br>anything.<span class="hljs-title function_">doAnything</span>(); <br>anything = <span class="hljs-number">1</span>; <br>anything = <span class="hljs-string">&#x27;x&#x27;</span>; <br><span class="hljs-keyword">let</span> z = anything.<span class="hljs-property">x</span>.<span class="hljs-property">y</span>.<span class="hljs-property">z</span>; <br><span class="hljs-title function_">z</span>(); <br></code></pre></td></tr></table></figure><p><strong>2、unknown</strong></p><p>unknown 是 TypeScript 3.0 中添加的一个类型，它主要用来描述类型并不确定的变量。与any不同的是，unknown更安全，我们可以将任意类型的值赋值给unknown，但是unknown类型的值只能赋值给unknown或any。</p><p>使用unknown时，TypeScript还是会对它做类型检测的，并且如果在使用过程中不缩小类型的话，在后续的执行过程中也是会出现错误的，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> <span class="hljs-attr">weight</span>: unknown;<br>weight.<span class="hljs-title function_">toFixed</span>(); <span class="hljs-comment">// Object is of type &#x27;unknown&#x27;.(2571)</span><br><br></code></pre></td></tr></table></figure><p>应该进行类型缩小，才会避免报错，如下代码所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">let</span> <span class="hljs-attr">weight</span>: unknown;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> weight === <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>  weight.<span class="hljs-title function_">toFixed</span>(); <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3、void</strong></p><p>对于函数表示没有返回值的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">interface <span class="hljs-title class_">UserInfo</span> = &#123;<br>  <span class="hljs-attr">work</span>: <span class="hljs-function">()=&gt;</span><span class="hljs-keyword">void</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>在严格模式下，对于变量设置void类型则是几乎没有什么用处，因为不能将void类型的变量赋值给除了any和unknown之外的任何类型变量。</p><p><strong>4、undefined</strong></p><p>undefined表示未定义的意思，在接口类型中有一定价值，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">interface <span class="hljs-title class_">UserInfo</span> &#123;<br>  <span class="hljs-attr">name</span>: string;<br>  age?: number;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为age属性被标注为可缺省，就相当于它的类型是<code>number</code>类型与<code>undefined</code>的联合类型，但你不能手动将<code>number | undefined</code> 直接设置为age的类型，两者是不等价的，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">interface <span class="hljs-title class_">UserInfo</span> &#123;<br>  <span class="hljs-attr">name</span>: string;<br>  <span class="hljs-attr">age</span>: number | <span class="hljs-literal">undefined</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面<code>?: </code>意味着可缺省，你可以不为这个属性赋值，但是类型undefined只是表示未定义，不代表该属性可缺省。</p><p><strong>5、null</strong></p><p>null表示值可能为空。它的主要价值在于接口的指定上，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">interface <span class="hljs-title class_">UserInfo</span>: &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-literal">null</span> | string<br>&#125;<br></code></pre></td></tr></table></figure><p>对于undefined和null我们在实际开发中要做好容错处理，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-attr">userInfo</span>: &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-literal">null</span> | string<br>&#125;<br><span class="hljs-keyword">if</span>(userInfo.<span class="hljs-property">name</span> != <span class="hljs-literal">null</span>)&#123;<br>  ...<br>&#125; <br></code></pre></td></tr></table></figure><p><strong>6、never</strong></p><p>never是指永远不会发生值的类型</p><p>例如一个抛错的函数，函数永远不会有返回值，所以返回值类型为never，代码如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">ThrowError</span>(<span class="hljs-params">msg: string</span>): never &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(msg);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>never是所有类型的子类型，可以赋值给所有类型，但是反过来，除了never自身以外，其他类型都不能为never类型赋值。</p><p>在恒为false的条件判断下，变量类型就会被缩小为never类型，因为上面提到了never是所有类型的子类型，所以缩小到never类型，所以这种恒为false情况会提示错误给我们，如下代码所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> <span class="hljs-attr">name</span>: string = <span class="hljs-string">&#x27;spencer&#x27;</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> name === <span class="hljs-string">&#x27;number&#x27;</span>) &#123;<br>  name.<span class="hljs-title function_">toFixed</span>(); <span class="hljs-comment">// Property &#x27;toFixed&#x27; does not exist on type &#x27;never&#x27;.ts(2339)</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="接口类型"><a href="#接口类型" class="headerlink" title="接口类型"></a>接口类型</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">work</span>(<span class="hljs-params">action: &#123; coding: string &#125;</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(action.<span class="hljs-property">coding</span>);<br>&#125;<br><br><span class="hljs-keyword">let</span> myAction = &#123; <span class="hljs-attr">meeting</span>: <span class="hljs-string">&quot;have a meeting&quot;</span>, <span class="hljs-attr">coding</span>: <span class="hljs-string">&quot;TypeScript&quot;</span> &#125;;<br><span class="hljs-title function_">work</span>(myAction);<br></code></pre></td></tr></table></figure><p>换成接口类型写法</p><p>使用interface关键字来抽离可复用的接口类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">interface <span class="hljs-title class_">ActionValue</span> &#123;<br>  <span class="hljs-attr">coding</span>: string;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">work</span>(<span class="hljs-params">action: ActionValue</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(action.<span class="hljs-property">coding</span>);<br>&#125;<br><br><span class="hljs-keyword">let</span> myAction = &#123; <span class="hljs-attr">meeting</span>: <span class="hljs-string">&quot;have a meeting&quot;</span>, <span class="hljs-attr">coding</span>: <span class="hljs-string">&quot;TypeScript&quot;</span> &#125;;<br><span class="hljs-title function_">work</span>(myAction);<br><span class="hljs-keyword">let</span> <span class="hljs-attr">myAction2</span>: <span class="hljs-title class_">ActionValue</span> = &#123; <span class="hljs-attr">meeting</span>: <span class="hljs-string">&quot;have a meeting&quot;</span>, <span class="hljs-attr">coding</span>: <span class="hljs-string">&quot;CSS&quot;</span> &#125;;<br><span class="hljs-title function_">work</span>(myAction2);<span class="hljs-comment">//报错</span><br><br></code></pre></td></tr></table></figure><h4 id="Type类型别名"><a href="#Type类型别名" class="headerlink" title="Type类型别名"></a>Type类型别名</h4><p>通过type 别名名称 &#x3D; 类型定义的形式来定义类型别名，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">type <span class="hljs-title class_">User</span> = &#123;<br>  <span class="hljs-attr">name</span>: string;<br>  <span class="hljs-attr">age</span>: number;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Interface-与-Type-的区别"><a href="#Interface-与-Type-的区别" class="headerlink" title="Interface 与 Type 的区别"></a>Interface 与 Type 的区别</h4><p>大多数情况下都可以互相替代，但是如果遇到重复定义的时候两者会有区别，重复定义接口类型，他的属性会叠加，重复定义类型别名，ts会报错。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs text">&#123;<br>  interface Language &#123;<br>    id: number;<br>  &#125;<br>  <br>  interface Language &#123;<br>    name: string;<br>  &#125;<br>  let lang: Language = &#123;<br>    id: 1, // ok<br>    name: &#x27;name&#x27; // ok<br>  &#125;<br>&#125;<br>&#123;<br>  /** ts(2300) 重复的标志 */<br>  type Language = &#123;<br>    id: number;<br>  &#125;<br>  <br>  /** ts(2300) 重复的标志 */<br>  type Language = &#123;<br>    name: string;<br>  &#125;<br>  let lang: Language = &#123;<br>    id: 1,<br>    name: &#x27;name&#x27;<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h4><h4 id="公共、私有、受保护的修饰符"><a href="#公共、私有、受保护的修饰符" class="headerlink" title="公共、私有、受保护的修饰符"></a>公共、私有、受保护的修饰符</h4><ul><li>public 修饰的是在任何地方可见、公有的属性或方法；</li><li>private 修饰的是仅在同一类中可见、私有的属性或方法；</li><li>protected 修饰的是仅在类自身及子类中可见、受保护的属性或方法。</li></ul><p>在不设置的时候默认都是public</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  public <span class="hljs-attr">firstName</span>: string;<br>  private <span class="hljs-attr">lastName</span>: string = <span class="hljs-string">&#x27;Peter&#x27;</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">firstName: string</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> = firstName;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span>; <span class="hljs-comment">// ok</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;John&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">firstName</span>); <span class="hljs-comment">//  =&gt; &quot;John&quot;</span><br>person.<span class="hljs-property">firstName</span> = <span class="hljs-string">&#x27;Victor&#x27;</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">firstName</span>); <span class="hljs-comment">//  =&gt; &quot;Victor&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">lastName</span>); <span class="hljs-comment">// Property &#x27;lastName&#x27; is private and only accessible within class &#x27;Person&#x27;.(2341)</span><br><br></code></pre></td></tr></table></figure><p>TypeScript 中定义类的私有属性仅仅代表静态类型检测层面的私有。如果我们强制忽略 TypeScript 类型的检查错误，转译且运行 JavaScript 时依旧可以获取到私有属性，因为 JavaScript 并不支持真正意义上的私有属性。</p><p>受保护属性和方法示例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  public <span class="hljs-attr">firstName</span>: string;<br>  protected <span class="hljs-attr">lastName</span>: string = <span class="hljs-string">&#x27;Peter&#x27;</span>;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">firstName: string</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> = firstName;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span>; <span class="hljs-comment">// ok</span><br>  &#125;<br>&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Programmer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">firstName: string</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(firstName);<br>  &#125;<br>​<br>  public <span class="hljs-title function_">getLastName</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">lastName</span>;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> programmer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Programmer</span>(<span class="hljs-string">&#x27;John&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(programmer.<span class="hljs-title function_">getLastName</span>()); <span class="hljs-comment">// =&gt; &quot;Peter&quot;</span><br>programmer.<span class="hljs-property">lastName</span>; <span class="hljs-comment">//Property &#x27;lastName&#x27; is protected and only accessible within class &#x27;Person&#x27; and its subclasses.(2445)</span><br></code></pre></td></tr></table></figure><h4 id="只读修饰符-readonly"><a href="#只读修饰符-readonly" class="headerlink" title="只读修饰符 - readonly"></a>只读修饰符 - <code>readonly</code></h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  public readonly <span class="hljs-attr">firstName</span>: string;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">firstName: string</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">firstName</span> = firstName;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;John&#x27;</span>);<br>person.<span class="hljs-property">firstName</span> = <span class="hljs-string">&#x27;Victor&#x27;</span>; <span class="hljs-comment">// ts(2540) Cannot assign to &#x27;firstName&#x27; because it is a read-only property.</span><br><br></code></pre></td></tr></table></figure><h4 id="静态属性"><a href="#静态属性" class="headerlink" title="静态属性"></a>静态属性</h4><p>静态属性可以直接通过类访问，而不用实例化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-keyword">static</span> name = <span class="hljs-string">&#x27;Spencer&#x27;</span>;<br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">getAge</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">//...</span><br>  &#125;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-property">name</span>); <span class="hljs-comment">// =&gt; &quot;Spencer&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Person</span>.<span class="hljs-title function_">getAge</span>());<br><br></code></pre></td></tr></table></figure><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>它是一种不能被实例化仅能被子类继承的特殊类。我们可以使用抽象类定义派生类需要实现的属性和方法如下代码所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript">abstract <span class="hljs-keyword">class</span> <span class="hljs-title class_">Adder</span> &#123;<br>  abstract <span class="hljs-attr">x</span>: number;<br>  abstract <span class="hljs-attr">y</span>: number;<br>  abstract <span class="hljs-title function_">add</span>(): number;<br>  displayName = <span class="hljs-string">&#x27;Adder&#x27;</span>;<br>  <span class="hljs-title function_">addTwice</span>(): number &#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span>) * <span class="hljs-number">2</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NumAdder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Adder</span> &#123;<br>  <span class="hljs-attr">x</span>: number;<br>  <span class="hljs-attr">y</span>: number;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x: number, y: number</span>) &#123;<br>    <span class="hljs-variable language_">super</span>();<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> = x;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span> = y;<br>  &#125;<br><br>  <span class="hljs-title function_">add</span>(): number &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">y</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> numAdder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NumAdder</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numAdder.<span class="hljs-property">displayName</span>); <span class="hljs-comment">// =&gt; &quot;Adder&quot;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numAdder.<span class="hljs-title function_">add</span>()); <span class="hljs-comment">// =&gt; 3</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(numAdder.<span class="hljs-title function_">addTwice</span>()); <span class="hljs-comment">// =&gt; 6</span><br><br></code></pre></td></tr></table></figure><p>继承自Adder的派生类 NumAdder， 实现了抽象类里定义的 x、y 抽象属性和 add 抽象方法。如果派生类中缺少对 x、y、add 这三者中任意一个抽象成员的实现，ts是会报错提示的</p><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><p>泛型指的是类型参数化，即将原来某种具体的类型进行参数化。和定义函数参数一样，我们可以给泛型定义若干个类型参数，并在<strong>调用时</strong>给泛型传入明确的类型参数。设计泛型的目的在于有效约束类型成员之间的关系，比如函数参数和返回值、类或者接口成员和方法之间的关系。</p><p>比如定义了一个 reflect 函数 ，它可以接收一个任意类型的参数，并原封不动地返回参数的值和类型，那我们该如何描述这个函数呢？好像只能用any了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reflect</span>(<span class="hljs-params">param: any</span>) &#123;<br>  <span class="hljs-keyword">return</span> param;<br>&#125;<br><span class="hljs-keyword">const</span> str = <span class="hljs-title function_">reflect</span>(<span class="hljs-string">&#x27;string&#x27;</span>);<br><span class="hljs-keyword">const</span> num = <span class="hljs-title function_">reflect</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>此时，泛型正好可以满足这样的诉求，因为泛型就是将参数的类型定义为一个参数、变量，而不是一个明确的类型，等到函数调用时再传入明确的类型。</p><p>我们可以通过尖括号 &lt;&gt; 语法给函数定义一个泛型参数 P，并指定 param 参数的类型为 P ，如下代码所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">function</span> reflect&lt;P&gt;(<span class="hljs-attr">param</span>: P) &#123;<br>  <span class="hljs-keyword">return</span> param;<br>&#125;<br><br><span class="hljs-keyword">const</span> reflectStr = reflect&lt;string&gt;(<span class="hljs-string">&#x27;string&#x27;</span>);<br><span class="hljs-keyword">const</span> reflectNum = reflect&lt;number&gt;(<span class="hljs-number">1</span>);<br><br></code></pre></td></tr></table></figure><p>这里我们可以看到，尖括号中的 P 表示泛型参数的定义，param 后的 P 表示参数的类型是泛型 P（即类型受 P 约束）。</p><p>然后在调用函数时，我们也通过 &lt;&gt; 语法指定了如下所示的 string、number 类型入参，相应地，reflectStr 的类型是 string，reflectNum 的类型是 number。</p><p>另外，如果调用泛型函数时受泛型约束的参数有传值，泛型参数的入参可以从参数的类型中进行推断，而无须再显式指定类型（可缺省），因此上边的示例可以简写为如下示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JavaScript"><span class="hljs-keyword">const</span> reflectStr2 = <span class="hljs-title function_">reflect</span>(<span class="hljs-string">&#x27;string&#x27;</span>);<br><span class="hljs-keyword">const</span> reflectNum2 = <span class="hljs-title function_">reflect</span>(<span class="hljs-number">1</span>); <br></code></pre></td></tr></table></figure><p>注意：函数的泛型入参必须和参数&#x2F;参数成员建立有效的约束关系才有实际意义。</p><h4 id="在-Vue3-中使用-typescript"><a href="#在-Vue3-中使用-typescript" class="headerlink" title="在 Vue3 中使用 typescript"></a>在 Vue3 中使用 typescript</h4><h5 id="在单文件组件中的用法​"><a href="#在单文件组件中的用法​" class="headerlink" title="在单文件组件中的用法​"></a>在单文件组件中的用法​</h5><p>要在单文件组件中使用 TypeScript，需要在 <code>&lt;script&gt;</code> 标签上加上 lang&#x3D;”ts” 的 attribute。当 lang&#x3D;”ts” 存在时，所有的模板内表达式都将享受到更严格的类型检查。</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; defineComponent &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineComponent</span>(&#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">count</span>: <span class="hljs-number">1</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;)</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-comment">&lt;!-- 启用了类型检查和自动补全 --&gt;</span></span><br><span class="language-xml">  </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">count.toFixed</span>(<span class="hljs-name">2</span>) &#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h5 id="TS-与组合式-API"><a href="#TS-与组合式-API" class="headerlink" title="TS 与组合式 API"></a>TS 与组合式 API</h5><p>通过泛型参数来定义 props 的类型</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> props = defineProps&lt;</span></span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">  foo: string</span><br><span class="hljs-template-variable">  bar?: number</span><br><span class="hljs-template-variable">&#125;</span><span class="language-xml">&gt;()</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>为 <code>ref()</code>标注类型</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">// 得到的类型：Ref&lt;string | number&gt;</span><br><span class="hljs-keyword">const</span> year = <span class="hljs-built_in">ref<span class="hljs-keyword">&lt;<span class="hljs-built_in">string</span> | number&gt;</span></span>(<span class="hljs-string">&#x27;2020&#x27;</span>)<br><br>year.value = <span class="hljs-number">2020</span> <span class="hljs-comment">// 成功！</span><br></code></pre></td></tr></table></figure><h5 id="为组件模版引用标注类型"><a href="#为组件模版引用标注类型" class="headerlink" title="为组件模版引用标注类型"></a>为组件模版引用标注类型</h5><p>例如我们想要调用 Modal 组件的 open 方法</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!-- MyModal.vue --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> </span></span><span class="hljs-template-variable">&#123; ref &#125;</span><span class="language-xml"><span class="language-javascript"> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> isContentShown = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">false</span>)</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> <span class="hljs-title function_">open</span> = (<span class="hljs-params"></span>) =&gt; (isContentShown.<span class="hljs-property">value</span> = <span class="hljs-literal">true</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-title function_">defineExpose</span>(</span></span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">  open</span><br><span class="hljs-template-variable">&#125;</span><span class="language-xml">)</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>为了获取 <code>MyModal</code> 的类型，我们首先需要通过 <code>typeof</code> 得到其类型，再使用 TypeScript 内置的 <code>InstanceType</code> 工具类型来获取其实例类型：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-comment">&lt;!-- App.vue --&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">setup</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;ts&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">MyModal</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./MyModal.vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> modal = ref&lt;<span class="hljs-title class_">InstanceType</span>&lt;<span class="hljs-keyword">typeof</span> <span class="hljs-title class_">MyModal</span>&gt; | <span class="hljs-literal">null</span>&gt;(<span class="hljs-literal">null</span>)</span></span><br><span class="language-javascript"><span class="language-xml"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">const</span> <span class="hljs-title function_">openModal</span> = (<span class="hljs-params"></span>) =&gt; </span></span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">  modal.value?.open()</span><br><span class="hljs-template-variable">&#125;</span><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端开发手册</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发手册</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网页的骨架：HTML 奇幻之旅</title>
    <link href="/2024/06/05/frontendGuide/webBase/html/"/>
    <url>/2024/06/05/frontendGuide/webBase/html/</url>
    
    <content type="html"><![CDATA[<h4 id="1-HTML-的基本结构"><a href="#1-HTML-的基本结构" class="headerlink" title="1. HTML 的基本结构"></a>1. HTML 的基本结构</h4><p>HTML（Hyper Text Markup Language，即超文本标记语言）的基本结构分为四大部分：</p><ol><li><p>**文档声明 (Document Type Declaration, DOCTYPE)**：</p><ul><li>这是一个指令，告诉浏览器文档遵循的 HTML 规范版本。对于 HTML5，声明如下：<code>&lt;!DOCTYPE html&gt;</code>。这行代码位于 HTML 文件的第一行，它不是 HTML 标签，而是 XML 声明的一部分。</li></ul></li><li><p><strong>HTML 根元素</strong>：</p><ul><li><code>&lt;html&gt;</code> 标签是整个 HTML 文档的根元素，它包含所有其他 HTML 元素。</li></ul></li><li><p><strong>头部元素</strong>：</p><ul><li><code>&lt;head&gt;</code> 标签包含有关文档的信息，比如标题、字符集设置、样式表（CSS）引用、脚本（JS）引用等。其中脚本引用也可以放在 <code>&lt;body&gt;</code> 里。</li></ul></li><li><p><strong>主体元素</strong>：</p><ul><li><code>&lt;body&gt;</code> 标签包含网页的主体部分，比如文本、图像、表格、列表、链接等。</li></ul></li></ol><p>下面是一个完整的 HTML 文档的例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;HTML 技术教程。&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;keywords&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;HTML, CSS&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>我的HTML页面<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>CSS 样式<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span>script 脚本<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>欢迎来到我的网站！<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>这是一个段落。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-常用标签"><a href="#2-常用标签" class="headerlink" title="2. 常用标签"></a>2. 常用标签</h4><p>HTML 的常用标签主要分为以下几类（HTML5 新增的标签会在后面 HTML5 新特性一章介绍）：</p><h5 id="2-1-文档结构标签"><a href="#2-1-文档结构标签" class="headerlink" title="2.1. 文档结构标签"></a>2.1. 文档结构标签</h5><ul><li><code>html</code>：文档的根元素</li><li><code>head</code>：文档的头部，包含文档的标题、字符集、CSS 样式表、JS 脚本等。</li><li><code>body</code>：文档的主体部分，包含文档的文本、图片、表格、列表等。</li></ul><h5 id="2-2-文本内容标签"><a href="#2-2-文本内容标签" class="headerlink" title="2.2. 文本内容标签"></a>2.2. 文本内容标签</h5><ul><li><code>h1</code> 到 <code>h6</code>：标题。</li><li><code>p</code>：段落。</li><li><code>a</code>：超链接。</li><li><code>br</code>：换行。</li><li><code>div</code>：块级元素，用于定义一个区域。</li><li><code>span</code>：行内元素，用于定义一个区域。</li></ul><h5 id="2-3-列表标签"><a href="#2-3-列表标签" class="headerlink" title="2.3. 列表标签"></a>2.3. 列表标签</h5><ul><li><code>ul</code>：无序列表。</li><li><code>ol</code>：有序列表。</li><li><code>li</code>：列表项。</li></ul><h5 id="2-4-图片和多媒体标签"><a href="#2-4-图片和多媒体标签" class="headerlink" title="2.4. 图片和多媒体标签"></a>2.4. 图片和多媒体标签</h5><ul><li><code>img</code>：图片。</li><li><code>audio</code>：音频。</li><li><code>video</code>：视频。</li><li><code>iframe</code>：内嵌网页，可以加载另一个 HTML 文档。</li></ul><h5 id="2-5-表格标签"><a href="#2-5-表格标签" class="headerlink" title="2.5. 表格标签"></a>2.5. 表格标签</h5><ul><li><code>table</code>：表格。</li><li><code>tr</code>：表格行。</li><li><code>th</code>：表头单元格。</li><li><code>td</code>：数据单元格。</li></ul><h5 id="2-6-表单标签"><a href="#2-6-表单标签" class="headerlink" title="2.6. 表单标签"></a>2.6. 表单标签</h5><ul><li><code>form</code>：表单。</li><li><code>input</code>：输入框。</li><li><code>button</code>：按钮。</li><li><code>select</code>：下拉框。</li><li><code>textarea</code>：文本域。</li><li><code>label</code>：标签。</li><li><code>radio</code>：单选按钮。</li><li><code>checkbox</code>：复选框。</li></ul><h5 id="2-7-布局和样式控制"><a href="#2-7-布局和样式控制" class="headerlink" title="2.7. 布局和样式控制"></a>2.7. 布局和样式控制</h5><ul><li><code>div</code>：块级元素，用于定义一个区域。</li><li><code>span</code>：行内元素，用于定义一个区域。</li><li><code>link</code>：链接的 CSS 样式表文件。</li><li><code>style</code>：在文件内写的样式。</li></ul><h4 id="3-表单元素"><a href="#3-表单元素" class="headerlink" title="3. 表单元素"></a>3. 表单元素</h4><p>HTML 的表单元素用于收集用户输入的数据，并将其提交给服务器进行处理的关键组成部分。以下是表单的一些核心元素和属性：</p><h5 id="3-1-表单容器"><a href="#3-1-表单容器" class="headerlink" title="3.1. 表单容器"></a>3.1. 表单容器</h5><ul><li><code>form</code>：所有表单元素都应包含在这个标签内。</li></ul><h5 id="3-2-文本输入框"><a href="#3-2-文本输入框" class="headerlink" title="3.2. 文本输入框"></a>3.2. 文本输入框</h5><ul><li><code>input</code> 是最常用的表单元素之一。通过 <code>type</code> 属性定义不同的输入类型，如文本、密码、日期等。</li><li><code>type=&quot;text&quot;</code>：文本输入框。</li><li><code>type=&quot;password&quot;</code>：密码输入框。</li><li><code>type=&quot;email&quot;</code>：邮箱输入框。</li><li><code>type=&quot;number&quot;</code>：数字输入框。</li><li><code>type=&quot;file&quot;</code>：文件上传框。</li><li><code>type=&quot;submit&quot;</code>：提交按钮。</li><li><code>type=&quot;reset&quot;</code>：重置按钮。</li><li><code>type=&quot;button&quot;</code>：按钮。</li><li><code>type=&quot;image&quot;</code>：图片按钮。</li><li><code>type=&quot;hidden&quot;</code>：隐藏域。</li><li><code>type=&quot;checkbox&quot;</code>：复选框。</li><li><code>type=&quot;radio&quot;</code>：单选按钮。</li><li><code>type=&quot;range&quot;</code>：滑块输入框。</li><li><code>type=&quot;color&quot;</code>：颜色选择框。</li><li><code>type=&quot;tel&quot;</code>：电话号码输入框。</li><li><code>type=&quot;url&quot;</code>：URL 输入框。</li><li><code>type=&quot;search&quot;</code>：搜索框。</li><li><code>type=&quot;date&quot;</code>：日期输入框。</li><li><code>type=&quot;time&quot;</code>：时间输入框。</li><li><code>type=&quot;week&quot;</code>：周选择框。</li><li><code>type=&quot;month&quot;</code>：月选择框。</li><li><code>type=&quot;datetime-local&quot;</code>：日期和时间选择框。</li></ul><h5 id="3-3-多行文本输入"><a href="#3-3-多行文本输入" class="headerlink" title="3.3. 多行文本输入"></a>3.3. 多行文本输入</h5><ul><li><code>textarea</code>：多行文本，可通过 <code>rows</code> 和 <code>cols</code> 属性设置行数和列数。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;feedback&quot;</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;4&quot;</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;50&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="3-4-单选按钮-radio"><a href="#3-4-单选按钮-radio" class="headerlink" title="3.4. 单选按钮 (radio)"></a>3.4. 单选按钮 (radio)</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;male&quot;</span>&gt;</span>男<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;female&quot;</span>&gt;</span>女<br></code></pre></td></tr></table></figure><h5 id="3-5-复选框-checkbox"><a href="#3-5-复选框-checkbox" class="headerlink" title="3.5. 复选框 (checkbox)"></a>3.5. 复选框 (checkbox)</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;male&quot;</span>&gt;</span>男<br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;female&quot;</span>&gt;</span>女<br></code></pre></td></tr></table></figure><h5 id="3-6-下拉框-select"><a href="#3-6-下拉框-select" class="headerlink" title="3.6. 下拉框 (select)"></a>3.6. 下拉框 (select)</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;country&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;country&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;cn&quot;</span>&gt;</span>CN<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;usa&quot;</span>&gt;</span>USA<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;uk&quot;</span>&gt;</span>UK<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="3-7-按钮-button"><a href="#3-7-按钮-button" class="headerlink" title="3.7. 按钮 (button)"></a>3.7. 按钮 (button)</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>保存<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>下面是一个完整的 form 表单的例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;post&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 文本输入框 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;name&quot;</span>&gt;</span>用户名:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">required</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 密码输入框 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span>密码:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">required</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 单选按钮 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span>性别:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;male&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;male&quot;</span> <span class="hljs-attr">checked</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;male&quot;</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;female&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;gender&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;female&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;female&quot;</span>&gt;</span>女<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 复选框 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;checkbox&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;subscribe&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;subscribe&quot;</span> <span class="hljs-attr">checked</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;subscribe&quot;</span>&gt;</span>订阅推送信息<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 下拉列表 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;country&quot;</span>&gt;</span>国家:<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;country&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;country&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;cn&quot;</span>&gt;</span>CN<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;usa&quot;</span>&gt;</span>USA<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;uk&quot;</span>&gt;</span>UK<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 提交按钮 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="4-语义化标签的使用"><a href="#4-语义化标签的使用" class="headerlink" title="4. 语义化标签的使用"></a>4. 语义化标签的使用</h4><p>HTML 的语义化标签，简而言之就是让特定的标签去做特定的事。语义化标签的使用使得页面结构更加清晰，便于开发者阅读和维护，同时也有助于搜索引擎和辅助技术（如屏幕阅读器）更好地识别页面内容。</p><h5 id="常见的语义化标签及其用途："><a href="#常见的语义化标签及其用途：" class="headerlink" title="常见的语义化标签及其用途："></a>常见的语义化标签及其用途：</h5><ul><li><code>header</code>：用于表示页面或节的标题。</li><li><code>nav</code>：用于表示导航链接。</li><li><code>main</code>：用于表示页面的主要内容。</li><li><code>article</code>：用于表示独立的文章或内容块。</li><li><code>section</code>：用于表示页面的一部分。</li><li><code>aside</code>：用于表示页面的附加信息。</li><li><code>footer</code>：用于表示页面或节的页脚。</li></ul><table><thead><tr><th>标签名</th><th>英文全称</th><th>中文说明</th></tr></thead><tbody><tr><td>h1~h6</td><td>Header 1 to 6</td><td>标题 1 到 标题 6</td></tr><tr><td>iframe</td><td>Inline frame</td><td>定义内联框架</td></tr><tr><td>ul</td><td>Unordered List</td><td>不排序列表</td></tr><tr><td>li</td><td>List Item</td><td>列表项目</td></tr><tr><td>ol</td><td>Ordered List</td><td>排序列表</td></tr></tbody></table><h4 id="5-HTML5-的新特性"><a href="#5-HTML5-的新特性" class="headerlink" title="5. HTML5 的新特性"></a>5. HTML5 的新特性</h4><ul><li>HTML5 技术结合了 HTML4.01 的相关标准并革新，符合现代网络发展要求，在 2008 年正式发布。主要包括以下几方面：</li></ul><h5 id="5-1-语义化标签"><a href="#5-1-语义化标签" class="headerlink" title="5.1 语义化标签"></a>5.1 语义化标签</h5><p>新增几个语义化标签：</p><ul><li><code>section</code>：代表文档中的一段或者一节；</li><li><code>nav</code>：用于构建导航；</li><li><code>article</code>：表示文档、页面、应用程序或网站中一体化的内容；</li><li><code>aside</code>：代表与页面内容相关、有别于主要内容的部分；</li><li><code>hgroup</code>：代表段或者节的标题；</li><li><code>header</code>：页面的页眉；</li><li><code>footer</code>：页面的页脚；</li><li><code>time</code>：表示日期和时间；</li><li><code>mark</code>：文档中需要突出的文字。</li></ul><h5 id="5-2-表单增强"><a href="#5-2-表单增强" class="headerlink" title="5.2 表单增强"></a>5.2 表单增强</h5><p>引入新的表单元素和属性：</p><ul><li>日期选择器：<code>&lt;input type=&quot;date&quot;&gt;</code></li><li>其他新类型：<code>email</code>、<code>password</code>、<code>time</code>、<code>range</code>（滑块）、<code>color</code>（选择颜色的控件）、<code>search</code></li><li><code>placeholder</code> 属性：简短的提示在用户输入值前会显示在输入域上。</li><li><code>required</code> 属性：要求填写的输入域不能为空。</li><li><code>pattern</code> 属性：描述一个正则表达式用于验证 <code>&lt;input&gt;</code> 元素的值。</li><li><code>min</code> 和 <code>max</code> 属性：设置元素最小值与最大值。</li><li><code>step</code> 属性：为输入域规定合法的数字间隔。</li><li><code>autofocus</code> 属性：规定在页面加载时，域自动地获得焦点。</li><li><code>multiple</code> 属性：规定 <code>&lt;input&gt;</code> 元素中可选择多个值。</li></ul><h5 id="5-3-绘图画布-Canvas-和-SVG"><a href="#5-3-绘图画布-Canvas-和-SVG" class="headerlink" title="5.3 绘图画布 Canvas 和 SVG"></a>5.3 绘图画布 Canvas 和 SVG</h5><p>Canvas 和 SVG 都是 HTML5 中的图形渲染技术，用于在网页中呈现动态或静态图形。</p><ul><li><p><strong>Canvas</strong>：</p><ul><li>使用 JavaScript 来绘制图形。</li><li>提供一个位图渲染环境，可以直接操作像素，适合处理图像、视频和游戏等需要高性能的场景。</li><li>可以通过绘制形状、图像和文本来创建图形，使用各种绘图方法和属性来控制线条、填充和阴影等效果。</li></ul></li><li><p><strong>SVG</strong>：</p><ul><li>使用 XML 描述 2D 图形的格式。</li><li>可以缩放到任意大小而不失真，并且可以在不同的平台和设备上以相同的方式呈现。</li><li>使用矢量图形而不是像素，可以轻松地编辑和修改，并支持更多的交互性和动画效果，常用于页面中一些小图标。</li></ul></li></ul><h5 id="5-4-多媒体"><a href="#5-4-多媒体" class="headerlink" title="5.4 多媒体"></a>5.4 多媒体</h5><p>支持音频和视频播放，无需依赖第三方插件 Flash：</p><ul><li><strong>视频播放</strong>：<code>&lt;video&gt;</code></li><li><strong>音频播放</strong>：<code>&lt;audio&gt;</code></li><li><code>src</code>：音视频的地址</li><li><code>controls</code>：音频播放控制器</li><li><code>autoplay</code>：自动播放</li><li><code>loop</code>：循环播放</li><li><code>poster</code>：指定视频封面图的 URL</li></ul><h5 id="5-5-地理定位"><a href="#5-5-地理定位" class="headerlink" title="5.5 地理定位"></a>5.5 地理定位</h5><p>在 HTML5 中有一个 <code>navigator.geolocation</code> 的特性来判断是否支持获取地理位置。地理位置的定位有 GPS，IP 地址，WiFi，GSM&#x2F;CDMA 几种方法。</p><ul><li><code>navigator.geolocation</code> 有三个方法：<ol><li><code>getCurrentPosition()</code>：获取当前位置。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">navigator.<span class="hljs-property">geolocation</span>.<span class="hljs-title function_">getCurrentPosition</span>(onSuccess, onError, options);<br></code></pre></td></tr></table></figure></li><li><code>watchPosition()</code>：定期轮询设备的位置。</li><li><code>clearWatch()</code>：停止 <code>watchPosition()</code> 轮询。</li></ol></li></ul><h5 id="5-6-数据存储"><a href="#5-6-数据存储" class="headerlink" title="5.6 数据存储"></a>5.6 数据存储</h5><p>HTML5 提供的数据持久化技术（离线存储）：</p><ul><li><p><strong>Application Cache</strong>：本地缓存应用所需的文件</p></li><li><p><strong>LocalStorage 和 SessionStorage</strong>：以键值对（JSON 串）格式存储数据</p></li><li><p><strong>Web SQL</strong>：关系数据库，通过 SQL 语句访问</p></li><li><p><strong>IndexDB</strong>：索引数据库</p></li><li><p><strong>localStorage</strong>：</p><ul><li>永久级别的存储。再次访问同一个域名中的任何页面，都可以提取到数据。只要浏览器不卸载，数据就会一直存在。可以手动删除数据。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 存储数据</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-string">&#x27;value&#x27;</span>);<br><span class="hljs-comment">// 获取数据</span><br><span class="hljs-keyword">let</span> value = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;key&#x27;</span>);<br><span class="hljs-comment">// 删除数据</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&#x27;key&#x27;</span>);<br><span class="hljs-comment">// 清空所有数据</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">clear</span>();<br></code></pre></td></tr></table></figure></li><li><p><strong>sessionStorage</strong>：</p><ul><li>会话级别的存储。仅在当前页面中有效，页面关闭数据销毁，页面之间不可以互相访问。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 存储数据</span><br><span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-string">&#x27;value&#x27;</span>);<br><span class="hljs-comment">// 获取数据</span><br><span class="hljs-keyword">let</span> value = <span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;key&#x27;</span>);<br><span class="hljs-comment">// 删除数据</span><br><span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&#x27;key&#x27;</span>);<br><span class="hljs-comment">// 清空所有数据</span><br><span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">clear</span>();<br></code></pre></td></tr></table></figure></li></ul><p><em>注：</em></p><ol><li><code>localStorage</code> 和 <code>sessionStorage</code> 从名字可以辨认出二者的区别。前者是一直存在本地的，后者只是伴随着会话，窗口一旦关闭就没了。使用上完全相同，具有相同的 API。</li><li>本地存储数据的格式是 JSON 串（key-value 形式）。</li><li>存储数据大小限制：每个域名 5M。</li></ol><h5 id="5-7-多线程"><a href="#5-7-多线程" class="headerlink" title="5.7 多线程"></a>5.7 多线程</h5><p>JavaScript 语言的一大特点就是单线程，同一时间只能做一件事。单线程始终是一个痛点。为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程。但子线程完全受主线程控制，且不得操作 DOM，所以这个新标准并没有改变 JavaScript 单线程的本质。</p><p>Web Workers 是现代浏览器提供的一个 JavaScript 多线程解决方案，使用场景包括：</p><ol><li>进行大计算量的操作；</li><li>实现轮询，改变某些状态；</li><li>页头消息状态更新，如页头的消息个数通知；</li><li>高频用户交互，如拼写检查；</li><li>加密，如发往服务器前加密数据；</li><li>预取数据，为优化网站或网络应用及提升数据加载时间提前加载部分数据。</li></ol><h4 id="6-本地存储"><a href="#6-本地存储" class="headerlink" title="6. 本地存储"></a>6. 本地存储</h4><h5 id="6-1-localStorage"><a href="#6-1-localStorage" class="headerlink" title="6.1 localStorage:"></a>6.1 localStorage:</h5><p>提供了在浏览器关闭后仍然保持数据的能力，数据存储在客户端，并没有过期时间，但有大小限制 5M。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 存储数据</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-string">&#x27;value&#x27;</span>);<br><br><span class="hljs-comment">// 获取数据</span><br><span class="hljs-keyword">let</span> value = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;key&#x27;</span>);<br><br><span class="hljs-comment">// 删除数据</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&#x27;key&#x27;</span>);<br><br><span class="hljs-comment">// 清空所有数据</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">clear</span>();<br></code></pre></td></tr></table></figure><ol><li><p><strong>作用域</strong>：localStorage 只要在相同的协议（如 http）、相同的主机名（host）、相同的端口下（如 8080），就能读取&#x2F;修改到同一份 localStorage 数据。</p></li><li><p><strong>生存期</strong>：localStorage 理论上来说是永久有效的，即不主动清空的话就不会消失，即使保存的数据超出了浏览器所规定的大小，也不会把旧数据清空而只会报错。</p></li><li><p><strong>数据结构</strong>：localStorage 为标准的键值对（Key-Value, 简称 KV）数据类型，简单但也易扩展，只要以某种编码方式把想要存储进 localStorage 的对象转化成字符串，就能轻松支持。</p><p> 可以使用 JSON.stringify() 和 JSON.parse() 方法来转换。</p><p> 举个例子：把对象转换成 JSON 字符串，就能让存储对象了；把图片转换成 DataUrl（base64），就可以存储图片了。</p><p> 另外对于键值对数据类型来说，“键是唯一的”这个特性也是相当重要的，重复以同一个键来赋值的话，会覆盖上次的值。</p></li><li><p><strong>过期时间</strong>：localStorage 是不支持设置过期时间的。但是可以通过自己设置时间和 removeItem、clear 方法结合来实现。</p></li><li><p><strong>大小限制</strong>：5M。</p></li></ol><h5 id="6-2-sessionStorage"><a href="#6-2-sessionStorage" class="headerlink" title="6.2 sessionStorage:"></a>6.2 sessionStorage:</h5><p>用于临时保存同一窗口（或标签页）的数据，在关闭窗口或标签页后将会删除这些数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 存储数据</span><br><span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-string">&#x27;value&#x27;</span>);<br><br><span class="hljs-comment">// 获取数据</span><br><span class="hljs-keyword">let</span> value = <span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;key&#x27;</span>);<br><br><span class="hljs-comment">// 删除数据</span><br><span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&#x27;key&#x27;</span>);<br><br><span class="hljs-comment">// 清空所有数据</span><br><span class="hljs-variable language_">sessionStorage</span>.<span class="hljs-title function_">clear</span>();<br></code></pre></td></tr></table></figure><ol><li><p><strong>作用域</strong>：sessionStorage 操作限制在单个标签页中，在此标签页中进行同源页面访问都可以共享 sessionStorage 数据。同源策略限制，若想在不同页面之间对同一个 sessionStorage 对象进行操作，这些页面必须在同一个协议、同一个主机名和同一个端口下。</p></li><li><p><strong>生存期</strong>：sessionStorage 理论上来说是永久有效的，即不主动清空的话就不会消失，即使保存的数据超出了浏览器所规定的大小，也不会把旧数据清空而只会报错。</p></li><li><p><strong>数据结构</strong>：sessionStorage 为标准的键值对（Key-Value, 简称 KV）数据类型，简单但也易扩展，只要以某种编码方式把想要存储进 sessionStorage 的对象转化成字符串，就能轻松支持。</p><p> 可以使用 JSON.stringify() 和 JSON.parse() 方法来转换。</p><p> 举个例子：把对象转换成 JSON 字符串，就能让存储对象了；把图片转换成 DataUrl（base64），就可以存储图片了。</p><p> 另外对于键值对数据类型来说，“键是唯一的”这个特性也是相当重要的，重复以同一个键来赋值的话，会覆盖上次的值。</p></li><li><p><strong>过期时间</strong>：sessionStorage 是不支持设置过期时间的。但是可以通过自己设置时间和 removeItem、clear 方法结合来实现。</p></li><li><p><strong>大小限制</strong>：5M。</p></li></ol><h5 id="6-3-cookie"><a href="#6-3-cookie" class="headerlink" title="6.3 cookie"></a>6.3 cookie</h5><p>HTTP 协议本身是无状态的，这和 HTTP 最初的设计是相符的，每次请求都是创建一个短连接，发送请求，得到数据后就关闭连接。即每次连接都是独立的一次连接。</p><p>这样的话，导致的问题就是当我在一个页面登陆了账号之后，点击连接打开的新界面或者关闭后再打开我都需要再次登陆账号，所以我们需要借助 Cookie 和 Session 来记录网页的状态。</p><p>Cookie，有时也用其复数形式 Cookies。可以简单地理解为存储在浏览器的文本数据。</p><p>Cookie 按域名来进行存储，不同的域名存储的 Cookie 互相之间不能访问，是隔绝的。而在当前域名存在 Cookie 时，每次向服务端进行请求时都会在 HTTP 请求头中，把当前域名下的所有 Cookie 都一起进行提交。这样服务端就可以获取当前网站存储的所有 Cookie 数据。</p><ol><li><p><strong>Cookie 的作用</strong>就是用于解决 “如何记录客户端的用户信息”，存储于用户电脑上的文本文件中。当用户访问 web 页面时，他的名字可以记录在 cookie 中。在用户下一次访问该页面时，可以在 cookie 中读取用户访问记录。</p></li><li><p><strong>Cookie 以 key-value 对形式存储</strong>，如：<code>username=John Doe</code></p></li><li><p>当浏览器从服务器上请求 web 页面时，属于该页面的 cookie 会被添加到该请求中（cookie 会在同源的 http 请求携带），服务端通过这种方式来获取用户的信息。</p></li><li><p>前端、后端都可以单独的操作 Cookie，对其进行增删改查。</p></li><li><p>JavaScript 可以使用 <code>document.cookie</code> 属性来创建、读取及删除 cookie。</p></li></ol><p>Cookie 可以保存数据一段时间，只需要设置过期时间，过期时间到了，数据才会被删除；也可以是临时 cookie&#x2F;会话 cookie，关闭浏览器，数据就会被删除。</p><p>一些需要注意的地方：</p><ul><li><strong>可能会被用户禁用</strong>：Cookie 是保存在浏览器端的，所以用户有权利选择关闭 Cookie。</li><li><strong>存储大小有限制</strong>：不同的浏览器都对 Cookie 的存储大小有限制，Cookie 不宜存储过多的数据，不超过 4k。</li><li><strong>容易被删除</strong>：用户可以随时清空 Cookie。</li><li><strong>安全性不够高</strong>：Cookie 是用明文的方式存储的，不适合保存敏感的数据。</li></ul><ol start="6"><li><strong>Cookie 与 Session 的区别</strong>：</li></ol><ul><li>Cookie 是客户端信息，Session 是服务端信息；</li><li>Session 在客户端中，通过 Cookie 记录；</li><li>非 Session 的 Cookie 不会随着浏览器关闭而消失，Session 会消失；</li><li>Session 过期，导致回话过期，网站重新登录等等。</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端开发手册</category>
      
      <category>网页基石：HTML &amp; CSS 的神奇组合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发手册</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vite：快速构建现代前端项目的利器</title>
    <link href="/2024/06/02/frontendGuide/environment/vite/"/>
    <url>/2024/06/02/frontendGuide/environment/vite/</url>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>Vite 是由尤雨溪（Evan You）创建的一种新型前端构建工具。它旨在通过利用现代浏览器的原生 ES 模块支持，实现快速的开发和构建。今天，我们将带你深入了解 Vite 的特点、如何初始化 Vite 项目、配置文件的详细说明，以及与 Webpack 的对比。</p><h4 id="Vite-的特点与优势"><a href="#Vite-的特点与优势" class="headerlink" title="Vite 的特点与优势"></a>Vite 的特点与优势</h4><p>Vite 与传统的前端构建工具相比，具有以下显著特点和优势：</p><ol><li><strong>极速启动</strong>：Vite 利用浏览器的原生 ES 模块支持，不需要打包，可以即时启动开发服务器，无需等待繁重的打包过程。</li><li><strong>即时热更新（HMR）</strong>：Vite 通过模块热替换（Hot Module Replacement, HMR），实现了快速响应的热更新，使得开发者在修改代码后，页面能够迅速更新而无需完全刷新。</li><li><strong>优化的生产构建</strong>：尽管开发时不进行打包，Vite 依然能够在生产环境中利用 Rollup 进行高效的代码打包和优化，确保最终构建的应用性能最佳。</li><li><strong>丰富的插件生态</strong>：Vite 基于 Rollup 的插件接口，拥有丰富的插件生态系统，可以满足各种前端项目的需求。</li></ol><h4 id="Vite-的项目初始化"><a href="#Vite-的项目初始化" class="headerlink" title="Vite 的项目初始化"></a>Vite 的项目初始化</h4><p>初始化一个 Vite 项目非常简单，只需几步即可完成：</p><ol><li><p><strong>安装 Vite</strong>：<br>首先，全局安装 Vite：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g create-vite<br></code></pre></td></tr></table></figure></li><li><p><strong>创建新项目</strong>：<br>使用 Vite 创建一个新项目：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm create vite@latest<br></code></pre></td></tr></table></figure></li><li><p><strong>选择模板</strong>：<br>在创建项目过程中，Vite 提供了多种模板选择，例如 Vue、React、Svelte 等。根据需要选择适合的模板。</p></li><li><p><strong>安装依赖</strong>：<br>进入项目目录后，安装项目依赖：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> my-vite-project<br>npm install<br></code></pre></td></tr></table></figure></li><li><p><strong>启动开发服务器</strong>：<br>启动 Vite 开发服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm run dev<br></code></pre></td></tr></table></figure></li></ol><p>这样，一个 Vite 项目就初始化完成了，开发者可以开始愉快的开发之旅。</p><h4 id="Vite-配置文件详解"><a href="#Vite-配置文件详解" class="headerlink" title="Vite 配置文件详解"></a>Vite 配置文件详解</h4><p>Vite 的配置文件是 <code>vite.config.js</code>，它使用了 JavaScript 或 TypeScript 编写，允许开发者根据项目需求进行个性化配置。以下是配置文件的详细说明：</p><ol><li><p><strong>基础配置</strong>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">root</span>: <span class="hljs-string">&#x27;./src&#x27;</span>, <span class="hljs-comment">// 项目根目录</span><br>  <span class="hljs-attr">base</span>: <span class="hljs-string">&#x27;/&#x27;</span>,     <span class="hljs-comment">// 公共基础路径</span><br>  <span class="hljs-attr">server</span>: &#123;<br>    <span class="hljs-attr">port</span>: <span class="hljs-number">3000</span>, <span class="hljs-comment">// 开发服务器端口</span><br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p><strong>插件配置</strong>：<br>Vite 支持使用插件，可以在配置文件中添加插件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@vitejs/plugin-vue&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">plugins</span>: [<span class="hljs-title function_">vue</span>()],<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p><strong>构建配置</strong>：<br>可以自定义构建选项，例如输出目录、打包策略等：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">build</span>: &#123;<br>    <span class="hljs-attr">outDir</span>: <span class="hljs-string">&#x27;dist&#x27;</span>,    <span class="hljs-comment">// 输出目录</span><br>    <span class="hljs-attr">sourcemap</span>: <span class="hljs-literal">true</span>,   <span class="hljs-comment">// 生成 source map</span><br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p><strong>别名配置</strong>：<br>配置模块路径别名，简化模块导入路径：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; defineConfig &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vite&#x27;</span>;<br><span class="hljs-keyword">import</span> path <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;path&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">resolve</span>: &#123;<br>    <span class="hljs-attr">alias</span>: &#123;<br>      <span class="hljs-string">&#x27;@&#x27;</span>: path.<span class="hljs-title function_">resolve</span>(__dirname, <span class="hljs-string">&#x27;src&#x27;</span>),<br>    &#125;,<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p><strong>代理配置</strong>：<br>配置开发服务器代理，解决跨域问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineConfig</span>(&#123;<br>  <span class="hljs-attr">server</span>: &#123;<br>    <span class="hljs-attr">proxy</span>: &#123;<br>      <span class="hljs-string">&#x27;/api&#x27;</span>: &#123;<br>        <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://localhost:5000&#x27;</span>,<br>        <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>      &#125;,<br>    &#125;,<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure></li></ol><h4 id="Vite-与-Webpack-的对比"><a href="#Vite-与-Webpack-的对比" class="headerlink" title="Vite 与 Webpack 的对比"></a>Vite 与 Webpack 的对比</h4><p>Vite 和 Webpack 都是流行的前端构建工具，但它们在设计理念和实现方式上有显著的不同。</p><ol><li><p><strong>启动速度</strong>：</p><ul><li><strong>Vite</strong>：利用浏览器的原生 ES 模块支持，启动速度极快，因为无需预打包所有模块。</li><li><strong>Webpack</strong>：启动时需要对项目进行一次完整的打包，启动速度较慢。</li></ul></li><li><p><strong>热更新</strong>：</p><ul><li><strong>Vite</strong>：利用 HMR 实现即时热更新，速度快，响应迅速。</li><li><strong>Webpack</strong>：也支持 HMR，但由于需要打包处理，响应速度相对较慢。</li></ul></li><li><p><strong>构建过程</strong>：</p><ul><li><strong>Vite</strong>：开发阶段不进行打包，生产环境下使用 Rollup 进行优化打包。</li><li><strong>Webpack</strong>：无论开发还是生产环境，都会进行打包，开发过程中构建速度较慢。</li></ul></li><li><p><strong>配置复杂度</strong>：</p><ul><li><strong>Vite</strong>：配置相对简单，基于 Rollup 插件系统，易于上手。</li><li><strong>Webpack</strong>：配置灵活强大，但相对复杂，需要较多的配置文件。</li></ul></li><li><p><strong>生态系统</strong>：</p><ul><li><strong>Vite</strong>：基于 Rollup 插件系统，拥有丰富的插件生态。</li><li><strong>Webpack</strong>：插件生态庞大，几乎可以满足所有前端项目的需求。</li></ul></li></ol><h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>Vite 是一个现代前端开发的利器，通过极速启动、即时热更新和优化的生产构建，大大提高了开发效率。通过简单的项目初始化和灵活的配置，Vite 能够满足各种前端项目的需求。相比于传统的 Webpack，Vite 在开发体验和构建速度上都有显著的优势。</p>]]></content>
    
    
    <categories>
      
      <category>前端开发手册</category>
      
      <category>前端新手村：环境配置轻松上手</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发手册</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>package.json 的揭秘之旅：让你的项目配置更轻松</title>
    <link href="/2024/06/02/frontendGuide/environment/package.json/"/>
    <url>/2024/06/02/frontendGuide/environment/package.json/</url>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在前端开发中，<code>package.json</code> 文件是一个至关重要的配置文件。它不仅定义了项目的元数据，还管理了依赖项、脚本命令和其他配置项。今天，我们将带你深入了解 <code>package.json</code> 的结构和功能，让你轻松掌握这个神奇的文件。</p><h4 id="文件结构解析"><a href="#文件结构解析" class="headerlink" title="文件结构解析"></a>文件结构解析</h4><p><code>package.json</code> 文件的结构包括多个关键字段，每个字段有其特定的用途。下面我们来逐一解析这些字段。</p><h5 id="name"><a href="#name" class="headerlink" title="name"></a>name</h5><p><strong>name</strong>: 项目名称</p><ul><li>必须是小写字母，可以包含连字符和下划线。</li><li>示例：<code>&quot;name&quot;: &quot;my-awesome-project&quot;</code></li></ul><h5 id="version"><a href="#version" class="headerlink" title="version"></a>version</h5><p><strong>version</strong>: 项目版本号</p><ul><li>遵循语义化版本规范（SemVer）。</li><li>示例：<code>&quot;version&quot;: &quot;1.0.0&quot;</code></li></ul><h5 id="description"><a href="#description" class="headerlink" title="description"></a>description</h5><p><strong>description</strong>: 项目描述</p><ul><li>对项目的简要描述。</li><li>示例：<code>&quot;description&quot;: &quot;A brief description of my project&quot;</code></li></ul><h5 id="main"><a href="#main" class="headerlink" title="main"></a>main</h5><p><strong>main</strong>: 入口文件</p><ul><li>指定项目的主文件。</li><li>示例：<code>&quot;main&quot;: &quot;index.js&quot;</code></li></ul><h5 id="scripts"><a href="#scripts" class="headerlink" title="scripts"></a>scripts</h5><p><strong>scripts</strong>: 脚本命令</p><ul><li>定义各种运行命令，可以通过 <code>npm run &lt;script&gt;</code> 来执行。</li><li>示例：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node index.js&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;mocha&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="dependencies"><a href="#dependencies" class="headerlink" title="dependencies"></a>dependencies</h5><p><strong>dependencies</strong>: 生产环境依赖</p><ul><li>项目在运行时所需的依赖包。</li><li>示例：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;express&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^4.17.1&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;axios&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^0.21.1&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="devDependencies"><a href="#devDependencies" class="headerlink" title="devDependencies"></a>devDependencies</h5><p><strong>devDependencies</strong>: 开发环境依赖</p><ul><li>仅在开发时使用的依赖包。</li><li>示例：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;devDependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;mocha&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^8.2.1&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;eslint&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^7.15.0&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="repository"><a href="#repository" class="headerlink" title="repository"></a>repository</h5><p><strong>repository</strong>: 代码仓库信息</p><ul><li>项目代码所在的仓库地址。</li><li>示例：<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;repository&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;git&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;url&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://github.com/username/repo.git&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li></ul><h5 id="keywords"><a href="#keywords" class="headerlink" title="keywords"></a>keywords</h5><p><strong>keywords</strong>: 关键字</p><ul><li>有助于搜索和识别项目的关键词列表。</li><li>示例：<code>&quot;keywords&quot;: [&quot;nodejs&quot;, &quot;express&quot;, &quot;api&quot;]</code></li></ul><h5 id="author"><a href="#author" class="headerlink" title="author"></a>author</h5><p><strong>author</strong>: 作者信息</p><ul><li>项目作者的姓名或组织名。</li><li>示例：<code>&quot;author&quot;: &quot;John Doe&quot;</code></li></ul><h5 id="license"><a href="#license" class="headerlink" title="license"></a>license</h5><p><strong>license</strong>: 项目许可证</p><ul><li>指定项目使用的开源许可证。</li><li>示例：<code>&quot;license&quot;: &quot;MIT&quot;</code></li></ul><h4 id="启动命令详解"><a href="#启动命令详解" class="headerlink" title="启动命令详解"></a>启动命令详解</h4><p>在 <code>package.json</code> 文件中，<code>scripts</code> 字段定义了各种运行命令。开发者可以通过 <code>npm run &lt;script&gt;</code> 执行这些命令。常见的启动命令包括：</p><ul><li><p><strong>start</strong>: 启动应用的主要命令。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;start&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;node index.js&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>使用 <code>npm run start</code> 或 <code>npm start</code> 即可执行。</p></li><li><p><strong>test</strong>: 运行测试脚本。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;test&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;mocha&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>使用 <code>npm run test</code> 即可执行。</p></li><li><p><strong>build</strong>: 构建项目的命令。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;scripts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;build&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;webpack --config webpack.config.js&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>使用 <code>npm run build</code> 即可执行。</p></li></ul><h4 id="依赖版本管理策略"><a href="#依赖版本管理策略" class="headerlink" title="依赖版本管理策略"></a>依赖版本管理策略</h4><p>在 <code>package.json</code> 文件中，依赖项通常使用语义化版本控制（SemVer）。版本号格式为 <code>MAJOR.MINOR.PATCH</code>，分别表示主版本号、次版本号和修订号。管理依赖版本时，开发者可以使用以下符号：</p><ul><li><code>^</code>：表示兼容某个主版本，允许次版本和修订号变化（例如：<code>^1.2.3</code> 表示 <code>1.x.x</code>）。</li><li><code>~</code>：表示兼容某个次版本，允许修订号变化（例如：<code>~1.2.3</code> 表示 <code>1.2.x</code>）。</li></ul><h4 id="如何安装新的第三方依赖包"><a href="#如何安装新的第三方依赖包" class="headerlink" title="如何安装新的第三方依赖包"></a>如何安装新的第三方依赖包</h4><p>安装新的第三方依赖包有几种常见方式，主要取决于你使用的是 npm 还是 yarn。以下是详细的安装方法：</p><h5 id="安装单个依赖包"><a href="#安装单个依赖包" class="headerlink" title="安装单个依赖包"></a>安装单个依赖包</h5><p><strong>使用 npm</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install axios<br></code></pre></td></tr></table></figure><p><strong>使用 yarn</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yarn add axios<br></code></pre></td></tr></table></figure><h5 id="安装多个依赖包"><a href="#安装多个依赖包" class="headerlink" title="安装多个依赖包"></a>安装多个依赖包</h5><p><strong>使用 npm</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install axios react<br></code></pre></td></tr></table></figure><p><strong>使用 yarn</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yarn add axios react<br></code></pre></td></tr></table></figure><h5 id="安装特定版本的依赖包"><a href="#安装特定版本的依赖包" class="headerlink" title="安装特定版本的依赖包"></a>安装特定版本的依赖包</h5><p><strong>使用 npm</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install axios@0.21.1<br></code></pre></td></tr></table></figure><p><strong>使用 yarn</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yarn add axios@0.21.1<br></code></pre></td></tr></table></figure><h5 id="全局安装依赖包"><a href="#全局安装依赖包" class="headerlink" title="全局安装依赖包"></a>全局安装依赖包</h5><p><strong>使用 npm</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g typescript<br></code></pre></td></tr></table></figure><p><strong>使用 yarn</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yarn global add typescript<br></code></pre></td></tr></table></figure><h5 id="安装开发环境依赖包"><a href="#安装开发环境依赖包" class="headerlink" title="安装开发环境依赖包"></a>安装开发环境依赖包</h5><p><strong>使用 npm</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save-dev eslint<br></code></pre></td></tr></table></figure><p><strong>使用 yarn</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yarn add --dev eslint<br></code></pre></td></tr></table></figure><h4 id="package-lock-json-如何生成及作用"><a href="#package-lock-json-如何生成及作用" class="headerlink" title="package-lock.json 如何生成及作用"></a>package-lock.json 如何生成及作用</h4><p><code>package-lock.json</code> 文件在每次运行 <code>npm install</code> 命令时自动生成。它详细记录了项目中所有安装的依赖项的确切版本和依赖关系，确保团队中的每个人在安装依赖时都能得到相同的依赖版本。该文件的主要作用包括：</p><ul><li><strong>锁定依赖版本</strong>：确保开发和生产环境中的依赖版本一致，避免因版本差异导致的 Bug。</li><li><strong>提高安装速度</strong>：减少依赖解析时间，因为 <code>package-lock.json</code> 已经记录了所有依赖关系。</li></ul><p><code>package-lock.json</code> 是维护项目稳定性的重要文件，应与 <code>package.json</code> 一起提交到版本控制系统中。</p><h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>通过这篇文章，我们详细解析了 <code>package.json</code> 文件的结构和功能，并介绍了如何使用 npm 和 yarn 安装第三方依赖包以及 <code>package-lock.json</code> 的作用。希望这段讲解能帮助你更好地理解和使用 <code>package.json</code> 文件，让你的前端开发之路更加顺畅。</p>]]></content>
    
    
    <categories>
      
      <category>前端开发手册</category>
      
      <category>前端新手村：环境配置轻松上手</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发手册</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>npm 介绍：Node.js 项目管理的利器</title>
    <link href="/2024/06/02/frontendGuide/environment/npm/"/>
    <url>/2024/06/02/frontendGuide/environment/npm/</url>
    
    <content type="html"><![CDATA[<h1 id="npm的安装与使用"><a href="#npm的安装与使用" class="headerlink" title="npm的安装与使用"></a>npm的安装与使用</h1><h2 id="什么是-npm"><a href="#什么是-npm" class="headerlink" title="什么是 npm"></a>什么是 npm</h2><ul><li><p>npm（全称 Node Package Manager）是一个软件包管理系统，专门管理用 JavaScript 编写的软件包。可以免费下载别人写好的 js软件包，并用到项目中，当然也可以上传共享自己写的 js软件包。</p></li><li><p>Node.js 内置了npm，只要安装了node.js，就可以直接使用 npm</p></li><li><p>安装完 node.js 后，把npm更新到最新版本:</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install <span class="hljs-built_in">npm</span>@latest -g<br></code></pre></td></tr></table></figure></li></ul><h2 id="项目中使用npm"><a href="#项目中使用npm" class="headerlink" title="项目中使用npm"></a>项目中使用npm</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>根据提示填写对应信息，即可产生package.json 文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">cd <span class="hljs-tag">&lt;<span class="hljs-name">项目根目录</span>&gt;</span><br>npm init <br></code></pre></td></tr></table></figure><h3 id="使用-npm-下载安装包"><a href="#使用-npm-下载安装包" class="headerlink" title="使用 npm 下载安装包"></a>使用 npm 下载安装包</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment"># 安装需要使用的包</span><br>npm <span class="hljs-keyword">install</span> lodash<br><br><span class="hljs-comment"># 安装完成后，package.json 中会添加版本信息，如下：</span><br>&#123;<br>  <span class="hljs-string">&quot;dependencies&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;lodash&quot;</span>: <span class="hljs-string">&quot;^1.0.0&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用安装的包"><a href="#使用安装的包" class="headerlink" title="使用安装的包"></a>使用安装的包</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> lodash = require(<span class="hljs-string">&#x27;lodash&#x27;</span>);<br><span class="hljs-keyword">var</span> output = lodash.without([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-number">1</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(output);<br><br></code></pre></td></tr></table></figure><h3 id="更新包"><a href="#更新包" class="headerlink" title="更新包"></a>更新包</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-comment"># 法一：根据版本号更新</span><br><span class="hljs-built_in">npm</span> install lodash@版本号<br><br><span class="hljs-comment"># 法二：更新最新版本</span><br><span class="hljs-built_in">npm</span> install lodash<br><span class="hljs-built_in">npm</span> install lodash@latest<br><br><span class="hljs-comment"># 法三：修改 package.json 中包的版本号，下一次npm install会自动更新会修改后的版本。</span><br><br></code></pre></td></tr></table></figure><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-comment"># 全局安装 lodash</span><br><span class="hljs-built_in">npm</span> install -g lodash<br><br><span class="hljs-comment"># 本地安装 lodash（默认安装最新版本）</span><br><span class="hljs-built_in">npm</span> install lodash<br><span class="hljs-built_in">npm</span> install lodash@latest<br><br><span class="hljs-comment"># 安装指定版本</span><br><span class="hljs-built_in">npm</span> install lodash@<span class="hljs-number">1.0</span><span class="hljs-number">.0</span><br><br><span class="hljs-comment"># 卸载</span><br><span class="hljs-built_in">npm</span> uninstall lodash <br><br><span class="hljs-comment"># 查看已安装</span><br><span class="hljs-built_in">npm</span> ls <br><br><span class="hljs-comment"># 更新 lodash 到最新版本</span><br><span class="hljs-built_in">npm</span> update lodash <br><br><span class="hljs-comment"># 搜索 lodash</span><br><span class="hljs-built_in">npm</span> search lodash <br></code></pre></td></tr></table></figure><h2 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h2><h3 id="Error-Cannot-find-module"><a href="#Error-Cannot-find-module" class="headerlink" title="Error: Cannot find module"></a>Error: Cannot find module</h3><ul><li>当出现如下错误提示，表示 packages 没有被安装：<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs subunit">module.js:340<br>    throw err;<br>          ^<br><span class="hljs-keyword">Error: </span>Cannot find module &#x27;lodash&#x27;<br></code></pre></td></tr></table></figure></li><li>解决方案：<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-comment"># 无作用域包安装</span><br><span class="hljs-built_in">npm</span> install &lt;package_name&gt;<br><br><span class="hljs-comment"># 有作用域包安装</span><br><span class="hljs-built_in">npm</span> install &lt;@scope/package_name&gt;<br></code></pre></td></tr></table></figure></li></ul><h3 id="安装出错"><a href="#安装出错" class="headerlink" title="安装出错"></a>安装出错</h3><p>错误提示：npm resource busy or locked….. 可以先清除再重新安装：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> cache clean<br><span class="hljs-built_in">npm</span> install<br><br></code></pre></td></tr></table></figure><h2 id="版本控制符"><a href="#版本控制符" class="headerlink" title="版本控制符"></a>版本控制符</h2><p>版本号有三位数字组成（譬如：1.2.3），1 表示主版本、1.2表示次要版本、1.2.3 表示补丁版本。<br>^  表示用于确定主版本号、 ~  用于确定主版本号 + 次要版本号；</p><ul><li>^1 ：等同于 1.x.x ,  以1开头的所有版本；</li><li>~2.2 ：等同于 2.2.x ，以  2.2  开头的所有版本。</li><li>~2.2.1 ：以  2.2  开头，且最后一位 补丁号≥1 的所有版本，即 2.2.1  与 2.2.9 之间版本，包括头尾。</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// 可使用在package.json中</span><br><span class="hljs-attr">&quot;dependencies&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;my_dep&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;^1.0.0&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;another_dep&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;~2.2.0&quot;</span><br><span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br></code></pre></td></tr></table></figure><h1 id="nrm-的安装和使用"><a href="#nrm-的安装和使用" class="headerlink" title="nrm 的安装和使用"></a>nrm 的安装和使用</h1><p>npm 默认镜像源是 <a href="https://registry.npmjs.org/%EF%BC%8C%E5%9C%A8%E5%9B%BD%E5%86%85%E8%AE%BF%E9%97%AE%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%BE%88%E6%85%A2%E3%80%82%E5%90%8E%E6%9D%A5%EF%BC%8C%E6%B7%98%E5%AE%9D%E5%81%9A%E4%BA%86%E4%B8%80%E4%B8%AA%E9%95%9C%E5%83%8F%E7%BD%91%E7%AB%99%EF%BC%88[npmmirror](https://www.npmmirror.com/)%EF%BC%89%EF%BC%8C%E4%BB%A5%E4%BE%BF%E5%9B%BD%E5%86%85%E5%BC%80%E5%8F%91%E8%80%85%E8%AE%BF%E9%97%AE%E3%80%82">https://registry.npmjs.org/，在国内访问可能会很慢。后来，淘宝做了一个镜像网站（[npmmirror](https://www.npmmirror.com/)），以便国内开发者访问。</a></p><p>使用 <code>npm</code> 命令，设置设置镜像源：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">$ npm config set registry https:<span class="hljs-comment">//registry.npmmirror.com/</span><br></code></pre></td></tr></table></figure><p>命令有点长，特别是源地址，不好记。下文将会介绍使用 nrm 来快速切换。</p><h2 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h2><h3 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">$ <span class="hljs-built_in">npm</span> i -g nrm<br></code></pre></td></tr></table></figure><h3 id="查看所有源"><a href="#查看所有源" class="headerlink" title="查看所有源"></a>查看所有源</h3><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">$ nrm <span class="hljs-keyword">ls</span><br><br>* npm <span class="hljs-params">--------</span> https:<span class="hljs-string">//registry.npmjs.org/</span><br>  yarn <span class="hljs-params">-------</span> https:<span class="hljs-string">//registry.yarnpkg.com/</span><br>  cnpm <span class="hljs-params">-------</span> http:<span class="hljs-string">//r.cnpmjs.org/</span><br>  taobao <span class="hljs-params">-----</span> https:<span class="hljs-string">//www.npmmirror.com/</span><br>  nj <span class="hljs-params">---------</span> https:<span class="hljs-string">//registry.nodejitsu.com/</span><br>  npmMirror -- https:<span class="hljs-string">//skimdb.npmjs.com/registry/</span><br>  edunpm <span class="hljs-params">-----</span> http:<span class="hljs-string">//registry.enpmjs.org/</span><br><br></code></pre></td></tr></table></figure><h3 id="切换源"><a href="#切换源" class="headerlink" title="切换源"></a>切换源</h3><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>nrm <span class="hljs-keyword">use</span> &lt;registry&gt;<br></code></pre></td></tr></table></figure><h3 id="添加源"><a href="#添加源" class="headerlink" title="添加源"></a>添加源</h3><p>适用于企业内部定制的私有源，<code>&lt;registry&gt;</code> 表示源名称，<code>&lt;url&gt;</code> 表示源地址。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ nrm <span class="hljs-built_in">add</span> <span class="hljs-symbol">&lt;registry&gt;</span> <span class="hljs-symbol">&lt;url&gt;</span><br><br></code></pre></td></tr></table></figure><h3 id="删除源"><a href="#删除源" class="headerlink" title="删除源"></a>删除源</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> nrm <span class="hljs-built_in">del</span> &lt;registry&gt;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端开发手册</category>
      
      <category>前端新手村：环境配置轻松上手</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发手册</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node.js 安装和使用指南</title>
    <link href="/2024/06/02/frontendGuide/environment/nodeJs/"/>
    <url>/2024/06/02/frontendGuide/environment/nodeJs/</url>
    
    <content type="html"><![CDATA[<h1 id="macOS-中安装-Node-js"><a href="#macOS-中安装-Node-js" class="headerlink" title="macOS 中安装 Node.js"></a>macOS 中安装 Node.js</h1><h2 id="什么是-Node-js"><a href="#什么是-Node-js" class="headerlink" title="什么是 Node.js"></a>什么是 Node.js</h2><p><code>Node.js</code> 是一个基于 <code>Chrome V8</code> 引擎的 <code>JavaScript</code> 运行时环境。最早发布于 2009 年 5 月，由 <code>Ryan Dahl</code> 开发。它使用了一个事件驱动、非阻塞式 <code>I/O</code> 模型，让 <code>JavaScript</code> 运行在服务端的开发平台，能让 <code>JavaScript</code> 成为 <code>PHP</code>、<code>Python</code>、<code>Perl</code>、<code>Ruby</code> 等服务端语言的脚本语言。</p><h2 id="下载-Node-js"><a href="#下载-Node-js" class="headerlink" title="下载 Node.js"></a>下载 Node.js</h2><blockquote><ul><li><a href="https://nodejs.org/zh-cn/">下载地址</a></li></ul></blockquote><p><img src="/../../img/frontendGuide/node-mac-1.webp"></p><p>其中 <code>LTS</code> 表示长期维护版本，也更加推荐安装这个版本。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li>下载好安装包之后，双击后缀名为 <code>.pkg</code> 的安装包，会弹出以下的弹窗。弹窗中会提示欢迎语，然后提示 <code>Node.js</code> 和 <code>npm</code> 会安装到硬盘中的地址。</li></ol><ul><li><p><code>Node.js</code>：安装在硬盘中的 <code>/usr/local/bin/node</code> 目录。</p></li><li><p><code>npm</code>：安装在硬盘中的 <code>/usr/local/bin/npm</code> 目录。</p></li></ul><p>这里注意和 <code>Windows</code> 区分一下，因为 <code>macOS</code> 是基于 <code>Unix</code> 开发而来的，所以它的目录结构和 <code>Linux</code> 类似，是在总的根目录 <code>/</code> 下存在子目录。<br><img src="/../../img/frontendGuide/node-mac-2.webp"><br>2. 点击<strong>继续</strong>，会提示软件的相关许可协议。</p><p><img src="/../../img/frontendGuide/node-mac-3.webp"></p><ul><li>如果点击<strong>打印</strong>，而你的电脑也连接了打印机，那么这时候就能够将协议打印出来。</li></ul><p><img src="/../../img/frontendGuide/node-mac-4.webp"></p><ul><li>如果点击<strong>存储</strong>，此时会将协议保存为 <code>pdf</code>，由自己选择存放的路径。</li></ul><p><img src="/../../img/frontendGuide/node-mac-5.webp"></p><ol start="3"><li>再次点击继续，会弹窗提示必须同意相关协议条款才能走下一步。</li></ol><p><img src="/../../img/frontendGuide/node-mac-6.webp"></p><ol start="4"><li>选择软件安装的目的盘，一般来讲，<code>macOS</code> 中没有什么盘之分的，但如果你外接了硬盘，而你需要安装的软件也刚好要放在外接盘中，那么此时就可以选择另一个硬盘。</li></ol><p><img src="/../../img/frontendGuide/node-mac-7.webp"><br><img src="/../../img/frontendGuide/node-mac-8.webp"></p><ol start="5"><li>下一步，此时会提示让输入电脑的密码来开始安装。</li></ol><p><img src="/../../img/frontendGuide/node-mac-9.webp"></p><ol start="6"><li>安装成功，关闭安装窗口即可。</li></ol><p><img src="/../../img/frontendGuide/node-mac-10.webp"></p><h1 id="Windows-安装-Node-js-图文教程"><a href="#Windows-安装-Node-js-图文教程" class="headerlink" title="Windows 安装 Node.js 图文教程"></a>Windows 安装 Node.js 图文教程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本教程所有操作基于<code>Window 10</code>操作系统 + <code>Node.js v12.16.1-x64</code>，原则上适用于所有<code>Windows</code>操作系统，细节不同请根据自己需要自行判断。</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>要安装<code>Node.js</code>，首先需要去下载对应系统安装包，<a href="https://nodejs.org/zh-cn/download/">下载地址</a>；</p><p><img src="/../../img/frontendGuide/node-win-1.png"></p><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><ol><li><p>双击下载好的安装包；</p><p> <img src="/../../img/frontendGuide/node-win-2.png"></p></li><li><p>直接下一步；</p><p> <img src="/../../img/frontendGuide/node-win-3.png"></p></li><li><p>勾选同意相关使用协议，同时下一步；</p><p> <img src="/../../img/frontendGuide/node-win-4.png"></p></li><li><p>修改成你要安装的路径（默认也可以），然后下一步；</p><p> <img src="/../../img/frontendGuide/node-win-5.png"></p></li><li><p>建议不作修改，直接下一步，当然你也可以对里边所需服务进行勾选；</p><p> <img src="/../../img/frontendGuide/node-win-6.png"></p></li><li><p>所需工具自己需要就勾选，不需要就直接下一步；</p><p> <img src="/../../img/frontendGuide/node-win-7.png"></p></li><li><p>直接安装，开始安装；</p><p> <img src="/../../img/frontendGuide/node-win-8.png"></p></li><li><p>完成安装后，点击 Finish 完成安装；</p><p> <img src="/../../img/frontendGuide/node-win-9.png"></p></li></ol><h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>安装后，我们怎样知道自己是否安装成功呢？可以使用如下命令查看，若成功则会返回下图类似结果；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">node -v<br></code></pre></td></tr></table></figure><p><img src="/../../img/frontendGuide/node-win-10.png"></p><h2 id="环境变量配置"><a href="#环境变量配置" class="headerlink" title="环境变量配置"></a>环境变量配置</h2><p>默认情况下，我们利用 <code>npm</code> 包管理器用来安装依赖包时，包会默认存放在 <code>C:\Users\用户名\AppData\Roaming\npm\node_modules</code> 目录下，如果你不确定你的包存放路径在哪儿，那么可以通过如下命令来进行查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm root -g<br></code></pre></td></tr></table></figure><p>但这样就存在一个问题，如果我们的依赖包很多的情况下，就会占用我们系统盘大量的空间，这时候我们如果不想让全局包放在这里，那么就可以自定义存放目录。修改的方式也很简单，只需要在控制台中执行如下两条命令即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm config <span class="hljs-built_in">set</span> prefix <span class="hljs-string">&quot;D:\node\node_global&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm config <span class="hljs-built_in">set</span> cache <span class="hljs-string">&quot;D:\node\node_cache&quot;</span><br></code></pre></td></tr></table></figure><p>当然，我们也可以打开配置文件 <code>.npmrc</code>，然后修改如下两条记录：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml">prefix = D:\node\node_global<br>cache = D:\node\node_cache<br></code></pre></td></tr></table></figure><p><img src="/../../img/frontendGuide/node-win-11.png"></p><h1 id="nvm的安装和使用"><a href="#nvm的安装和使用" class="headerlink" title="nvm的安装和使用"></a>nvm的安装和使用</h1><h2 id="nvm是什么"><a href="#nvm是什么" class="headerlink" title="nvm是什么"></a>nvm是什么</h2><p>nvm全英文也叫node.js version management，是一个nodejs的版本管理工具。nvm和n都是node.js版本管理工具，为了解决node.js各种版本存在不兼容现象可以通过它可以安装和切换不同版本的node.js。</p><h2 id="nvm下载"><a href="#nvm下载" class="headerlink" title="nvm下载"></a>nvm下载</h2><p>可在点此在<a href="https://github.com/coreybutler/nvm-windows/releases">github</a> 上下载最新版本,本次下载安装的是windows版本。打开网址我们可以看到有两个版本：</p><ul><li>nvm 1.1.7-setup.zip：安装版，推荐使用</li><li>nvm 1.1.7-noinstall.zip: 绿色免安装版，但使用时需进行配置。</li></ul><h2 id="nvm安装"><a href="#nvm安装" class="headerlink" title="nvm安装"></a>nvm安装</h2><h3 id="windows安装"><a href="#windows安装" class="headerlink" title="windows安装"></a>windows安装</h3><ol><li><p>卸载之前的node后安装nvm, nvm-setup.exe安装版，直接运行nvm-setup.exe<br><img src="/../../img/frontendGuide/nvm-1.png"></p></li><li><p>选择nvm安装路径<br><img src="/../../img/frontendGuide/nvm-2.png"></p></li><li><p>选择nodejs路径<br><img src="/../../img/frontendGuide/nvm-3.png"></p></li><li><p>确认安装即可<br><img src="/../../img/frontendGuide/nvm-4.png"></p></li><li><p>安装完确认<br><img src="/../../img/frontendGuide/nvm-5.png"></p></li></ol><p>打开CMD，输入命令 nvm ，安装成功则如下显示。可以看到里面列出了各种命令，本节最后会列出这些命令的中文示意。</p><h3 id="mac安装"><a href="#mac安装" class="headerlink" title="mac安装"></a>mac安装</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -o- https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/nvm-sh/</span>nvm<span class="hljs-regexp">/v0.39.1/i</span>nstall.sh | bash<br><br><span class="hljs-comment"># or</span><br><br>wget -qO- https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/nvm-sh/</span>nvm<span class="hljs-regexp">/v0.39.1/i</span>nstall.sh | bash <br></code></pre></td></tr></table></figure><h2 id="nvm命令提示"><a href="#nvm命令提示" class="headerlink" title="nvm命令提示"></a>nvm命令提示</h2><blockquote><ul><li>nvm arch：显示node是运行在32位还是64位。</li><li>nvm install <version> [arch] ：安装node， version是特定版本也可以是最新稳定版本latest。可选参数arch指定安装32位还是64位版本，默认是系统位数。可以添加–insecure绕过远程服务器的SSL。</li><li>nvm list [available] ：显示已安装的列表。可选参数available，显示可安装的所有版本。list可简化为ls。</li><li>nvm on ：开启node.js版本管理。</li><li>nvm off ：关闭node.js版本管理。</li><li>nvm proxy [url] ：设置下载代理。不加可选参数url，显示当前代理。将url设置为none则移除代理。</li><li>nvm node_mirror [url] ：设置node镜像。默认是nodejs.org&#x2F;dist&#x2F;。如果不写u…</li><li>nvm npm_mirror [url] ：设置npm镜像。github.com&#x2F;npm&#x2F;cli&#x2F;arc…</li><li>nvm uninstall <version> ：卸载指定版本node。</li><li>nvm use [version] [arch] ：使用制定版本node。可指定32&#x2F;64位。</li><li>nvm root [path] ：设置存储不同版本node的目录。如果未设置，默认使用当前目录。</li><li>nvm version ：显示nvm版本。version可简化为v。</li></ul></blockquote><h2 id="安装node-js版本"><a href="#安装node-js版本" class="headerlink" title="安装node.js版本"></a>安装node.js版本</h2><p><code>nvm list available</code> 显示可下载版本的部分列表<br><img src="/../../img/frontendGuide/nvm-6.png"></p><p><code>nvm install latest</code> 安装最新版本 ( 安装时可以在上面看到 node.js 、 npm 相应的版本号 ，不建议安装最新版本)<br><img src="/../../img/frontendGuide/nvm-7.png"></p><p><code>nvm install</code> 版本号 安装指定的版本的nodejs<br><img src="/../../img/frontendGuide/nvm-8.png"></p><h2 id="查看已安装版本"><a href="#查看已安装版本" class="headerlink" title="查看已安装版本"></a>查看已安装版本</h2><p><code>nvm list</code>或 <code>nvm ls</code> 查看目前已经安装的版本 （ 当前版本号前面没有 * ， 此时还没有使用任何一个版本，这时使用 node.js 时会报错 ）<br><img src="/../../img/frontendGuide/nvm-9.png"></p><h2 id="切换node版本"><a href="#切换node版本" class="headerlink" title="切换node版本"></a>切换node版本</h2><p><code>nvm use</code> 版本号 使用指定版本的nodejs （ 这时会发现在启用的 node 版本前面有 * 标记，这时就可以使用 node.js ）<br><img src="/../../img/frontendGuide/nvm-10.png"></p>]]></content>
    
    
    <categories>
      
      <category>前端开发手册</category>
      
      <category>前端新手村：环境配置轻松上手</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发手册</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从古至今：前端技术的演变史</title>
    <link href="/2024/06/01/frontendGuide/history/"/>
    <url>/2024/06/01/frontendGuide/history/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在前端开发的历史长河中，有一个名字家喻户晓，那就是 JavaScript。今天，我们要回到互联网的远古时代，揭开 JavaScript 的神秘面纱，看看它是如何从一个简单的脚本语言，变成今天不可或缺的存在的。</p><h2 id="刀耕火种"><a href="#刀耕火种" class="headerlink" title="刀耕火种"></a>刀耕火种</h2><h3 id="JavaScript-的起源和早期发展"><a href="#JavaScript-的起源和早期发展" class="headerlink" title="JavaScript 的起源和早期发展"></a>JavaScript 的起源和早期发展</h3><h4 id="JavaScript-的诞生"><a href="#JavaScript-的诞生" class="headerlink" title="JavaScript 的诞生"></a>JavaScript 的诞生</h4><p>在 1995 年的某个春天，互联网的世界还很简陋，网页就像是数字报纸，只能显示静态内容。Netscape 公司的布兰登·艾奇（Brendan Eich）觉得：嘿，能不能给网页加点互动呢？于是，JavaScript 就这样诞生了。</p><blockquote><p><strong>示意图：布兰登·艾奇和 JavaScript 的诞生</strong><br><img src="/../../img/frontendGuide/1-1.png" alt="布兰登·艾奇"><br><em>图 1：布兰登·艾奇，JavaScript 的创造者</em></p></blockquote><p>布兰登·艾奇只用了10天，就创造了 JavaScript。要知道，很多程序员修一个 Bug 都要10天！这种效率，堪称编程界的奇迹。</p><h4 id="最初的用途和局限"><a href="#最初的用途和局限" class="headerlink" title="最初的用途和局限"></a>最初的用途和局限</h4><p>最初，JavaScript 被称为 Mocha，然后改名为 LiveScript，最后才定名为 JavaScript。这名字听起来高大上，但其实它和 Java 语言几乎没有关系，只是为了蹭 Java 的热度而已。早期的 JavaScript 功能很简单，大概只能做一些表单验证、弹个对话框啥的。</p><blockquote><p><strong>示意图：早期的网页互动</strong><br><img src="/../../img/frontendGuide/1-2.png" alt="早期网页"><br><em>图 2：早期的 JavaScript 互动效果</em></p></blockquote><p>当时的 JavaScript，简直是“程序员的噩梦”：没有模块系统，没有类，甚至连 <code>let</code> 和 <code>const</code> 这种声明变量的方法都没有。写 JavaScript 的感觉，就像是拿着锤子在修手表。</p><h4 id="早期浏览器的支持情况"><a href="#早期浏览器的支持情况" class="headerlink" title="早期浏览器的支持情况"></a>早期浏览器的支持情况</h4><p>当 JavaScript 出现后，浏览器界也不甘示弱。Netscape 率先在自家浏览器中支持了 JavaScript。而微软则推出了 JScript（没错，他们还改了个名字），并在 Internet Explorer 中支持。</p><blockquote><p><strong>示意图：早期浏览器大战</strong><br><img src="/../../img/frontendGuide/1-3.png" alt="早期浏览器大战"><br><em>图 3：Netscape 与 Internet Explorer 的浏览器大战</em></p></blockquote><p>这段时间，浏览器之间的兼容性问题让开发者们欲哭无泪。同一段代码，在 Netscape 上能跑，到了 IE 上就可能直接跪了。开发者们每天都在浏览器之间切换，修复各种稀奇古怪的 Bug，感觉就像在玩浏览器版的俄罗斯方块。</p><h2 id="万物归一"><a href="#万物归一" class="headerlink" title="万物归一"></a>万物归一</h2><h3 id="jQuery-的崛起"><a href="#jQuery-的崛起" class="headerlink" title="jQuery 的崛起"></a>jQuery 的崛起</h3><p>在前端开发的进化史上，有一个时期可以称之为“万物归一”。这段时间，jQuery 横空出世，成为了前端开发的救世主。它不仅简化了 JavaScript 的编写，还为开发者们带来了前所未有的便利。今天，让我们一起来回顾一下 jQuery 的崛起，看看它是如何在混乱的前端世界中一统江湖的。</p><p>2006 年，约翰·瑞西格（John Resig）发布了 jQuery。这位程序员当时一定是灵光乍现，觉得不能再让大家在 DOM 操作的泥沼中挣扎了。于是，他创造了 jQuery，一个让大家可以“写得更少，做得更多”的库。没错，jQuery 的口号就是这么自信。</p><blockquote><p><strong>示意图：jQuery 的崛起</strong><br><img src="https://upload.wikimedia.org/wikipedia/en/9/9e/JQuery_logo.svg" alt="jQuery 标志"><br><em>图 4：jQuery 标志</em></p></blockquote><h4 id="jQuery-的神奇魅力"><a href="#jQuery-的神奇魅力" class="headerlink" title="jQuery 的神奇魅力"></a>jQuery 的神奇魅力</h4><p>jQuery 的魅力在于其简单易用。以往，我们要操作 DOM，代码可能像一篇小作文。但有了 jQuery，一切变得如此简单。比如，我们要隐藏一个元素，从前可能要写一大堆代码，但现在只需一行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">$(<span class="hljs-string">&quot;#myElement&quot;</span>).<span class="hljs-title function_">hide</span>();<br></code></pre></td></tr></table></figure><p>这样简洁的代码，简直是对程序员的最大恩赐。更别提 jQuery 那强大的选择器系统，让你感觉自己像是在用 CSS 而不是写 JavaScript。</p><h4 id="jQuery-插件生态系统"><a href="#jQuery-插件生态系统" class="headerlink" title="jQuery 插件生态系统"></a>jQuery 插件生态系统</h4><p>不仅如此，jQuery 还有一个庞大的插件生态系统。无论你想实现什么功能，总能找到一个现成的 jQuery 插件。想做个幻灯片？没问题，用 <code>slick</code> 插件。想要复杂的表单验证？<code>jQuery Validate</code> 来帮你搞定。可以说，jQuery 的插件让前端开发者感觉自己仿佛拥有了魔法棒，轻轻一点，就能实现各种酷炫效果。</p><blockquote><p><strong>示意图：使用 jQuery 插件</strong><br><img src="/../../img/frontendGuide/1-4.png" alt="使用 jQuery 插件"><br><em>图 5：使用 jQuery 插件的效果</em></p></blockquote><h4 id="jQuery-的巅峰时刻"><a href="#jQuery-的巅峰时刻" class="headerlink" title="jQuery 的巅峰时刻"></a>jQuery 的巅峰时刻</h4><p>在 2010 年代初期，jQuery 几乎统治了整个前端开发领域。根据统计数据，超过 70% 的网站都在使用 jQuery。那时候，如果你不懂 jQuery，几乎就无法生存于前端开发的江湖。开发者们日夜苦练 jQuery，掌握了这门技能，就好像拿到了前端开发的通行证。</p><h4 id="jQuery-的挑战"><a href="#jQuery-的挑战" class="headerlink" title="jQuery 的挑战"></a>jQuery 的挑战</h4><p>然而，天下没有不散的筵席。随着时间的推移，前端开发技术不断进步，新的框架如雨后春笋般冒出。React、Vue、Angular 等现代框架的出现，让开发者们有了更多选择。jQuery 的地位开始受到挑战，特别是在大型应用和组件化开发方面，jQuery 显得有些力不从心。</p><h4 id="jQuery-的遗产"><a href="#jQuery-的遗产" class="headerlink" title="jQuery 的遗产"></a>jQuery 的遗产</h4><p>尽管如此，jQuery 的影响力不可否认。它让前端开发变得更加简单和高效，为现代前端框架的出现铺平了道路。即便在今天，jQuery 仍然在许多项目中扮演重要角色，特别是在那些维护性项目和简单网站中。</p><p>jQuery 的崛起和辉煌，就像一部前端开发的传奇剧。它不仅改变了无数开发者的工作方式，还推动了整个前端技术的发展。虽然今天的前端世界百花齐放，但 jQuery 的精神永远存在，它让我们记住了那段“万物归一”的美好时光。</p><h2 id="百家争鸣"><a href="#百家争鸣" class="headerlink" title="百家争鸣"></a>百家争鸣</h2><h3 id="Angular-js、React-和-Vue-的发展"><a href="#Angular-js、React-和-Vue-的发展" class="headerlink" title="Angular.js、React 和 Vue 的发展"></a>Angular.js、React 和 Vue 的发展</h3><p>在前端开发的历史中，有一个时期可以被称为“百家争鸣”。这段时间，各大框架如雨后春笋般冒出，各显神通。在这场激烈的竞争中，Angular.js、React 和 Vue 成为了最具代表性的三大框架。今天，我们就来看看它们是如何在前端世界中争奇斗艳的。</p><h4 id="Angular-js：全能型选手的起伏"><a href="#Angular-js：全能型选手的起伏" class="headerlink" title="Angular.js：全能型选手的起伏"></a>Angular.js：全能型选手的起伏</h4><p>Angular.js 由 Google 在 2010 年推出，是一个全能型的前端框架。Angular.js 的目标是解决单页应用开发中的痛点，通过提供 MVC 架构，使开发者可以更容易地构建复杂的应用。</p><blockquote><p><strong>示意图：Angular.js 标志</strong><br><img src="https://upload.wikimedia.org/wikipedia/commons/c/cf/Angular_full_color_logo.svg" alt="Angular.js 标志"><br><em>图 6：Angular.js 标志</em></p></blockquote><p>Angular.js 以其双向数据绑定、依赖注入和强大的指令系统迅速赢得了开发者的青睐。双向数据绑定让数据和视图的同步变得前所未有的简单，简直就是开发者的“福音”。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Angular.js 的双向数据绑定示例</span><br>&lt;input ng-model=<span class="hljs-string">&quot;name&quot;</span>&gt;<br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>Hello, &#123;&#123;name&#125;&#125;!<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>然而，Angular.js 的学习曲线陡峭，复杂的概念和语法让不少新手开发者望而却步。Google 也意识到这个问题，于是在 2016 年推出了完全重写的 Angular（也称为 Angular 2 及后续版本），试图解决这些问题。然而，Angular.js 和新 Angular 之间的巨大差异，让不少开发者感到困惑和不满。</p><h4 id="React：组件化和单向数据流的革新"><a href="#React：组件化和单向数据流的革新" class="headerlink" title="React：组件化和单向数据流的革新"></a>React：组件化和单向数据流的革新</h4><p>2013 年，Facebook 发布了 React，一个革命性的前端库。与 Angular.js 不同，React 并不试图成为一个全能框架，而是专注于视图层，通过组件化的方式，使 UI 的构建变得模块化和可复用。</p><blockquote><p><strong>示意图：React 标志</strong><br><img src="https://upload.wikimedia.org/wikipedia/commons/a/a7/React-icon.svg" alt="React 标志"><br><em>图 7：React 标志</em></p></blockquote><p>React 的核心理念是组件化和单向数据流。组件化让开发者可以将 UI 拆分为独立的小组件，每个组件都有自己的状态和逻辑。单向数据流则通过明确的数据流向，降低了应用的复杂性和调试难度。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 一个简单的 React 组件</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, world!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>React 的虚拟 DOM 技术，让页面的更新变得高效而流畅。每次状态改变时，React 会计算出最小的 DOM 变更，然后批量更新，这大大提高了性能。</p><h4 id="Vue：渐进式框架的崛起"><a href="#Vue：渐进式框架的崛起" class="headerlink" title="Vue：渐进式框架的崛起"></a>Vue：渐进式框架的崛起</h4><p>2014 年，尤雨溪（Evan You）发布了 Vue，一个渐进式前端框架。Vue 的设计理念是渐进式，即开发者可以根据需求逐步引入 Vue 的功能，从简单的视图层库，到复杂的单页应用框架，Vue 都能轻松应对。</p><blockquote><p><strong>示意图：Vue 标志</strong><br><img src="https://upload.wikimedia.org/wikipedia/commons/f/f1/Vue.png" alt="Vue 标志"><br><em>图 8：Vue 标志</em></p></blockquote><p>Vue 的语法简单易学，类似于 HTML 和 JavaScript 的结合，非常适合新手上手。同时，Vue 也借鉴了 Angular.js 和 React 的优点，提供了数据绑定和组件化的能力。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 一个简单的 Vue 组件</span><br><span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>(&#123;<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>  <span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Hello, Vue!&#x27;</span><br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>Vue 的生态系统也非常完善，从路由管理（Vue Router）到状态管理（Vuex），都有完整的解决方案。其灵活性和易用性，使得 Vue 在短时间内迅速流行，成为前端开发的新宠。</p><h3 id="Angular-js、React-和-Vue-的竞相辉煌"><a href="#Angular-js、React-和-Vue-的竞相辉煌" class="headerlink" title="Angular.js、React 和 Vue 的竞相辉煌"></a>Angular.js、React 和 Vue 的竞相辉煌</h3><p>在前端开发的历史中，Angular.js、React 和 Vue 各自发挥了重要的作用。它们的出现，让前端开发变得更加高效和灵活，推动了整个行业的发展。尽管它们各有优劣，但正是这种百家争鸣的局面，激发了更多的创新和进步。</p><h2 id="未来展望：前端开发的无限可能"><a href="#未来展望：前端开发的无限可能" class="headerlink" title="未来展望：前端开发的无限可能"></a>未来展望：前端开发的无限可能</h2><p>前端开发的世界总是充满了惊喜和创新。从刀耕火种的 JavaScript，到万物归一的 jQuery，再到百家争鸣的 Angular、React 和 Vue，每一阶段都有其独特的魅力。那么，未来的前端开发又会走向何方呢？让我们展开想象的翅膀，幽默风趣地展望一下未来的前端开发吧！</p><h4 id="微前端：大型项目的救星"><a href="#微前端：大型项目的救星" class="headerlink" title="微前端：大型项目的救星"></a>微前端：大型项目的救星</h4><p>微前端的概念就像是前端世界的“分而治之”，它将一个大型的单页应用分解为多个小型的前端应用，每个应用由不同的团队独立开发和部署。这不仅提高了开发效率，还解决了大型项目中的维护和扩展问题。</p><blockquote><p><strong>示意图：微前端架构</strong><br><img src="/../../img/frontendGuide/1-5.png" alt="微前端架构"><br><em>图 9：微前端架构</em></p></blockquote><p>想象一下，每个微前端应用就像是一个独立的小岛，开发者们就像是岛上的居民。他们只需要关心自己岛上的建设，而不需要操心其他岛上的事情。这种方式不仅让开发变得更加高效，还能有效地避免“交通堵塞”和“资源争夺”的问题。</p><h4 id="无服务器架构：前端开发的新大陆"><a href="#无服务器架构：前端开发的新大陆" class="headerlink" title="无服务器架构：前端开发的新大陆"></a>无服务器架构：前端开发的新大陆</h4><p>无服务器架构（Serverless）听起来就像是一个程序员的梦想：无需管理服务器，只需编写代码，剩下的交给云服务提供商。无服务器架构让前端开发者可以专注于前端逻辑，而不需要关心后端的运维问题。</p><blockquote><p><strong>示意图：无服务器架构</strong><br><img src="/../../img/frontendGuide/1-6.png" alt="无服务器架构"><br><em>图 10：无服务器架构</em></p></blockquote><p>无服务器架构的出现，让开发者们可以像在“前端乐园”中尽情玩耍。只需写几行代码，就能实现复杂的后端功能，比如处理用户请求、存储数据和发送通知。而所有这些，只需要在云端点几下鼠标，就能搞定。</p><h4 id="WebAssembly：前端性能的革命"><a href="#WebAssembly：前端性能的革命" class="headerlink" title="WebAssembly：前端性能的革命"></a>WebAssembly：前端性能的革命</h4><p>WebAssembly（Wasm）是一种新的二进制指令格式，可以在浏览器中高效运行。它允许开发者使用包括 C++、Rust 等多种语言编写代码，并将其编译为 Wasm，在浏览器中执行。WebAssembly 的出现，进一步提升了 Web 应用的性能和可能性。</p><blockquote><p><strong>示意图：WebAssembly 标志</strong><br><img src="https://upload.wikimedia.org/wikipedia/commons/1/1f/WebAssembly_Logo.svg" alt="WebAssembly 标志"><br><em>图 11：WebAssembly 标志</em></p></blockquote><p>WebAssembly 就像是前端开发的“超能战士”，它的出现让前端应用的性能达到了前所未有的高度。无论是复杂的 3D 游戏，还是高性能的计算任务，WebAssembly 都能轻松应对。想象一下，你的网页游戏可以像主机游戏一样流畅，这不禁让人热血沸腾。</p><h4 id="前后端交互的新方式"><a href="#前后端交互的新方式" class="headerlink" title="前后端交互的新方式"></a>前后端交互的新方式</h4><p>未来的前后端交互将更加高效和智能。GraphQL 的出现，让前端开发者可以灵活地获取数据，而不再受限于 REST API 的固定结构。前端开发者只需编写一个查询语句，就能获取所需的全部数据。</p><blockquote><p><strong>示意图：GraphQL 查询</strong><br><img src="/../../img/frontendGuide/1-7.png" alt="GraphQL 查询"><br><em>图 12：GraphQL 查询</em></p></blockquote><p>再比如，随着 WebSockets 的普及，实时通信将变得更加简单和高效。无论是实时聊天、在线协作还是实时数据更新，前后端的交互将更加顺畅，用户体验也将大大提升。</p><h4 id="AI-和前端开发"><a href="#AI-和前端开发" class="headerlink" title="AI 和前端开发"></a>AI 和前端开发</h4><p>未来，人工智能（AI）将深度融合到前端开发中。智能代码补全、自动化测试、个性化用户体验等，都是 AI 在前端开发中的潜在应用。想象一下，一个智能助手在你编写代码时自动为你补全代码，提醒你潜在的错误，甚至在你犯困时为你递上一杯咖啡。</p><blockquote><p><strong>示意图：AI 辅助编程</strong><br><img src="/../../img/frontendGuide/1-8.png" alt="AI 辅助编程"><br><em>图 13：AI 辅助编程</em></p></blockquote><h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>前端开发的历史如同一部波澜壮阔的史诗，从“刀耕火种”的 JavaScript 诞生，到“万物归一”的 jQuery 统治，再到“百家争鸣”的 Angular、React 和 Vue 的竞争，每一个阶段都见证了前端技术的飞速发展和革新。在这个过程中，前端开发者们不断探索、创新，推动了整个行业的进步。</p><p>展望未来，前端技术依旧充满无限可能。从微前端架构到无服务器架构，从 WebAssembly 的性能革命到智能前后端交互，再到 AI 在前端开发中的深度融合，每一项新技术都将为前端开发带来新的突破和机遇。</p><p>我们相信，前端开发的未来将更加精彩和充满挑战。无论是新手还是老手，每一位前端开发者都将继续在这条充满创造力和激情的道路上前行，共同书写前端开发的新篇章。让我们一起期待和迎接前端开发的美好未来，迎接新的挑战和机遇！</p><p>希望这段历史和展望能为你带来一些启发和乐趣，激励你在前端开发的世界中不断探索和成长。谢谢阅读！</p>]]></content>
    
    
    <categories>
      
      <category>前端开发手册</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发手册</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《前端开发手册》大纲</title>
    <link href="/2024/06/01/frontendGuide/outline/"/>
    <url>/2024/06/01/frontendGuide/outline/</url>
    
    <content type="html"><![CDATA[<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲"></a>大纲</h1><img src='data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBjb250ZW50U3R5bGVUeXBlPSJ0ZXh0L2NzcyIgaGVpZ2h0PSI5MTQycHgiIHByZXNlcnZlQXNwZWN0UmF0aW89Im5vbmUiIHN0eWxlPSJ3aWR0aDoxMTg1cHg7aGVpZ2h0OjkxNDJweDtiYWNrZ3JvdW5kOiNGRkZGRkY7IiB2ZXJzaW9uPSIxLjEiIHZpZXdCb3g9IjAgMCAxMTg1IDkxNDIiIHdpZHRoPSIxMTg1cHgiIHpvb21BbmRQYW49Im1hZ25pZnkiPjxkZWZzLz48Zz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTAzLjk5OTYiIHg9IjEwIiB5PSI0NTUxLjg5ODQiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI4My45OTk2IiB4PSIyMCIgeT0iNDU3NC44OTM2Ij4mIzIxMDY5OyYjMzE0NzE7JiMyNDMyMDsmIzIxNDU3OyYjMjUxNjM7JiMyMDg3Njs8L3RleHQ+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9Ijg5Ljk5OTciIHg9IjE2My45OTk2IiB5PSI2MTEuMTE3MiIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjY5Ljk5OTciIHg9IjE3My45OTk2IiB5PSI2MzQuMTEyMyI+JiMyMTA2OTsmIzMxNDcxOyYjMjE0NTc7JiMyMzYzNzsmIzIxNDkwOzwvdGV4dD48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iNzUuOTk5OCIgeD0iMzAzLjk5OTMiIHk9Ijc2LjI5NjkiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI1NS45OTk4IiB4PSIzMTMuOTk5MyIgeT0iOTkuMjkyIj4mIzIwOTkyOyYjMzI3ODk7JiMyODc3OTsmIzMxMTgxOzwvdGV4dD48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMjAxLjkzOCIgeD0iNDI5Ljk5OTEiIHk9Ijc2LjI5NjkiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxODEuOTM4IiB4PSI0MzkuOTk5MSIgeT0iOTkuMjkyIj5qYXZhU2NyaXB0JiMzMDM0MDsmIzM2MjE1OyYjMjgzMDQ7JiMyMTY0NDsmIzI2MDg5OyYjMjYzOTk7JiMyMTQ1NzsmIzIzNjM3OzwvdGV4dD48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iNzMuMTgzNCIgeD0iNjgxLjkzNzEiIHk9IjIwIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNTMuMTgzNCIgeD0iNjkxLjkzNzEiIHk9IjQyLjk5NTEiPmpzJiMzMDM0MDsmIzM1ODA2OyYjMjk5ODM7PC90ZXh0PjxwYXRoIGQ9Ik02MzEuOTM3MSw5NC40NDUzIEw2NDEuOTM3MSw5NC40NDUzIEM2NTYuOTM3MSw5NC40NDUzIDY1Ni45MzcxLDM4LjE0ODQgNjcxLjkzNzEsMzguMTQ4NCBMNjgxLjkzNzEsMzguMTQ4NCAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxMzEuOTk5NSIgeD0iNjgxLjkzNzEiIHk9Ijc2LjI5NjkiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxMTEuOTk5NSIgeD0iNjkxLjkzNzEiIHk9Ijk5LjI5MiI+JiMyNjM2ODsmIzIxMDIxOyYjMzAzNDA7JiMyOTk5MjsmIzM2ODg0OyYjMjE2NDQ7JiMyMzYxNjsmIzM4NDgwOzwvdGV4dD48cGF0aCBkPSJNNjMxLjkzNzEsOTQuNDQ1MyBMNjQxLjkzNzEsOTQuNDQ1MyBDNjU2LjkzNzEsOTQuNDQ1MyA2NTYuOTM3MSw5NC40NDUzIDY3MS45MzcxLDk0LjQ0NTMgTDY4MS45MzcxLDk0LjQ0NTMgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTU5Ljk5OTQiIHg9IjY4MS45MzcxIiB5PSIxMzIuNTkzOCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjEzOS45OTk0IiB4PSI2OTEuOTM3MSIgeT0iMTU1LjU4ODkiPiYjMjYwODk7JiMyNjM5OTsmIzI3OTgzOyYjMzUyNzI7JiMyMjEyMDsmIzMwMzQwOyYjMjU5MDM7JiMyNTM0NTsmIzI0NzczOyYjMjA5MTc7PC90ZXh0PjxwYXRoIGQ9Ik02MzEuOTM3MSw5NC40NDUzIEw2NDEuOTM3MSw5NC40NDUzIEM2NTYuOTM3MSw5NC40NDUzIDY1Ni45MzcxLDE1MC43NDIyIDY3MS45MzcxLDE1MC43NDIyIEw2ODEuOTM3MSwxNTAuNzQyMiAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik0zNzkuOTk5MSw5NC40NDUzIEwzODkuOTk5MSw5NC40NDUzIEM0MDQuOTk5MSw5NC40NDUzIDQwNC45OTkxLDk0LjQ0NTMgNDE5Ljk5OTEsOTQuNDQ1MyBMNDI5Ljk5OTEsOTQuNDQ1MyAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik0yNTMuOTk5Myw2MjkuMjY1NiBMMjYzLjk5OTMsNjI5LjI2NTYgQzI3OC45OTkzLDYyOS4yNjU2IDI3OC45OTkzLDk0LjQ0NTMgMjkzLjk5OTMsOTQuNDQ1MyBMMzAzLjk5OTMsOTQuNDQ1MyAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSI3NS45OTk4IiB4PSIzMDMuOTk5MyIgeT0iMjczLjMzNTkiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI1NS45OTk4IiB4PSIzMTMuOTk5MyIgeT0iMjk2LjMzMTEiPiYjMTk5NzU7JiMyOTI4OTsmIzI0NDAyOyYjMTk5Njg7PC90ZXh0PjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxMTIuODg2NSIgeD0iNDI5Ljk5OTEiIHk9IjI3My4zMzU5Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTIuODg2NSIgeD0iNDM5Ljk5OTEiIHk9IjI5Ni4zMzExIj5qUXVlcnkgJiMzMDM0MDsmIzIzODM1OyYjMzYyMTU7PC90ZXh0PjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxMzYuNDM2MiIgeD0iNTkyLjg4NTYiIHk9IjE4OC44OTA2Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTE2LjQzNjIiIHg9IjYwMi44ODU2IiB5PSIyMTEuODg1NyI+alF1ZXJ5JiMzMDM0MDsmIzM1ODA2OyYjMjk5ODM7JiMzMjk3MjsmIzI2MjIzOzwvdGV4dD48cGF0aCBkPSJNNTQyLjg4NTYsMjkxLjQ4NDQgTDU1Mi44ODU2LDI5MS40ODQ0IEM1NjcuODg1NiwyOTEuNDg0NCA1NjcuODg1NiwyMDcuMDM5MSA1ODIuODg1NiwyMDcuMDM5MSBMNTkyLjg4NTYsMjA3LjAzOTEgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTQwLjg4NjQiIHg9IjU5Mi44ODU2IiB5PSIyNDUuMTg3NSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjEyMC44ODY0IiB4PSI2MDIuODg1NiIgeT0iMjY4LjE4MjYiPmpRdWVyeSAmIzMwMzQwOyYjMjY2ODA7JiMyNDUxNTsmIzIxMTUxOyYjMzMwMjE7PC90ZXh0PjxwYXRoIGQ9Ik01NDIuODg1NiwyOTEuNDg0NCBMNTUyLjg4NTYsMjkxLjQ4NDQgQzU2Ny44ODU2LDI5MS40ODQ0IDU2Ny44ODU2LDI2My4zMzU5IDU4Mi44ODU2LDI2My4zMzU5IEw1OTIuODg1NiwyNjMuMzM1OSAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxNTQuODg2NCIgeD0iNTkyLjg4NTYiIHk9IjMwMS40ODQ0Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTM0Ljg4NjQiIHg9IjYwMi44ODU2IiB5PSIzMjQuNDc5NSI+alF1ZXJ5ICYjMzAzNDA7JiMyMDI0ODsmIzIxMTgzOyYjMjE2NDQ7JiMyNDQzMzsmIzIxNzA5OzwvdGV4dD48cGF0aCBkPSJNNTQyLjg4NTYsMjkxLjQ4NDQgTDU1Mi44ODU2LDI5MS40ODQ0IEM1NjcuODg1NiwyOTEuNDg0NCA1NjcuODg1NiwzMTkuNjMyOCA1ODIuODg1NiwzMTkuNjMyOCBMNTkyLjg4NTYsMzE5LjYzMjggIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTk2Ljg4NjIiIHg9IjU5Mi44ODU2IiB5PSIzNTcuNzgxMyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjE3Ni44ODYyIiB4PSI2MDIuODg1NiIgeT0iMzgwLjc3NjQiPmpRdWVyeSAmIzMwMzQwOyYjMzQ5Mjg7JiMzMzg1MzsmIzIxNjQ0OyYjMjk2MTY7JiMyMDE5NTsmIzI2MzY3OyYjMjAxOTU7JiMyMTY5Nzs8L3RleHQ+PHBhdGggZD0iTTU0Mi44ODU2LDI5MS40ODQ0IEw1NTIuODg1NiwyOTEuNDg0NCBDNTY3Ljg4NTYsMjkxLjQ4NDQgNTY3Ljg4NTYsMzc1LjkyOTcgNTgyLjg4NTYsMzc1LjkyOTcgTDU5Mi44ODU2LDM3NS45Mjk3ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTM3OS45OTkxLDI5MS40ODQ0IEwzODkuOTk5MSwyOTEuNDg0NCBDNDA0Ljk5OTEsMjkxLjQ4NDQgNDA0Ljk5OTEsMjkxLjQ4NDQgNDE5Ljk5OTEsMjkxLjQ4NDQgTDQyOS45OTkxLDI5MS40ODQ0ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTI1My45OTkzLDYyOS4yNjU2IEwyNjMuOTk5Myw2MjkuMjY1NiBDMjc4Ljk5OTMsNjI5LjI2NTYgMjc4Ljk5OTMsMjkxLjQ4NDQgMjkzLjk5OTMsMjkxLjQ4NDQgTDMwMy45OTkzLDI5MS40ODQ0ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9Ijc1Ljk5OTgiIHg9IjMwMy45OTkzIiB5PSI2MzkuMjY1NiIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjU1Ljk5OTgiIHg9IjMxMy45OTkzIiB5PSI2NjIuMjYwNyI+JiMzMDMzNDsmIzIzNDc4OyYjMjAxMDU7JiM0MDQ4Mzs8L3RleHQ+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjIxMy4yMzgiIHg9IjQyOS45OTkxIiB5PSI2MzkuMjY1NiIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjE5My4yMzgiIHg9IjQzOS45OTkxIiB5PSI2NjIuMjYwNyI+QW5ndWxhci5qcyYjMTIyODk7UmVhY3QmIzEyMjg5O1Z1ZSYjMjE0NTc7JiMyMzYzNzs8L3RleHQ+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjkwLjA2ODQiIHg9IjY5My4yMzcxIiB5PSI0NzAuMzc1Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNzAuMDY4NCIgeD0iNzAzLjIzNzEiIHk9IjQ5My4zNzAxIj5Bbmd1bGFyLmpzPC90ZXh0PjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSI3NS45OTk4IiB4PSI4MzMuMzA1NSIgeT0iNDE0LjA3ODEiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI1NS45OTk4IiB4PSI4NDMuMzA1NSIgeT0iNDM3LjA3MzIiPiYjMjY2ODA7JiMyNDUxNTsmIzI3MDEwOyYjMjQ1NjU7PC90ZXh0PjxwYXRoIGQ9Ik03ODMuMzA1NSw0ODguNTIzNCBMNzkzLjMwNTUsNDg4LjUyMzQgQzgwOC4zMDU1LDQ4OC41MjM0IDgwOC4zMDU1LDQzMi4yMjY2IDgyMy4zMDU1LDQzMi4yMjY2IEw4MzMuMzA1NSw0MzIuMjI2NiAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSI3NS45OTk4IiB4PSI4MzMuMzA1NSIgeT0iNDcwLjM3NSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjU1Ljk5OTgiIHg9Ijg0My4zMDU1IiB5PSI0OTMuMzcwMSI+JiMyOTk4MzsmIzI0NTc3OyYjMzE5OTU7JiMzMjQ3OTs8L3RleHQ+PHBhdGggZD0iTTc4My4zMDU1LDQ4OC41MjM0IEw3OTMuMzA1NSw0ODguNTIzNCBDODA4LjMwNTUsNDg4LjUyMzQgODA4LjMwNTUsNDg4LjUyMzQgODIzLjMwNTUsNDg4LjUyMzQgTDgzMy4zMDU1LDQ4OC41MjM0ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjEwMy45OTk2IiB4PSI4MzMuMzA1NSIgeT0iNTI2LjY3MTkiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI4My45OTk2IiB4PSI4NDMuMzA1NSIgeT0iNTQ5LjY2NyI+JiMyMzQ1NDsmIzM4NDY5OyYjMjQyMTI7JiMyOTk5MjsmIzI2Njk2OyYjMjAzNjM7PC90ZXh0PjxwYXRoIGQ9Ik03ODMuMzA1NSw0ODguNTIzNCBMNzkzLjMwNTUsNDg4LjUyMzQgQzgwOC4zMDU1LDQ4OC41MjM0IDgwOC4zMDU1LDU0NC44MjAzIDgyMy4zMDU1LDU0NC44MjAzIEw4MzMuMzA1NSw1NDQuODIwMyAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik02NDMuMjM3MSw2NTcuNDE0MSBMNjUzLjIzNzEsNjU3LjQxNDEgQzY2OC4yMzcxLDY1Ny40MTQxIDY2OC4yMzcxLDQ4OC41MjM0IDY4My4yMzcxLDQ4OC41MjM0IEw2OTMuMjM3MSw0ODguNTIzNCAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxOTUuMjcyOSIgeD0iNjkzLjIzNzEiIHk9IjYzOS4yNjU2Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTc1LjI3MjkiIHg9IjcwMy4yMzcxIiB5PSI2NjIuMjYwNyI+UmVhY3Q6ICYjMzI0NTI7JiMyMDIxNDsmIzIxMjcwOyYjMjE2NDQ7JiMyMTMzMzsmIzIxNTIxOyYjMjU5Njg7JiMyNTQ1NDsmIzI3OTY5OzwvdGV4dD48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iNzUuOTk5OCIgeD0iOTM4LjUxIiB5PSI1ODIuOTY4OCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjU1Ljk5OTgiIHg9Ijk0OC41MSIgeT0iNjA1Ljk2MzkiPiYjMjY2ODA7JiMyNDUxNTsmIzI3MDEwOyYjMjQ1NjU7PC90ZXh0PjxwYXRoIGQ9Ik04ODguNTEsNjU3LjQxNDEgTDg5OC41MSw2NTcuNDE0MSBDOTEzLjUxLDY1Ny40MTQxIDkxMy41MSw2MDEuMTE3MiA5MjguNTEsNjAxLjExNzIgTDkzOC41MSw2MDEuMTE3MiAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSI3NS45OTk4IiB4PSI5MzguNTEiIHk9IjYzOS4yNjU2Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNTUuOTk5OCIgeD0iOTQ4LjUxIiB5PSI2NjIuMjYwNyI+JiMyOTk4MzsmIzI0NTc3OyYjMzE5OTU7JiMzMjQ3OTs8L3RleHQ+PHBhdGggZD0iTTg4OC41MSw2NTcuNDE0MSBMODk4LjUxLDY1Ny40MTQxIEM5MTMuNTEsNjU3LjQxNDEgOTEzLjUxLDY1Ny40MTQxIDkyOC41MSw2NTcuNDE0MSBMOTM4LjUxLDY1Ny40MTQxICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjEwMy45OTk2IiB4PSI5MzguNTEiIHk9IjY5NS41NjI1Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iODMuOTk5NiIgeD0iOTQ4LjUxIiB5PSI3MTguNTU3NiI+JiMyMzQ1NDsmIzM4NDY5OyYjMjQyMTI7JiMyOTk5MjsmIzI2Njk2OyYjMjAzNjM7PC90ZXh0PjxwYXRoIGQ9Ik04ODguNTEsNjU3LjQxNDEgTDg5OC41MSw2NTcuNDE0MSBDOTEzLjUxLDY1Ny40MTQxIDkxMy41MSw3MTMuNzEwOSA5MjguNTEsNzEzLjcxMDkgTDkzOC41MSw3MTMuNzEwOSAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik02NDMuMjM3MSw2NTcuNDE0MSBMNjUzLjIzNzEsNjU3LjQxNDEgQzY2OC4yMzcxLDY1Ny40MTQxIDY2OC4yMzcxLDY1Ny40MTQxIDY4My4yMzcxLDY1Ny40MTQxIEw2OTMuMjM3MSw2NTcuNDE0MSAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxMzEuMDYzMSIgeD0iNjkzLjIzNzEiIHk9IjgwOC4xNTYzIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTExLjA2MzEiIHg9IjcwMy4yMzcxIiB5PSI4MzEuMTUxNCI+VnVlJiM2NTMwNjsmIzI4MTc2OyYjMzY4Mjc7JiMyNDMzNTsmIzI2Njk0OyYjMjY1NTA7PC90ZXh0PjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSI3NS45OTk4IiB4PSI4NzQuMzAwMiIgeT0iNzUxLjg1OTQiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI1NS45OTk4IiB4PSI4ODQuMzAwMiIgeT0iNzc0Ljg1NDUiPiYjMjY2ODA7JiMyNDUxNTsmIzI3MDEwOyYjMjQ1NjU7PC90ZXh0PjxwYXRoIGQ9Ik04MjQuMzAwMiw4MjYuMzA0NyBMODM0LjMwMDIsODI2LjMwNDcgQzg0OS4zMDAyLDgyNi4zMDQ3IDg0OS4zMDAyLDc3MC4wMDc4IDg2NC4zMDAyLDc3MC4wMDc4IEw4NzQuMzAwMiw3NzAuMDA3OCAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSI3NS45OTk4IiB4PSI4NzQuMzAwMiIgeT0iODA4LjE1NjMiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI1NS45OTk4IiB4PSI4ODQuMzAwMiIgeT0iODMxLjE1MTQiPiYjMjk5ODM7JiMyNDU3NzsmIzMxOTk1OyYjMzI0Nzk7PC90ZXh0PjxwYXRoIGQ9Ik04MjQuMzAwMiw4MjYuMzA0NyBMODM0LjMwMDIsODI2LjMwNDcgQzg0OS4zMDAyLDgyNi4zMDQ3IDg0OS4zMDAyLDgyNi4zMDQ3IDg2NC4zMDAyLDgyNi4zMDQ3IEw4NzQuMzAwMiw4MjYuMzA0NyAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxMDMuOTk5NiIgeD0iODc0LjMwMDIiIHk9Ijg2NC40NTMxIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iODMuOTk5NiIgeD0iODg0LjMwMDIiIHk9Ijg4Ny40NDgyIj4mIzIzNDU0OyYjMzg0Njk7JiMyNDIxMjsmIzI5OTkyOyYjMjY2OTY7JiMyMDM2Mzs8L3RleHQ+PHBhdGggZD0iTTgyNC4zMDAyLDgyNi4zMDQ3IEw4MzQuMzAwMiw4MjYuMzA0NyBDODQ5LjMwMDIsODI2LjMwNDcgODQ5LjMwMDIsODgyLjYwMTYgODY0LjMwMDIsODgyLjYwMTYgTDg3NC4zMDAyLDg4Mi42MDE2ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTY0My4yMzcxLDY1Ny40MTQxIEw2NTMuMjM3MSw2NTcuNDE0MSBDNjY4LjIzNzEsNjU3LjQxNDEgNjY4LjIzNzEsODI2LjMwNDcgNjgzLjIzNzEsODI2LjMwNDcgTDY5My4yMzcxLDgyNi4zMDQ3ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTM3OS45OTkxLDY1Ny40MTQxIEwzODkuOTk5MSw2NTcuNDE0MSBDNDA0Ljk5OTEsNjU3LjQxNDEgNDA0Ljk5OTEsNjU3LjQxNDEgNDE5Ljk5OTEsNjU3LjQxNDEgTDQyOS45OTkxLDY1Ny40MTQxICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTI1My45OTkzLDYyOS4yNjU2IEwyNjMuOTk5Myw2MjkuMjY1NiBDMjc4Ljk5OTMsNjI5LjI2NTYgMjc4Ljk5OTMsNjU3LjQxNDEgMjkzLjk5OTMsNjU3LjQxNDEgTDMwMy45OTkzLDY1Ny40MTQxICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9Ijc1Ljk5OTgiIHg9IjMwMy45OTkzIiB5PSIxMDYxLjQ5MjIiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI1NS45OTk4IiB4PSIzMTMuOTk5MyIgeT0iMTA4NC40ODczIj4mIzI2NDEwOyYjMjY0Njk7JiMyMzYzNzsmIzI2Mzk1OzwvdGV4dD48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iNjEuOTk5OCIgeD0iNDI5Ljk5OTEiIHk9Ijk0OC44OTg0Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNDEuOTk5OCIgeD0iNDM5Ljk5OTEiIHk9Ijk3MS44OTM2Ij4mIzI0NDk0OyYjMjEwNjk7JiMzMTQ3MTs8L3RleHQ+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjkxLjI1NzgiIHg9IjU0MS45OTg5IiB5PSI5MjAuNzUiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI3MS4yNTc4IiB4PSI1NTEuOTk4OSIgeT0iOTQzLjc0NTEiPnNpbmdsZS1zcGE8L3RleHQ+PHBhdGggZD0iTTQ5MS45OTg5LDk2Ny4wNDY5IEw1MDEuOTk4OSw5NjcuMDQ2OSBDNTE2Ljk5ODksOTY3LjA0NjkgNTE2Ljk5ODksOTM4Ljg5ODQgNTMxLjk5ODksOTM4Ljg5ODQgTDU0MS45OTg5LDkzOC44OTg0ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9Ijg5LjkwNDMiIHg9IjU0MS45OTg5IiB5PSI5NzcuMDQ2OSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjY5LjkwNDMiIHg9IjU1MS45OTg5IiB5PSIxMDAwLjA0MiI+TW9ub3JlcG88L3RleHQ+PHBhdGggZD0iTTQ5MS45OTg5LDk2Ny4wNDY5IEw1MDEuOTk4OSw5NjcuMDQ2OSBDNTE2Ljk5ODksOTY3LjA0NjkgNTE2Ljk5ODksOTk1LjE5NTMgNTMxLjk5ODksOTk1LjE5NTMgTDU0MS45OTg5LDk5NS4xOTUzICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTM3OS45OTkxLDEwNzkuNjQwNiBMMzg5Ljk5OTEsMTA3OS42NDA2IEM0MDQuOTk5MSwxMDc5LjY0MDYgNDA0Ljk5OTEsOTY3LjA0NjkgNDE5Ljk5OTEsOTY3LjA0NjkgTDQyOS45OTkxLDk2Ny4wNDY5ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjkzLjAwMSIgeD0iNDI5Ljk5OTEiIHk9IjEwMzMuMzQzOCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjczLjAwMSIgeD0iNDM5Ljk5OTEiIHk9IjEwNTYuMzM4OSI+U2VydmVybGVzczwvdGV4dD48cGF0aCBkPSJNMzc5Ljk5OTEsMTA3OS42NDA2IEwzODkuOTk5MSwxMDc5LjY0MDYgQzQwNC45OTkxLDEwNzkuNjQwNiA0MDQuOTk5MSwxMDUxLjQ5MjIgNDE5Ljk5OTEsMTA1MS40OTIyIEw0MjkuOTk5MSwxMDUxLjQ5MjIgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTE4LjgyMDMiIHg9IjQyOS45OTkxIiB5PSIxMDg5LjY0MDYiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI5OC44MjAzIiB4PSI0MzkuOTk5MSIgeT0iMTExMi42MzU3Ij5XZWJBc3NlbWJseTwvdGV4dD48cGF0aCBkPSJNMzc5Ljk5OTEsMTA3OS42NDA2IEwzODkuOTk5MSwxMDc5LjY0MDYgQzQwNC45OTkxLDEwNzkuNjQwNiA0MDQuOTk5MSwxMTA3Ljc4OTEgNDE5Ljk5OTEsMTEwNy43ODkxIEw0MjkuOTk5MSwxMTA3Ljc4OTEgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iODEuNzYyNyIgeD0iNDI5Ljk5OTEiIHk9IjExNDUuOTM3NSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjYxLjc2MjciIHg9IjQzOS45OTkxIiB5PSIxMTY4LjkzMjYiPkdyYXBoUUw8L3RleHQ+PHBhdGggZD0iTTM3OS45OTkxLDEwNzkuNjQwNiBMMzg5Ljk5OTEsMTA3OS42NDA2IEM0MDQuOTk5MSwxMDc5LjY0MDYgNDA0Ljk5OTEsMTE2NC4wODU5IDQxOS45OTkxLDExNjQuMDg1OSBMNDI5Ljk5OTEsMTE2NC4wODU5ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjEwMy43MDU3IiB4PSI0MjkuOTk5MSIgeT0iMTIwMi4yMzQ0Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iODMuNzA1NyIgeD0iNDM5Ljk5OTEiIHk9IjEyMjUuMjI5NSI+QUkmIzIxNjQ0OyYjMjEwNjk7JiMzMTQ3MTsmIzI0MzIwOyYjMjE0NTc7PC90ZXh0PjxwYXRoIGQ9Ik0zNzkuOTk5MSwxMDc5LjY0MDYgTDM4OS45OTkxLDEwNzkuNjQwNiBDNDA0Ljk5OTEsMTA3OS42NDA2IDQwNC45OTkxLDEyMjAuMzgyOCA0MTkuOTk5MSwxMjIwLjM4MjggTDQyOS45OTkxLDEyMjAuMzgyOCAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik0yNTMuOTk5Myw2MjkuMjY1NiBMMjYzLjk5OTMsNjI5LjI2NTYgQzI3OC45OTkzLDYyOS4yNjU2IDI3OC45OTkzLDEwNzkuNjQwNiAyOTMuOTk5MywxMDc5LjY0MDYgTDMwMy45OTkzLDEwNzkuNjQwNiAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik0xMTMuOTk5Niw0NTcwLjA0NjkgTDEyMy45OTk2LDQ1NzAuMDQ2OSBDMTM4Ljk5OTYsNDU3MC4wNDY5IDEzOC45OTk2LDYyOS4yNjU2IDE1My45OTk2LDYyOS4yNjU2IEwxNjMuOTk5Niw2MjkuMjY1NiAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSI3NS45OTk4IiB4PSIxNjMuOTk5NiIgeT0iMjA3NC44MzU5Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNTUuOTk5OCIgeD0iMTczLjk5OTYiIHk9IjIwOTcuODMxMSI+JiMyOTYxNTsmIzIyNjU5OyYjMjAzODE7JiMzNjE4Mjs8L3RleHQ+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjcyLjE3MTkiIHg9IjI4OS45OTk0IiB5PSIxMzk5LjI3MzQiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI1Mi4xNzE5IiB4PSIyOTkuOTk5NCIgeT0iMTQyMi4yNjg2Ij5Ob2RlLmpzPC90ZXh0PjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSI3NS45OTk4IiB4PSI0MTIuMTcxMyIgeT0iMTM0Mi45NzY2Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNTUuOTk5OCIgeD0iNDIyLjE3MTMiIHk9IjEzNjUuOTcxNyI+JiMyMzQzMzsmIzM1MDEzOyYjMjYwNDE7JiMyNzg2MTs8L3RleHQ+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9Ijg5Ljk5OTciIHg9IjUzOC4xNzEiIHk9IjEyODYuNjc5NyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjY5Ljk5OTciIHg9IjU0OC4xNzEiIHk9IjEzMDkuNjc0OCI+JiMxOTk3OTsmIzM2NzMzOyYjMTk5ODI7JiMyMzQzMzsmIzM1MDEzOzwvdGV4dD48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iODAuNDA5MiIgeD0iNjc4LjE3MDciIHk9IjEyNTguNTMxMyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjYwLjQwOTIiIHg9IjY4OC4xNzA3IiB5PSIxMjgxLjUyNjQiPndpbmRvd3M8L3RleHQ+PHBhdGggZD0iTTYyOC4xNzA3LDEzMDQuODI4MSBMNjM4LjE3MDcsMTMwNC44MjgxIEM2NTMuMTcwNywxMzA0LjgyODEgNjUzLjE3MDcsMTI3Ni42Nzk3IDY2OC4xNzA3LDEyNzYuNjc5NyBMNjc4LjE3MDcsMTI3Ni42Nzk3ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjY5LjgyMDMiIHg9IjY3OC4xNzA3IiB5PSIxMzE0LjgyODEiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI0OS44MjAzIiB4PSI2ODguMTcwNyIgeT0iMTMzNy44MjMyIj5tYWNPUzwvdGV4dD48cGF0aCBkPSJNNjI4LjE3MDcsMTMwNC44MjgxIEw2MzguMTcwNywxMzA0LjgyODEgQzY1My4xNzA3LDEzMDQuODI4MSA2NTMuMTcwNywxMzMyLjk3NjYgNjY4LjE3MDcsMTMzMi45NzY2IEw2NzguMTcwNywxMzMyLjk3NjYgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNNDg4LjE3MSwxMzYxLjEyNSBMNDk4LjE3MSwxMzYxLjEyNSBDNTEzLjE3MSwxMzYxLjEyNSA1MTMuMTcxLDEzMDQuODI4MSA1MjguMTcxLDEzMDQuODI4MSBMNTM4LjE3MSwxMzA0LjgyODEgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iNzUuOTk5OCIgeD0iNTM4LjE3MSIgeT0iMTM5OS4yNzM0Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNTUuOTk5OCIgeD0iNTQ4LjE3MSIgeT0iMTQyMi4yNjg2Ij4mIzM5NTY0OyYjMzU3Nzc7JiMyMzQzMzsmIzM1MDEzOzwvdGV4dD48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iNzIuNzI1NiIgeD0iNjY0LjE3MDgiIHk9IjEzNzEuMTI1Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNTIuNzI1NiIgeD0iNjc0LjE3MDgiIHk9IjEzOTQuMTIwMSI+bm9kZSAtdjwvdGV4dD48cGF0aCBkPSJNNjE0LjE3MDgsMTQxNy40MjE5IEw2MjQuMTcwOCwxNDE3LjQyMTkgQzYzOS4xNzA4LDE0MTcuNDIxOSA2MzkuMTcwOCwxMzg5LjI3MzQgNjU0LjE3MDgsMTM4OS4yNzM0IEw2NjQuMTcwOCwxMzg5LjI3MzQgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iNjkuMTg0NiIgeD0iNjY0LjE3MDgiIHk9IjE0MjcuNDIxOSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjQ5LjE4NDYiIHg9IjY3NC4xNzA4IiB5PSIxNDUwLjQxNyI+bnBtIC12PC90ZXh0PjxwYXRoIGQ9Ik02MTQuMTcwOCwxNDE3LjQyMTkgTDYyNC4xNzA4LDE0MTcuNDIxOSBDNjM5LjE3MDgsMTQxNy40MjE5IDYzOS4xNzA4LDE0NDUuNTcwMyA2NTQuMTcwOCwxNDQ1LjU3MDMgTDY2NC4xNzA4LDE0NDUuNTcwMyAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik00ODguMTcxLDEzNjEuMTI1IEw0OTguMTcxLDEzNjEuMTI1IEM1MTMuMTcxLDEzNjEuMTI1IDUxMy4xNzEsMTQxNy40MjE5IDUyOC4xNzEsMTQxNy40MjE5IEw1MzguMTcxLDE0MTcuNDIxOSAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik0zNjIuMTcxMywxNDE3LjQyMTkgTDM3Mi4xNzEzLDE0MTcuNDIxOSBDMzg3LjE3MTMsMTQxNy40MjE5IDM4Ny4xNzEzLDEzNjEuMTI1IDQwMi4xNzEzLDEzNjEuMTI1IEw0MTIuMTcxMywxMzYxLjEyNSAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSI3NS45OTk4IiB4PSI0MTIuMTcxMyIgeT0iMTQ4My43MTg4Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNTUuOTk5OCIgeD0iNDIyLjE3MTMiIHk9IjE1MDYuNzEzOSI+JiMyOTI1NjsmIzI2NDEyOyYjMzE2NDk7JiMyOTcwMjs8L3RleHQ+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjEzOS4yNDU3IiB4PSI1MzguMTcxIiB5PSIxNDgzLjcxODgiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxMTkuMjQ1NyIgeD0iNTQ4LjE3MSIgeT0iMTUwNi43MTM5Ij5udm0gJiMzMDM0MDsmIzIzNDMzOyYjMzUwMTM7JiMyMTY0NDsmIzIwMzUxOyYjMjk5OTI7PC90ZXh0PjxwYXRoIGQ9Ik00ODguMTcxLDE1MDEuODY3MiBMNDk4LjE3MSwxNTAxLjg2NzIgQzUxMy4xNzEsMTUwMS44NjcyIDUxMy4xNzEsMTUwMS44NjcyIDUyOC4xNzEsMTUwMS44NjcyIEw1MzguMTcxLDE1MDEuODY3MiAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik0zNjIuMTcxMywxNDE3LjQyMTkgTDM3Mi4xNzEzLDE0MTcuNDIxOSBDMzg3LjE3MTMsMTQxNy40MjE5IDM4Ny4xNzEzLDE1MDEuODY3MiA0MDIuMTcxMywxNTAxLjg2NzIgTDQxMi4xNzEzLDE1MDEuODY3MiAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxMDMuOTk5NiIgeD0iNDEyLjE3MTMiIHk9IjE1NDAuMDE1NiIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjgzLjk5OTYiIHg9IjQyMi4xNzEzIiB5PSIxNTYzLjAxMDciPiYjMjk2MTU7JiMyMjY1OTsmIzIxNDY0OyYjMzczMjc7JiMzNzE5NzsmIzMyNjIyOzwvdGV4dD48cGF0aCBkPSJNMzYyLjE3MTMsMTQxNy40MjE5IEwzNzIuMTcxMywxNDE3LjQyMTkgQzM4Ny4xNzEzLDE0MTcuNDIxOSAzODcuMTcxMywxNTU4LjE2NDEgNDAyLjE3MTMsMTU1OC4xNjQxIEw0MTIuMTcxMywxNTU4LjE2NDEgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNMjM5Ljk5OTQsMjA5Mi45ODQ0IEwyNDkuOTk5NCwyMDkyLjk4NDQgQzI2NC45OTk0LDIwOTIuOTg0NCAyNjQuOTk5NCwxNDE3LjQyMTkgMjc5Ljk5OTQsMTQxNy40MjE5IEwyODkuOTk5NCwxNDE3LjQyMTkgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iNTEuMzk3NSIgeD0iMjg5Ljk5OTQiIHk9IjE2ODAuNzU3OCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjMxLjM5NzUiIHg9IjI5OS45OTk0IiB5PSIxNzAzLjc1MjkiPm5wbTwvdGV4dD48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iNTEuMzk3NSIgeD0iMzkxLjM5NjkiIHk9IjE1OTYuMzEyNSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjMxLjM5NzUiIHg9IjQwMS4zOTY5IiB5PSIxNjE5LjMwNzYiPm5wbTwvdGV4dD48cGF0aCBkPSJNMzQxLjM5NjksMTY5OC45MDYzIEwzNTEuMzk2OSwxNjk4LjkwNjMgQzM2Ni4zOTY5LDE2OTguOTA2MyAzNjYuMzk2OSwxNjE0LjQ2MDkgMzgxLjM5NjksMTYxNC40NjA5IEwzOTEuMzk2OSwxNjE0LjQ2MDkgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iNzUuOTk5OCIgeD0iMzkxLjM5NjkiIHk9IjE2NTIuNjA5NCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjU1Ljk5OTgiIHg9IjQwMS4zOTY5IiB5PSIxNjc1LjYwNDUiPiYjMjQxMjA7JiMyOTk5MjsmIzIxNjI5OyYjMjAxOTY7PC90ZXh0PjxwYXRoIGQ9Ik0zNDEuMzk2OSwxNjk4LjkwNjMgTDM1MS4zOTY5LDE2OTguOTA2MyBDMzY2LjM5NjksMTY5OC45MDYzIDM2Ni4zOTY5LDE2NzAuNzU3OCAzODEuMzk2OSwxNjcwLjc1NzggTDM5MS4zOTY5LDE2NzAuNzU3OCAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxMDIuMTU0MyIgeD0iMzkxLjM5NjkiIHk9IjE3MDguOTA2MyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjgyLjE1NDMiIHg9IjQwMS4zOTY5IiB5PSIxNzMxLjkwMTQiPm5wbSBzY3JpcHRzPC90ZXh0PjxwYXRoIGQ9Ik0zNDEuMzk2OSwxNjk4LjkwNjMgTDM1MS4zOTY5LDE2OTguOTA2MyBDMzY2LjM5NjksMTY5OC45MDYzIDM2Ni4zOTY5LDE3MjcuMDU0NyAzODEuMzk2OSwxNzI3LjA1NDcgTDM5MS4zOTY5LDE3MjcuMDU0NyAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxMDYuNDE5OCIgeD0iMzkxLjM5NjkiIHk9IjE3NjUuMjAzMSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9Ijg2LjQxOTgiIHg9IjQwMS4zOTY5IiB5PSIxNzg4LjE5ODIiPnJlZ2lzdHJ5ICYjMjA5OTk7JiMyNTQ0Mjs8L3RleHQ+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjEzNi43MTY0IiB4PSI1NDcuODE2NyIgeT0iMTc2NS4yMDMxIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTE2LjcxNjQiIHg9IjU1Ny44MTY3IiB5PSIxNzg4LjE5ODIiPm5ybSAmIzMwMzQwOyYjMjM0MzM7JiMzNTAxMzsmIzIxNjQ0OyYjMjAzNTE7JiMyOTk5Mjs8L3RleHQ+PHBhdGggZD0iTTQ5Ny44MTY3LDE3ODMuMzUxNiBMNTA3LjgxNjcsMTc4My4zNTE2IEM1MjIuODE2NywxNzgzLjM1MTYgNTIyLjgxNjcsMTc4My4zNTE2IDUzNy44MTY3LDE3ODMuMzUxNiBMNTQ3LjgxNjcsMTc4My4zNTE2ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTM0MS4zOTY5LDE2OTguOTA2MyBMMzUxLjM5NjksMTY5OC45MDYzIEMzNjYuMzk2OSwxNjk4LjkwNjMgMzY2LjM5NjksMTc4My4zNTE2IDM4MS4zOTY5LDE3ODMuMzUxNiBMMzkxLjM5NjksMTc4My4zNTE2ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTIzOS45OTk0LDIwOTIuOTg0NCBMMjQ5Ljk5OTQsMjA5Mi45ODQ0IEMyNjQuOTk5NCwyMDkyLjk4NDQgMjY0Ljk5OTQsMTY5OC45MDYzIDI3OS45OTk0LDE2OTguOTA2MyBMMjg5Ljk5OTQsMTY5OC45MDYzICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjExMi40MjE5IiB4PSIyODkuOTk5NCIgeT0iMjI3MS44NzUiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI5Mi40MjE5IiB4PSIyOTkuOTk5NCIgeT0iMjI5NC44NzAxIj5wYWNrYWdlLmpzb248L3RleHQ+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjEwMy45OTk2IiB4PSI0NTIuNDIxMyIgeT0iMjEwMi45ODQ0Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iODMuOTk5NiIgeD0iNDYyLjQyMTMiIHk9IjIxMjUuOTc5NSI+JiMyNTk5MTsmIzIwMjE0OyYjMzI0Njc7JiMyNjUwMDsmIzM1Mjk5OyYjMjY1MTI7PC90ZXh0PjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSI1OS43MDMxIiB4PSI2MDYuNDIwOSIgeT0iMTgyMS41Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMzkuNzAzMSIgeD0iNjE2LjQyMDkiIHk9IjE4NDQuNDk1MSI+bmFtZTwvdGV4dD48cGF0aCBkPSJNNTU2LjQyMDksMjEyMS4xMzI4IEw1NjYuNDIwOSwyMTIxLjEzMjggQzU4MS40MjA5LDIxMjEuMTMyOCA1ODEuNDIwOSwxODM5LjY0ODQgNTk2LjQyMDksMTgzOS42NDg0IEw2MDYuNDIwOSwxODM5LjY0ODQgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iNzEuMjc2NCIgeD0iNjA2LjQyMDkiIHk9IjE4NzcuNzk2OSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjUxLjI3NjQiIHg9IjYxNi40MjA5IiB5PSIxOTAwLjc5MiI+dmVyc2lvbjwvdGV4dD48cGF0aCBkPSJNNTU2LjQyMDksMjEyMS4xMzI4IEw1NjYuNDIwOSwyMTIxLjEzMjggQzU4MS40MjA5LDIxMjEuMTMyOCA1ODEuNDIwOSwxODk1Ljk0NTMgNTk2LjQyMDksMTg5NS45NDUzIEw2MDYuNDIwOSwxODk1Ljk0NTMgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iOTcuODQwOCIgeD0iNjA2LjQyMDkiIHk9IjE5MzQuMDkzOCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9Ijc3Ljg0MDgiIHg9IjYxNi40MjA5IiB5PSIxOTU3LjA4ODkiPmRlc2NyaXB0aW9uPC90ZXh0PjxwYXRoIGQ9Ik01NTYuNDIwOSwyMTIxLjEzMjggTDU2Ni40MjA5LDIxMjEuMTMyOCBDNTgxLjQyMDksMjEyMS4xMzI4IDU4MS40MjA5LDE5NTIuMjQyMiA1OTYuNDIwOSwxOTUyLjI0MjIgTDYwNi40MjA5LDE5NTIuMjQyMiAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSI1NC45Nzk1IiB4PSI2MDYuNDIwOSIgeT0iMTk5MC4zOTA2Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMzQuOTc5NSIgeD0iNjE2LjQyMDkiIHk9IjIwMTMuMzg1NyI+bWFpbjwvdGV4dD48cGF0aCBkPSJNNTU2LjQyMDksMjEyMS4xMzI4IEw1NjYuNDIwOSwyMTIxLjEzMjggQzU4MS40MjA5LDIxMjEuMTMyOCA1ODEuNDIwOSwyMDA4LjUzOTEgNTk2LjQyMDksMjAwOC41MzkxIEw2MDYuNDIwOSwyMDA4LjUzOTEgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iNjYuMzA2NiIgeD0iNjA2LjQyMDkiIHk9IjIwNDYuNjg3NSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjQ2LjMwNjYiIHg9IjYxNi40MjA5IiB5PSIyMDY5LjY4MjYiPnNjcmlwdHM8L3RleHQ+PHBhdGggZD0iTTU1Ni40MjA5LDIxMjEuMTMyOCBMNTY2LjQyMDksMjEyMS4xMzI4IEM1ODEuNDIwOSwyMTIxLjEzMjggNTgxLjQyMDksMjA2NC44MzU5IDU5Ni40MjA5LDIwNjQuODM1OSBMNjA2LjQyMDksMjA2NC44MzU5ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjExNy43NDAyIiB4PSI2MDYuNDIwOSIgeT0iMjEwMi45ODQ0Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTcuNzQwMiIgeD0iNjE2LjQyMDkiIHk9IjIxMjUuOTc5NSI+ZGVwZW5kZW5jaWVzPC90ZXh0PjxwYXRoIGQ9Ik01NTYuNDIwOSwyMTIxLjEzMjggTDU2Ni40MjA5LDIxMjEuMTMyOCBDNTgxLjQyMDksMjEyMS4xMzI4IDU4MS40MjA5LDIxMjEuMTMyOCA1OTYuNDIwOSwyMTIxLjEzMjggTDYwNi40MjA5LDIxMjEuMTMyOCAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxNDUuNDE4OSIgeD0iNjA2LjQyMDkiIHk9IjIxNTkuMjgxMyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjEyNS40MTg5IiB4PSI2MTYuNDIwOSIgeT0iMjE4Mi4yNzY0Ij5kZXZEZXBlbmRlbmNpZXM8L3RleHQ+PHBhdGggZD0iTTU1Ni40MjA5LDIxMjEuMTMyOCBMNTY2LjQyMDksMjEyMS4xMzI4IEM1ODEuNDIwOSwyMTIxLjEzMjggNTgxLjQyMDksMjE3Ny40Mjk3IDU5Ni40MjA5LDIxNzcuNDI5NyBMNjA2LjQyMDksMjE3Ny40Mjk3ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjkxLjEwMDYiIHg9IjYwNi40MjA5IiB5PSIyMjE1LjU3ODEiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI3MS4xMDA2IiB4PSI2MTYuNDIwOSIgeT0iMjIzOC41NzMyIj5yZXBvc2l0b3J5PC90ZXh0PjxwYXRoIGQ9Ik01NTYuNDIwOSwyMTIxLjEzMjggTDU2Ni40MjA5LDIxMjEuMTMyOCBDNTgxLjQyMDksMjEyMS4xMzI4IDU4MS40MjA5LDIyMzMuNzI2NiA1OTYuNDIwOSwyMjMzLjcyNjYgTDYwNi40MjA5LDIyMzMuNzI2NiAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSI4Ni45NTgiIHg9IjYwNi40MjA5IiB5PSIyMjcxLjg3NSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjY2Ljk1OCIgeD0iNjE2LjQyMDkiIHk9IjIyOTQuODcwMSI+a2V5d29yZHM8L3RleHQ+PHBhdGggZD0iTTU1Ni40MjA5LDIxMjEuMTMyOCBMNTY2LjQyMDksMjEyMS4xMzI4IEM1ODEuNDIwOSwyMTIxLjEzMjggNTgxLjQyMDksMjI5MC4wMjM0IDU5Ni40MjA5LDIyOTAuMDIzNCBMNjA2LjQyMDksMjI5MC4wMjM0ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjY2LjEzNTciIHg9IjYwNi40MjA5IiB5PSIyMzI4LjE3MTkiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI0Ni4xMzU3IiB4PSI2MTYuNDIwOSIgeT0iMjM1MS4xNjciPmF1dGhvcjwvdGV4dD48cGF0aCBkPSJNNTU2LjQyMDksMjEyMS4xMzI4IEw1NjYuNDIwOSwyMTIxLjEzMjggQzU4MS40MjA5LDIxMjEuMTMyOCA1ODEuNDIwOSwyMzQ2LjMyMDMgNTk2LjQyMDksMjM0Ni4zMjAzIEw2MDYuNDIwOSwyMzQ2LjMyMDMgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iNjguODcwMSIgeD0iNjA2LjQyMDkiIHk9IjIzODQuNDY4OCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjQ4Ljg3MDEiIHg9IjYxNi40MjA5IiB5PSIyNDA3LjQ2MzkiPmxpY2Vuc2U8L3RleHQ+PHBhdGggZD0iTTU1Ni40MjA5LDIxMjEuMTMyOCBMNTY2LjQyMDksMjEyMS4xMzI4IEM1ODEuNDIwOSwyMTIxLjEzMjggNTgxLjQyMDksMjQwMi42MTcyIDU5Ni40MjA5LDI0MDIuNjE3MiBMNjA2LjQyMDksMjQwMi42MTcyICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTQwMi40MjEzLDIyOTAuMDIzNCBMNDEyLjQyMTMsMjI5MC4wMjM0IEM0MjcuNDIxMywyMjkwLjAyMzQgNDI3LjQyMTMsMjEyMS4xMzI4IDQ0Mi40MjEzLDIxMjEuMTMyOCBMNDUyLjQyMTMsMjEyMS4xMzI4ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjEwMy45OTk2IiB4PSI0NTIuNDIxMyIgeT0iMjE1OS4yODEzIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iODMuOTk5NiIgeD0iNDYyLjQyMTMiIHk9IjIxODIuMjc2NCI+JiMyMTU1MTsmIzIxMTYwOyYjMjE2Mjk7JiMyMDE5NjsmIzM1ODE0OyYjMzUyOTk7PC90ZXh0PjxwYXRoIGQ9Ik00MDIuNDIxMywyMjkwLjAyMzQgTDQxMi40MjEzLDIyOTAuMDIzNCBDNDI3LjQyMTMsMjI5MC4wMjM0IDQyNy40MjEzLDIxNzcuNDI5NyA0NDIuNDIxMywyMTc3LjQyOTcgTDQ1Mi40MjEzLDIxNzcuNDI5NyAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxMzEuOTk5NSIgeD0iNDUyLjQyMTMiIHk9IjI0NDAuNzY1NiIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjExMS45OTk1IiB4PSI0NjIuNDIxMyIgeT0iMjQ2My43NjA3Ij4mIzIwMzgxOyYjMzYxODI7JiMyOTI1NjsmIzI2NDEyOyYjMzE2NDk7JiMyOTcwMjsmIzMxNTc0OyYjMzAwNTM7PC90ZXh0PjxwYXRoIGQ9Ik00MDIuNDIxMywyMjkwLjAyMzQgTDQxMi40MjEzLDIyOTAuMDIzNCBDNDI3LjQyMTMsMjI5MC4wMjM0IDQyNy40MjEzLDI0NTguOTE0MSA0NDIuNDIxMywyNDU4LjkxNDEgTDQ1Mi40MjEzLDI0NTguOTE0MSAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxODcuOTk5MyIgeD0iNDUyLjQyMTMiIHk9IjI1NTMuMzU5NCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjE2Ny45OTkzIiB4PSI0NjIuNDIxMyIgeT0iMjU3Ni4zNTQ1Ij4mIzIyOTE0OyYjMjAzMDk7JiMyMzQzMzsmIzM1MDEzOyYjMjYwMzI7JiMzMDM0MDsmIzMxNTMyOyYjMTk5Nzc7JiMyNjA0MTsmIzIwMzgxOyYjMzYxODI7JiMyMTI1Mzs8L3RleHQ+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjExNy45OTk2IiB4PSI2OTAuNDIwNSIgeT0iMjQ0MC43NjU2Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTcuOTk5NiIgeD0iNzAwLjQyMDUiIHk9IjI0NjMuNzYwNyI+JiMyMzQzMzsmIzM1MDEzOyYjMjEzMzM7JiMyMDAxMDsmIzIwMzgxOyYjMzYxODI7JiMyMTI1Mzs8L3RleHQ+PHBhdGggZD0iTTY0MC40MjA1LDI1NzEuNTA3OCBMNjUwLjQyMDUsMjU3MS41MDc4IEM2NjUuNDIwNSwyNTcxLjUwNzggNjY1LjQyMDUsMjQ1OC45MTQxIDY4MC40MjA1LDI0NTguOTE0MSBMNjkwLjQyMDUsMjQ1OC45MTQxICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjExNy45OTk2IiB4PSI2OTAuNDIwNSIgeT0iMjQ5Ny4wNjI1Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTcuOTk5NiIgeD0iNzAwLjQyMDUiIHk9IjI1MjAuMDU3NiI+JiMyMzQzMzsmIzM1MDEzOyYjMjI4MTA7JiMyMDAxMDsmIzIwMzgxOyYjMzYxODI7JiMyMTI1Mzs8L3RleHQ+PHBhdGggZD0iTTY0MC40MjA1LDI1NzEuNTA3OCBMNjUwLjQyMDUsMjU3MS41MDc4IEM2NjUuNDIwNSwyNTcxLjUwNzggNjY1LjQyMDUsMjUxNS4yMTA5IDY4MC40MjA1LDI1MTUuMjEwOSBMNjkwLjQyMDUsMjUxNS4yMTA5ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjE1OS45OTk0IiB4PSI2OTAuNDIwNSIgeT0iMjU1My4zNTk0Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTM5Ljk5OTQiIHg9IjcwMC40MjA1IiB5PSIyNTc2LjM1NDUiPiYjMjM0MzM7JiMzNTAxMzsmIzI5MzA1OyYjMjM0NTA7JiMyOTI1NjsmIzI2NDEyOyYjMzAzNDA7JiMyMDM4MTsmIzM2MTgyOyYjMjEyNTM7PC90ZXh0PjxwYXRoIGQ9Ik02NDAuNDIwNSwyNTcxLjUwNzggTDY1MC40MjA1LDI1NzEuNTA3OCBDNjY1LjQyMDUsMjU3MS41MDc4IDY2NS40MjA1LDI1NzEuNTA3OCA2ODAuNDIwNSwyNTcxLjUwNzggTDY5MC40MjA1LDI1NzEuNTA3OCAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxMTcuOTk5NiIgeD0iNjkwLjQyMDUiIHk9IjI2MDkuNjU2MyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9Ijk3Ljk5OTYiIHg9IjcwMC40MjA1IiB5PSIyNjMyLjY1MTQiPiYjMjA4NDA7JiMyMzYxNjsmIzIzNDMzOyYjMzUwMTM7JiMyMDM4MTsmIzM2MTgyOyYjMjEyNTM7PC90ZXh0PjxwYXRoIGQ9Ik02NDAuNDIwNSwyNTcxLjUwNzggTDY1MC40MjA1LDI1NzEuNTA3OCBDNjY1LjQyMDUsMjU3MS41MDc4IDY2NS40MjA1LDI2MjcuODA0NyA2ODAuNDIwNSwyNjI3LjgwNDcgTDY5MC40MjA1LDI2MjcuODA0NyAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxNDUuOTk5NSIgeD0iNjkwLjQyMDUiIHk9IjI2NjUuOTUzMSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjEyNS45OTk1IiB4PSI3MDAuNDIwNSIgeT0iMjY4OC45NDgyIj4mIzIzNDMzOyYjMzUwMTM7JiMyNDMyMDsmIzIxNDU3OyYjMjk2MTU7JiMyMjY1OTsmIzIwMzgxOyYjMzYxODI7JiMyMTI1Mzs8L3RleHQ+PHBhdGggZD0iTTY0MC40MjA1LDI1NzEuNTA3OCBMNjUwLjQyMDUsMjU3MS41MDc4IEM2NjUuNDIwNSwyNTcxLjUwNzggNjY1LjQyMDUsMjY4NC4xMDE2IDY4MC40MjA1LDI2ODQuMTAxNiBMNjkwLjQyMDUsMjY4NC4xMDE2ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTQwMi40MjEzLDIyOTAuMDIzNCBMNDEyLjQyMTMsMjI5MC4wMjM0IEM0MjcuNDIxMywyMjkwLjAyMzQgNDI3LjQyMTMsMjU3MS41MDc4IDQ0Mi40MjEzLDI1NzEuNTA3OCBMNDUyLjQyMTMsMjU3MS41MDc4ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjI0OC4xODMyIiB4PSI0NTIuNDIxMyIgeT0iMjcyMi4yNSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjIyOC4xODMyIiB4PSI0NjIuNDIxMyIgeT0iMjc0NS4yNDUxIj5wYWNrYWdlLWxvY2suanNvbiAmIzIyOTE0OyYjMjAzMDk7JiMyOTk4MzsmIzI1MTA0OyYjMjE0NTA7JiMyMDMxNjsmIzI5OTkyOzwvdGV4dD48cGF0aCBkPSJNNDAyLjQyMTMsMjI5MC4wMjM0IEw0MTIuNDIxMywyMjkwLjAyMzQgQzQyNy40MjEzLDIyOTAuMDIzNCA0MjcuNDIxMywyNzQwLjM5ODQgNDQyLjQyMTMsMjc0MC4zOTg0IEw0NTIuNDIxMywyNzQwLjM5ODQgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNMjM5Ljk5OTQsMjA5Mi45ODQ0IEwyNDkuOTk5NCwyMDkyLjk4NDQgQzI2NC45OTk0LDIwOTIuOTg0NCAyNjQuOTk5NCwyMjkwLjAyMzQgMjc5Ljk5OTQsMjI5MC4wMjM0IEwyODkuOTk5NCwyMjkwLjAyMzQgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iNDYuMjc3MyIgeD0iMjg5Ljk5OTQiIHk9IjI4MzQuODQzOCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjI2LjI3NzMiIHg9IjI5OS45OTk0IiB5PSIyODU3LjgzODkiPnZpdGU8L3RleHQ+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjEzNC43MjcyIiB4PSIzODYuMjc2NyIgeT0iMjc3OC41NDY5Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTE0LjcyNzIiIHg9IjM5Ni4yNzY3IiB5PSIyODAxLjU0MiI+dml0ZSAmIzMwMzQwOyYjMjkzMDU7JiMyODg1NzsmIzE5OTgyOyYjMjAyNDg7JiMyMTE4Mzs8L3RleHQ+PHBhdGggZD0iTTMzNi4yNzY3LDI4NTIuOTkyMiBMMzQ2LjI3NjcsMjg1Mi45OTIyIEMzNjEuMjc2NywyODUyLjk5MjIgMzYxLjI3NjcsMjc5Ni42OTUzIDM3Ni4yNzY3LDI3OTYuNjk1MyBMMzg2LjI3NjcsMjc5Ni42OTUzICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjEzNC43MjcyIiB4PSIzODYuMjc2NyIgeT0iMjgzNC44NDM4Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTE0LjcyNzIiIHg9IjM5Ni4yNzY3IiB5PSIyODU3LjgzODkiPnZpdGUgJiMzMDM0MDsmIzM5MDMzOyYjMzA0NDY7JiMyMTAyMTsmIzIyOTg3OyYjMjEyNzA7PC90ZXh0PjxwYXRoIGQ9Ik0zMzYuMjc2NywyODUyLjk5MjIgTDM0Ni4yNzY3LDI4NTIuOTkyMiBDMzYxLjI3NjcsMjg1Mi45OTIyIDM2MS4yNzY3LDI4NTIuOTkyMiAzNzYuMjc2NywyODUyLjk5MjIgTDM4Ni4yNzY3LDI4NTIuOTkyMiAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxMzQuNzI3MiIgeD0iMzg2LjI3NjciIHk9IjI4OTEuMTQwNiIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjExNC43MjcyIiB4PSIzOTYuMjc2NyIgeT0iMjkxNC4xMzU3Ij52aXRlICYjMzcxOTc7JiMzMjYyMjsmIzI1OTkxOyYjMjAyMTQ7JiMzNTgxNDsmIzM1Mjk5OzwvdGV4dD48cGF0aCBkPSJNMzM2LjI3NjcsMjg1Mi45OTIyIEwzNDYuMjc2NywyODUyLjk5MjIgQzM2MS4yNzY3LDI4NTIuOTkyMiAzNjEuMjc2NywyOTA5LjI4OTEgMzc2LjI3NjcsMjkwOS4yODkxIEwzODYuMjc2NywyOTA5LjI4OTEgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNMjM5Ljk5OTQsMjA5Mi45ODQ0IEwyNDkuOTk5NCwyMDkyLjk4NDQgQzI2NC45OTk0LDIwOTIuOTg0NCAyNjQuOTk5NCwyODUyLjk5MjIgMjc5Ljk5OTQsMjg1Mi45OTIyIEwyODkuOTk5NCwyODUyLjk5MjIgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNMTEzLjk5OTYsNDU3MC4wNDY5IEwxMjMuOTk5Niw0NTcwLjA0NjkgQzEzOC45OTk2LDQ1NzAuMDQ2OSAxMzguOTk5NiwyMDkyLjk4NDQgMTUzLjk5OTYsMjA5Mi45ODQ0IEwxNjMuOTk5NiwyMDkyLjk4NDQgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iNzUuOTk5OCIgeD0iMTYzLjk5OTYiIHk9IjQ2OTIuNjQwNiIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjU1Ljk5OTgiIHg9IjE3My45OTk2IiB5PSI0NzE1LjYzNTciPiYjMzU4MjE7JiMyNzg2MTsmIzIwMTcxOyYjMzI0NjE7PC90ZXh0PjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSI1MS44ODk2IiB4PSIyODkuOTk5NCIgeT0iMzE0NC40NzY2Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMzEuODg5NiIgeD0iMjk5Ljk5OTQiIHk9IjMxNjcuNDcxNyI+aHRtbDwvdGV4dD48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTI4Ljk1NzciIHg9IjM5MS44ODkiIHk9IjI5NDcuNDM3NSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjEwOC45NTc3IiB4PSI0MDEuODg5IiB5PSIyOTcwLjQzMjYiPkhUTUwmIzMwMzQwOyYjMjI1MjI7JiMyNjQxMjsmIzMyNDY3OyYjMjY1MDA7PC90ZXh0PjxwYXRoIGQ9Ik0zNDEuODg5LDMxNjIuNjI1IEwzNTEuODg5LDMxNjIuNjI1IEMzNjYuODg5LDMxNjIuNjI1IDM2Ni44ODksMjk2NS41ODU5IDM4MS44ODksMjk2NS41ODU5IEwzOTEuODg5LDI5NjUuNTg1OSAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSI3NS45OTk4IiB4PSIzOTEuODg5IiB5PSIzMDAzLjczNDQiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI1NS45OTk4IiB4PSI0MDEuODg5IiB5PSIzMDI2LjcyOTUiPiYjMjQxMjA7JiMyOTk5MjsmIzI2NjMxOyYjMzE2MTQ7PC90ZXh0PjxwYXRoIGQ9Ik0zNDEuODg5LDMxNjIuNjI1IEwzNTEuODg5LDMxNjIuNjI1IEMzNjYuODg5LDMxNjIuNjI1IDM2Ni44ODksMzAyMS44ODI4IDM4MS44ODksMzAyMS44ODI4IEwzOTEuODg5LDMwMjEuODgyOCAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSI3NS45OTk4IiB4PSIzOTEuODg5IiB5PSIzMDYwLjAzMTMiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI1NS45OTk4IiB4PSI0MDEuODg5IiB5PSIzMDgzLjAyNjQiPiYjMzQ5MjA7JiMyMTMzMzsmIzIwODAzOyYjMzIwMzI7PC90ZXh0PjxwYXRoIGQ9Ik0zNDEuODg5LDMxNjIuNjI1IEwzNTEuODg5LDMxNjIuNjI1IEMzNjYuODg5LDMxNjIuNjI1IDM2Ni44ODksMzA3OC4xNzk3IDM4MS44ODksMzA3OC4xNzk3IEwzOTEuODg5LDMwNzguMTc5NyAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxMzEuOTk5NSIgeD0iMzkxLjg4OSIgeT0iMzExNi4zMjgxIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTExLjk5OTUiIHg9IjQwMS44ODkiIHk9IjMxMzkuMzIzMiI+JiMzNTgyMTsmIzIwMDQxOyYjMjEyNzA7JiMyNjYzMTsmIzMxNjE0OyYjMzAzNDA7JiMyMDM1MTsmIzI5OTkyOzwvdGV4dD48cGF0aCBkPSJNMzQxLjg4OSwzMTYyLjYyNSBMMzUxLjg4OSwzMTYyLjYyNSBDMzY2Ljg4OSwzMTYyLjYyNSAzNjYuODg5LDMxMzQuNDc2NiAzODEuODg5LDMxMzQuNDc2NiBMMzkxLjg4OSwzMTM0LjQ3NjYgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTI4LjMxNTIiIHg9IjM5MS44ODkiIHk9IjMxNzIuNjI1Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTA4LjMxNTIiIHg9IjQwMS44ODkiIHk9IjMxOTUuNjIwMSI+SFRNTDUgJiMyNjAzMjsmIzMwMzQwOyYjMjkzMDU7JiMyNDYxNTs8L3RleHQ+PHBhdGggZD0iTTM0MS44ODksMzE2Mi42MjUgTDM1MS44ODksMzE2Mi42MjUgQzM2Ni44ODksMzE2Mi42MjUgMzY2Ljg4OSwzMTkwLjc3MzQgMzgxLjg4OSwzMTkwLjc3MzQgTDM5MS44ODksMzE5MC43NzM0ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9Ijc1Ljk5OTgiIHg9IjM5MS44ODkiIHk9IjMyODUuMjE4OCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjU1Ljk5OTgiIHg9IjQwMS44ODkiIHk9IjMzMDguMjEzOSI+JiMyNjQxMjsmIzIyMzIwOyYjMjMzODQ7JiMyMDY0ODs8L3RleHQ+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjEwNy4zOTc1IiB4PSI1MTcuODg4OCIgeT0iMzIyOC45MjE5Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iODcuMzk3NSIgeD0iNTI3Ljg4ODgiIHk9IjMyNTEuOTE3Ij5sb2NhbFN0b3JhZ2U8L3RleHQ+PHBhdGggZD0iTTQ2Ny44ODg4LDMzMDMuMzY3MiBMNDc3Ljg4ODgsMzMwMy4zNjcyIEM0OTIuODg4OCwzMzAzLjM2NzIgNDkyLjg4ODgsMzI0Ny4wNzAzIDUwNy44ODg4LDMyNDcuMDcwMyBMNTE3Ljg4ODgsMzI0Ny4wNzAzICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjEyNi41OTk2IiB4PSI1MTcuODg4OCIgeT0iMzI4NS4yMTg4Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTA2LjU5OTYiIHg9IjUyNy44ODg4IiB5PSIzMzA4LjIxMzkiPnNlc3Npb25TdG9yYWdlPC90ZXh0PjxwYXRoIGQ9Ik00NjcuODg4OCwzMzAzLjM2NzIgTDQ3Ny44ODg4LDMzMDMuMzY3MiBDNDkyLjg4ODgsMzMwMy4zNjcyIDQ5Mi44ODg4LDMzMDMuMzY3MiA1MDcuODg4OCwzMzAzLjM2NzIgTDUxNy44ODg4LDMzMDMuMzY3MiAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSI2NS40Mzg1IiB4PSI1MTcuODg4OCIgeT0iMzM0MS41MTU2Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNDUuNDM4NSIgeD0iNTI3Ljg4ODgiIHk9IjMzNjQuNTEwNyI+Y29va2llPC90ZXh0PjxwYXRoIGQ9Ik00NjcuODg4OCwzMzAzLjM2NzIgTDQ3Ny44ODg4LDMzMDMuMzY3MiBDNDkyLjg4ODgsMzMwMy4zNjcyIDQ5Mi44ODg4LDMzNTkuNjY0MSA1MDcuODg4OCwzMzU5LjY2NDEgTDUxNy44ODg4LDMzNTkuNjY0MSAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik0zNDEuODg5LDMxNjIuNjI1IEwzNTEuODg5LDMxNjIuNjI1IEMzNjYuODg5LDMxNjIuNjI1IDM2Ni44ODksMzMwMy4zNjcyIDM4MS44ODksMzMwMy4zNjcyIEwzOTEuODg5LDMzMDMuMzY3MiAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik0yMzkuOTk5NCw0NzEwLjc4OTEgTDI0OS45OTk0LDQ3MTAuNzg5MSBDMjY0Ljk5OTQsNDcxMC43ODkxIDI2NC45OTk0LDMxNjIuNjI1IDI3OS45OTk0LDMxNjIuNjI1IEwyODkuOTk5NCwzMTYyLjYyNSAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSI0Mi4yODUyIiB4PSIyODkuOTk5NCIgeT0iMzY3OS4yOTY5Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMjIuMjg1MiIgeD0iMjk5Ljk5OTQiIHk9IjM3MDIuMjkyIj5jc3M8L3RleHQ+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjExMi4yODQ5IiB4PSIzODIuMjg0NSIgeT0iMzM5Ny44MTI1Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTIuMjg0OSIgeD0iMzkyLjI4NDUiIHk9IjM0MjAuODA3NiI+Y3NzJiMzMDM0MDsmIzIyNTIyOyYjMjY0MTI7JiMzNTgyMTsmIzI3ODYxOzwvdGV4dD48cGF0aCBkPSJNMzMyLjI4NDUsMzY5Ny40NDUzIEwzNDIuMjg0NSwzNjk3LjQ0NTMgQzM1Ny4yODQ1LDM2OTcuNDQ1MyAzNTcuMjg0NSwzNDE1Ljk2MDkgMzcyLjI4NDUsMzQxNS45NjA5IEwzODIuMjg0NSwzNDE1Ljk2MDkgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTMxLjk5OTUiIHg9IjM4Mi4yODQ1IiB5PSIzNDU0LjEwOTQiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxMTEuOTk5NSIgeD0iMzkyLjI4NDUiIHk9IjM0NzcuMTA0NSI+JiMzNjg3MzsmIzI1MzIxOyYjMjIxMjA7JiMxMjI4OTsmIzIzNjQ2OyYjMjQ2MTU7JiMyMTY0NDsmIzIwNTQwOzwvdGV4dD48cGF0aCBkPSJNMzMyLjI4NDUsMzY5Ny40NDUzIEwzNDIuMjg0NSwzNjk3LjQ0NTMgQzM1Ny4yODQ1LDM2OTcuNDQ1MyAzNTcuMjg0NSwzNDcyLjI1NzggMzcyLjI4NDUsMzQ3Mi4yNTc4IEwzODIuMjg0NSwzNDcyLjI1NzggIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iNjEuOTk5OCIgeD0iMzgyLjI4NDUiIHk9IjM1MTAuNDA2MyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjQxLjk5OTgiIHg9IjM5Mi4yODQ1IiB5PSIzNTMzLjQwMTQiPiYjMzA0MTg7JiMyNzE2OTsmIzIyNDExOzwvdGV4dD48cGF0aCBkPSJNMzMyLjI4NDUsMzY5Ny40NDUzIEwzNDIuMjg0NSwzNjk3LjQ0NTMgQzM1Ny4yODQ1LDM2OTcuNDQ1MyAzNTcuMjg0NSwzNTI4LjU1NDcgMzcyLjI4NDUsMzUyOC41NTQ3IEwzODIuMjg0NSwzNTI4LjU1NDcgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iNDcuOTk5OSIgeD0iMzgyLjI4NDUiIHk9IjM2NTEuMTQ4NCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjI3Ljk5OTkiIHg9IjM5Mi4yODQ1IiB5PSIzNjc0LjE0MzYiPiYjMjQwNjc7JiMyMzYxNjs8L3RleHQ+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9Ijc1Ljk5OTgiIHg9IjQ4MC4yODQ0IiB5PSIzNTY2LjcwMzEiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI1NS45OTk4IiB4PSI0OTAuMjg0NCIgeT0iMzU4OS42OTgyIj4mIzI4MDE0OyYjMjExNjA7JiMyNDA2NzsmIzIzNjE2OzwvdGV4dD48cGF0aCBkPSJNNDMwLjI4NDQsMzY2OS4yOTY5IEw0NDAuMjg0NCwzNjY5LjI5NjkgQzQ1NS4yODQ0LDM2NjkuMjk2OSA0NTUuMjg0NCwzNTg0Ljg1MTYgNDcwLjI4NDQsMzU4NC44NTE2IEw0ODAuMjg0NCwzNTg0Ljg1MTYgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iNzUuOTk5OCIgeD0iNDgwLjI4NDQiIHk9IjM2MjMiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI1NS45OTk4IiB4PSI0OTAuMjg0NCIgeT0iMzY0NS45OTUxIj4mIzIzNDUwOyYjMjAzMDE7JiMyNDA2NzsmIzIzNjE2OzwvdGV4dD48cGF0aCBkPSJNNDMwLjI4NDQsMzY2OS4yOTY5IEw0NDAuMjg0NCwzNjY5LjI5NjkgQzQ1NS4yODQ0LDM2NjkuMjk2OSA0NTUuMjg0NCwzNjQxLjE0ODQgNDcwLjI4NDQsMzY0MS4xNDg0IEw0ODAuMjg0NCwzNjQxLjE0ODQgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTYzLjAyOCIgeD0iNDgwLjI4NDQiIHk9IjM2NzkuMjk2OSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjE0My4wMjgiIHg9IjQ5MC4yODQ0IiB5PSIzNzAyLjI5MiI+JiMyNDM3NzsmIzI0NjE1OyYjMjQwNjc7JiMyMzYxNjsgJiM2NTI4ODtGbGV4Ym94JiM2NTI4OTs8L3RleHQ+PHBhdGggZD0iTTQzMC4yODQ0LDM2NjkuMjk2OSBMNDQwLjI4NDQsMzY2OS4yOTY5IEM0NTUuMjg0NCwzNjY5LjI5NjkgNDU1LjI4NDQsMzY5Ny40NDUzIDQ3MC4yODQ0LDM2OTcuNDQ1MyBMNDgwLjI4NDQsMzY5Ny40NDUzICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjEzMy4zODA1IiB4PSI0ODAuMjg0NCIgeT0iMzczNS41OTM4Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTEzLjM4MDUiIHg9IjQ5MC4yODQ0IiB5PSIzNzU4LjU4ODkiPiYjMzI1OTM7JiMyNjY4NDsmIzI0MDY3OyYjMjM2MTY7JiM2NTI4ODtHcmlkJiM2NTI4OTs8L3RleHQ+PHBhdGggZD0iTTQzMC4yODQ0LDM2NjkuMjk2OSBMNDQwLjI4NDQsMzY2OS4yOTY5IEM0NTUuMjg0NCwzNjY5LjI5NjkgNDU1LjI4NDQsMzc1My43NDIyIDQ3MC4yODQ0LDM3NTMuNzQyMiBMNDgwLjI4NDQsMzc1My43NDIyICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTMzMi4yODQ1LDM2OTcuNDQ1MyBMMzQyLjI4NDUsMzY5Ny40NDUzIEMzNTcuMjg0NSwzNjk3LjQ0NTMgMzU3LjI4NDUsMzY2OS4yOTY5IDM3Mi4yODQ1LDM2NjkuMjk2OSBMMzgyLjI4NDUsMzY2OS4yOTY5ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9Ijk3LjY0MjQiIHg9IjM4Mi4yODQ1IiB5PSIzNzkxLjg5MDYiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI3Ny42NDI0IiB4PSIzOTIuMjg0NSIgeT0iMzgxNC44ODU3Ij5jc3MzICYjMjYwMzI7JiMyOTMwNTsmIzI0NjE1OzwvdGV4dD48cGF0aCBkPSJNMzMyLjI4NDUsMzY5Ny40NDUzIEwzNDIuMjg0NSwzNjk3LjQ0NTMgQzM1Ny4yODQ1LDM2OTcuNDQ1MyAzNTcuMjg0NSwzODEwLjAzOTEgMzcyLjI4NDUsMzgxMC4wMzkxIEwzODIuMjg0NSwzODEwLjAzOTEgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTU5Ljk5OTQiIHg9IjM4Mi4yODQ1IiB5PSIzODQ4LjE4NzUiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxMzkuOTk5NCIgeD0iMzkyLjI4NDUiIHk9IjM4NzEuMTgyNiI+JiMyMTcwOTsmIzI0MjEyOyYjMjQzMzU7JiMzNTc3NDsmIzM1NzQ1OyYjMjE2NDQ7JiMyMzE4NjsmIzIwMzA3OyYjMjY1OTc7JiMzNTgxMDs8L3RleHQ+PHBhdGggZD0iTTMzMi4yODQ1LDM2OTcuNDQ1MyBMMzQyLjI4NDUsMzY5Ny40NDUzIEMzNTcuMjg0NSwzNjk3LjQ0NTMgMzU3LjI4NDUsMzg2Ni4zMzU5IDM3Mi4yODQ1LDM4NjYuMzM1OSBMMzgyLjI4NDUsMzg2Ni4zMzU5ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9Ijc1Ljk5OTgiIHg9IjM4Mi4yODQ1IiB5PSIzOTMyLjYzMjgiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI1NS45OTk4IiB4PSIzOTIuMjg0NSIgeT0iMzk1NS42Mjc5Ij4mIzM5MDQ0OyYjMjI3ODg7JiMyOTcwMjsmIzIyMTIwOzwvdGV4dD48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iNTAuNDYwOSIgeD0iNTA4LjI4NDMiIHk9IjM5MDQuNDg0NCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjMwLjQ2MDkiIHg9IjUxOC4yODQzIiB5PSIzOTI3LjQ3OTUiPnNhc3M8L3RleHQ+PHBhdGggZD0iTTQ1OC4yODQzLDM5NTAuNzgxMyBMNDY4LjI4NDMsMzk1MC43ODEzIEM0ODMuMjg0MywzOTUwLjc4MTMgNDgzLjI4NDMsMzkyMi42MzI4IDQ5OC4yODQzLDM5MjIuNjMyOCBMNTA4LjI4NDMsMzkyMi42MzI4ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjQ3LjA5MDgiIHg9IjUwOC4yODQzIiB5PSIzOTYwLjc4MTMiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIyNy4wOTA4IiB4PSI1MTguMjg0MyIgeT0iMzk4My43NzY0Ij5sZXNzPC90ZXh0PjxwYXRoIGQ9Ik00NTguMjg0MywzOTUwLjc4MTMgTDQ2OC4yODQzLDM5NTAuNzgxMyBDNDgzLjI4NDMsMzk1MC43ODEzIDQ4My4yODQzLDM5NzguOTI5NyA0OTguMjg0MywzOTc4LjkyOTcgTDUwOC4yODQzLDM5NzguOTI5NyAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik0zMzIuMjg0NSwzNjk3LjQ0NTMgTDM0Mi4yODQ1LDM2OTcuNDQ1MyBDMzU3LjI4NDUsMzY5Ny40NDUzIDM1Ny4yODQ1LDM5NTAuNzgxMyAzNzIuMjg0NSwzOTUwLjc4MTMgTDM4Mi4yODQ1LDM5NTAuNzgxMyAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik0yMzkuOTk5NCw0NzEwLjc4OTEgTDI0OS45OTk0LDQ3MTAuNzg5MSBDMjY0Ljk5OTQsNDcxMC43ODkxIDI2NC45OTk0LDM2OTcuNDQ1MyAyNzkuOTk5NCwzNjk3LjQ0NTMgTDI4OS45OTk0LDM2OTcuNDQ1MyAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSI1NC42Nzg3IiB4PSIyODkuOTk5NCIgeT0iNTAzMC40MjE5Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMzQuNjc4NyIgeD0iMjk5Ljk5OTQiIHk9IjUwNTMuNDE3Ij52dWUzPC90ZXh0PjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSI3NS45OTk4IiB4PSIzOTQuNjc4MSIgeT0iNDE1Ny44MjAzIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNTUuOTk5OCIgeD0iNDA0LjY3ODEiIHk9IjQxODAuODE1NCI+JiMyMjUyMjsmIzMwNzg0OyYjMzA2OTM7JiMzNTc4Mjs8L3RleHQ+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjEzNC44NzA4IiB4PSI1MjAuNjc3OSIgeT0iNDAxNy4wNzgxIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTE0Ljg3MDgiIHg9IjUzMC42Nzc5IiB5PSI0MDQwLjA3MzIiPlZ1ZSAzICYjMzAzNDA7JiMyMjUyMjsmIzI2NDEyOyYjMjcwMTA7JiMyNDU2NTs8L3RleHQ+PHBhdGggZD0iTTQ3MC42Nzc5LDQxNzUuOTY4OCBMNDgwLjY3NzksNDE3NS45Njg4IEM0OTUuNjc3OSw0MTc1Ljk2ODggNDk1LjY3NzksNDAzNS4yMjY2IDUxMC42Nzc5LDQwMzUuMjI2NiBMNTIwLjY3NzksNDAzNS4yMjY2ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjEzMS45OTk1IiB4PSI1MjAuNjc3OSIgeT0iNDA3My4zNzUiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxMTEuOTk5NSIgeD0iNTMwLjY3NzkiIHk9IjQwOTYuMzcwMSI+JiMzOTAzMzsmIzMwNDQ2OyYjMjEwMjE7JiMyMjk4NzsmIzIxMjcwOyYjMTk5ODI7JiMzNzE5NzsmIzMyNjIyOzwvdGV4dD48cGF0aCBkPSJNNDcwLjY3NzksNDE3NS45Njg4IEw0ODAuNjc3OSw0MTc1Ljk2ODggQzQ5NS42Nzc5LDQxNzUuOTY4OCA0OTUuNjc3OSw0MDkxLjUyMzQgNTEwLjY3NzksNDA5MS41MjM0IEw1MjAuNjc3OSw0MDkxLjUyMzQgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTY2LjQ4MDMiIHg9IjUyMC42Nzc5IiB5PSI0MTI5LjY3MTkiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxNDYuNDgwMyIgeD0iNTMwLjY3NzkiIHk9IjQxNTIuNjY3Ij5Db21wb3NpdGlvbiBBUEkgJiMyNzAxMDsmIzM2ODQ4OzwvdGV4dD48cGF0aCBkPSJNNDcwLjY3NzksNDE3NS45Njg4IEw0ODAuNjc3OSw0MTc1Ljk2ODggQzQ5NS42Nzc5LDQxNzUuOTY4OCA0OTUuNjc3OSw0MTQ3LjgyMDMgNTEwLjY3NzksNDE0Ny44MjAzIEw1MjAuNjc3OSw0MTQ3LjgyMDMgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTE5LjYwNjIiIHg9IjUyMC42Nzc5IiB5PSI0MTg1Ljk2ODgiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI5OS42MDYyIiB4PSI1MzAuNjc3OSIgeT0iNDIwOC45NjM5Ij5zZXR1cCAmIzIwOTg5OyYjMjU5Njg7JiMzNTgxNDsmIzM1Mjk5OzwvdGV4dD48cGF0aCBkPSJNNDcwLjY3NzksNDE3NS45Njg4IEw0ODAuNjc3OSw0MTc1Ljk2ODggQzQ5NS42Nzc5LDQxNzUuOTY4OCA0OTUuNjc3OSw0MjA0LjExNzIgNTEwLjY3NzksNDIwNC4xMTcyIEw1MjAuNjc3OSw0MjA0LjExNzIgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTY5LjU0MjciIHg9IjUyMC42Nzc5IiB5PSI0MjQyLjI2NTYiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxNDkuNTQyNyIgeD0iNTMwLjY3NzkiIHk9IjQyNjUuMjYwNyI+UmVhY3RpdmUgJiMyMTY0NDsgcmVmICYjMzAzNDA7JiMyMDM1MTsmIzI5OTkyOzwvdGV4dD48cGF0aCBkPSJNNDcwLjY3NzksNDE3NS45Njg4IEw0ODAuNjc3OSw0MTc1Ljk2ODggQzQ5NS42Nzc5LDQxNzUuOTY4OCA0OTUuNjc3OSw0MjYwLjQxNDEgNTEwLjY3NzksNDI2MC40MTQxIEw1MjAuNjc3OSw0MjYwLjQxNDEgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTAzLjk5OTYiIHg9IjUyMC42Nzc5IiB5PSI0Mjk4LjU2MjUiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI4My45OTk2IiB4PSI1MzAuNjc3OSIgeT0iNDMyMS41NTc2Ij4mIzI5OTgzOyYjMjE2Mjk7JiMyMTYwODsmIzI2Mzk5OyYjMzgwNTc7JiMyMzM3Njs8L3RleHQ+PHBhdGggZD0iTTQ3MC42Nzc5LDQxNzUuOTY4OCBMNDgwLjY3NzksNDE3NS45Njg4IEM0OTUuNjc3OSw0MTc1Ljk2ODggNDk1LjY3NzksNDMxNi43MTA5IDUxMC42Nzc5LDQzMTYuNzEwOSBMNTIwLjY3NzksNDMxNi43MTA5ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTM0NC42NzgxLDUwNDguNTcwMyBMMzU0LjY3ODEsNTA0OC41NzAzIEMzNjkuNjc4MSw1MDQ4LjU3MDMgMzY5LjY3ODEsNDE3NS45Njg4IDM4NC42NzgxLDQxNzUuOTY4OCBMMzk0LjY3ODEsNDE3NS45Njg4ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9Ijc1Ljk5OTgiIHg9IjM5NC42NzgxIiB5PSI0NDk1LjYwMTYiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI1NS45OTk4IiB4PSI0MDQuNjc4MSIgeT0iNDUxOC41OTY3Ij4mIzM2ODI3OyYjMzg0NTQ7JiMyNzAxMDsmIzI0NTY1OzwvdGV4dD48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMjM4LjU2NSIgeD0iNTIwLjY3NzkiIHk9IjQzNTQuODU5NCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjIxOC41NjUiIHg9IjUzMC42Nzc5IiB5PSI0Mzc3Ljg1NDUiPiYjMzI0NTI7JiMyMTUxMjsmIzI0MzM1OyBBUEkgJiMxOTk4MjsgT3B0aW9ucyBBUEkgJiMzMDM0MDsmIzIzNTQ1OyYjMjc2MDQ7PC90ZXh0PjxwYXRoIGQ9Ik00NzAuNjc3OSw0NTEzLjc1IEw0ODAuNjc3OSw0NTEzLjc1IEM0OTUuNjc3OSw0NTEzLjc1IDQ5NS42Nzc5LDQzNzMuMDA3OCA1MTAuNjc3OSw0MzczLjAwNzggTDUyMC42Nzc5LDQzNzMuMDA3OCAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxOTkuODQ2MyIgeD0iNTIwLjY3NzkiIHk9IjQ0MTEuMTU2MyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjE3OS44NDYzIiB4PSI1MzAuNjc3OSIgeT0iNDQzNC4xNTE0Ij4mIzIwMzgxOyYjMzYxODI7JiMyNzg4MDsmIzIwODM3OyYjNjUyODg7UHJvdmlkZS9JbmplY3QmIzY1Mjg5OzwvdGV4dD48cGF0aCBkPSJNNDcwLjY3NzksNDUxMy43NSBMNDgwLjY3NzksNDUxMy43NSBDNDk1LjY3NzksNDUxMy43NSA0OTUuNjc3OSw0NDI5LjMwNDcgNTEwLjY3NzksNDQyOS4zMDQ3IEw1MjAuNjc3OSw0NDI5LjMwNDcgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iODkuOTk5NyIgeD0iNTIwLjY3NzkiIHk9IjQ0NjcuNDUzMSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjY5Ljk5OTciIHg9IjUzMC42Nzc5IiB5PSI0NDkwLjQ0ODIiPiYjMzMyNTg7JiMyMzQ1MDsmIzIwMDQxOyYjMjUzNTE7JiMyMDE5Njs8L3RleHQ+PHBhdGggZD0iTTQ3MC42Nzc5LDQ1MTMuNzUgTDQ4MC42Nzc5LDQ1MTMuNzUgQzQ5NS42Nzc5LDQ1MTMuNzUgNDk1LjY3NzksNDQ4NS42MDE2IDUxMC42Nzc5LDQ0ODUuNjAxNiBMNTIwLjY3NzksNDQ4NS42MDE2ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjE0NS45OTk1IiB4PSI1MjAuNjc3OSIgeT0iNDUyMy43NSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjEyNS45OTk1IiB4PSI1MzAuNjc3OSIgeT0iNDU0Ni43NDUxIj4mIzIxMTYwOyYjMjQ1Nzc7JiMzMjQ1MjsmIzIwMjE0OyYjMTk5ODI7JiMyNDMyMjsmIzI3NDkzOyYjMzI0NTI7JiMyMDIxNDs8L3RleHQ+PHBhdGggZD0iTTQ3MC42Nzc5LDQ1MTMuNzUgTDQ4MC42Nzc5LDQ1MTMuNzUgQzQ5NS42Nzc5LDQ1MTMuNzUgNDk1LjY3NzksNDU0MS44OTg0IDUxMC42Nzc5LDQ1NDEuODk4NCBMNTIwLjY3NzksNDU0MS44OTg0ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjExMy43NDc3IiB4PSI1MjAuNjc3OSIgeT0iNDU4MC4wNDY5Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTMuNzQ3NyIgeD0iNTMwLjY3NzkiIHk9IjQ2MDMuMDQyIj4mIzI3MTY5OyYjMjY0OTU7JiMyNDM0MTsmIzI5OTkyOyYjMTk5ODI7IHJlZjwvdGV4dD48cGF0aCBkPSJNNDcwLjY3NzksNDUxMy43NSBMNDgwLjY3NzksNDUxMy43NSBDNDk1LjY3NzksNDUxMy43NSA0OTUuNjc3OSw0NTk4LjE5NTMgNTEwLjY3NzksNDU5OC4xOTUzIEw1MjAuNjc3OSw0NTk4LjE5NTMgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTEwLjgxNTMiIHg9IjUyMC42Nzc5IiB5PSI0NjM2LjM0MzgiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI5MC44MTUzIiB4PSI1MzAuNjc3OSIgeT0iNDY1OS4zMzg5Ij5UZWxlcG9ydCAmIzMyNDUyOyYjMjAyMTQ7PC90ZXh0PjxwYXRoIGQ9Ik00NzAuNjc3OSw0NTEzLjc1IEw0ODAuNjc3OSw0NTEzLjc1IEM0OTUuNjc3OSw0NTEzLjc1IDQ5NS42Nzc5LDQ2NTQuNDkyMiA1MTAuNjc3OSw0NjU0LjQ5MjIgTDUyMC42Nzc5LDQ2NTQuNDkyMiAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik0zNDQuNjc4MSw1MDQ4LjU3MDMgTDM1NC42NzgxLDUwNDguNTcwMyBDMzY5LjY3ODEsNTA0OC41NzAzIDM2OS42NzgxLDQ1MTMuNzUgMzg0LjY3ODEsNDUxMy43NSBMMzk0LjY3ODEsNDUxMy43NSAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSI3NS45OTk4IiB4PSIzOTQuNjc4MSIgeT0iNDc3Ny4wODU5Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNTUuOTk5OCIgeD0iNDA0LjY3ODEiIHk9IjQ4MDAuMDgxMSI+JiMyOTM2NjsmIzI0NTc3OyYjMzE2NDk7JiMyOTcwMjs8L3RleHQ+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjEwMS4xNTYxIiB4PSI1MjAuNjc3OSIgeT0iNDY5Mi42NDA2Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iODEuMTU2MSIgeD0iNTMwLjY3NzkiIHk9IjQ3MTUuNjM1NyI+VnVleCA0ICYjMjcwMTA7JiMzNjg0ODs8L3RleHQ+PHBhdGggZD0iTTQ3MC42Nzc5LDQ3OTUuMjM0NCBMNDgwLjY3NzksNDc5NS4yMzQ0IEM0OTUuNjc3OSw0Nzk1LjIzNDQgNDk1LjY3NzksNDcxMC43ODkxIDUxMC42Nzc5LDQ3MTAuNzg5MSBMNTIwLjY3NzksNDcxMC43ODkxICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjI5Ni4yNDY3IiB4PSI1MjAuNjc3OSIgeT0iNDc0OC45Mzc1Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMjc2LjI0NjciIHg9IjUzMC42Nzc5IiB5PSI0NzcxLjkzMjYiPlN0YXRlJiMxMjI4OTtHZXR0ZXImIzEyMjg5O011dGF0aW9uJiMxMjI4OTtBY3Rpb24gJiMzMDM0MDsmIzIwMzUxOyYjMjk5OTI7PC90ZXh0PjxwYXRoIGQ9Ik00NzAuNjc3OSw0Nzk1LjIzNDQgTDQ4MC42Nzc5LDQ3OTUuMjM0NCBDNDk1LjY3NzksNDc5NS4yMzQ0IDQ5NS42Nzc5LDQ3NjcuMDg1OSA1MTAuNjc3OSw0NzY3LjA4NTkgTDUyMC42Nzc5LDQ3NjcuMDg1OSAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxMTcuOTk5NiIgeD0iNTIwLjY3NzkiIHk9IjQ4MDUuMjM0NCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9Ijk3Ljk5OTYiIHg9IjUzMC42Nzc5IiB5PSI0ODI4LjIyOTUiPiYjMjcxNjk7JiMyMjM1OTsmIzIxMjcwOyYjMjkzNjY7JiMyNDU3NzsmIzMxNjQ5OyYjMjk3MDI7PC90ZXh0PjxwYXRoIGQ9Ik00NzAuNjc3OSw0Nzk1LjIzNDQgTDQ4MC42Nzc5LDQ3OTUuMjM0NCBDNDk1LjY3NzksNDc5NS4yMzQ0IDQ5NS42Nzc5LDQ4MjMuMzgyOCA1MTAuNjc3OSw0ODIzLjM4MjggTDUyMC42Nzc5LDQ4MjMuMzgyOCAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIyMjYuOTMwMyIgeD0iNTIwLjY3NzkiIHk9IjQ4NjEuNTMxMyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjIwNi45MzAzIiB4PSI1MzAuNjc3OSIgeT0iNDg4NC41MjY0Ij4mIzIwMzUxOyYjMjk5OTI7IENvbXBvc2l0aW9uIEFQSSAmIzMxNjQ5OyYjMjk3MDI7JiMyOTM2NjsmIzI0NTc3OzwvdGV4dD48cGF0aCBkPSJNNDcwLjY3NzksNDc5NS4yMzQ0IEw0ODAuNjc3OSw0Nzk1LjIzNDQgQzQ5NS42Nzc5LDQ3OTUuMjM0NCA0OTUuNjc3OSw0ODc5LjY3OTcgNTEwLjY3NzksNDg3OS42Nzk3IEw1MjAuNjc3OSw0ODc5LjY3OTcgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNMzQ0LjY3ODEsNTA0OC41NzAzIEwzNTQuNjc4MSw1MDQ4LjU3MDMgQzM2OS42NzgxLDUwNDguNTcwMyAzNjkuNjc4MSw0Nzk1LjIzNDQgMzg0LjY3ODEsNDc5NS4yMzQ0IEwzOTQuNjc4MSw0Nzk1LjIzNDQgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iNzUuOTk5OCIgeD0iMzk0LjY3ODEiIHk9IjUwMDIuMjczNCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjU1Ljk5OTgiIHg9IjQwNC42NzgxIiB5PSI1MDI1LjI2ODYiPiYjMzYzMzU7JiMzMDAwMTsmIzMxNjQ5OyYjMjk3MDI7PC90ZXh0PjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxODYuMzQ1NCIgeD0iNTIwLjY3NzkiIHk9IjQ5MTcuODI4MSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjE2Ni4zNDU0IiB4PSI1MzAuNjc3OSIgeT0iNDk0MC44MjMyIj5WdWUgUm91dGVyIDQgJiMzMDM0MDsmIzIyNTIyOyYjMjY0MTI7JiMyMDM1MTsmIzI5OTkyOzwvdGV4dD48cGF0aCBkPSJNNDcwLjY3NzksNTAyMC40MjE5IEw0ODAuNjc3OSw1MDIwLjQyMTkgQzQ5NS42Nzc5LDUwMjAuNDIxOSA0OTUuNjc3OSw0OTM1Ljk3NjYgNTEwLjY3NzksNDkzNS45NzY2IEw1MjAuNjc3OSw0OTM1Ljk3NjYgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTQ1Ljk5OTUiIHg9IjUyMC42Nzc5IiB5PSI0OTc0LjEyNSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjEyNS45OTk1IiB4PSI1MzAuNjc3OSIgeT0iNDk5Ny4xMjAxIj4mIzIxMTYwOyYjMjQ1Nzc7JiMzNjMzNTsmIzMwMDAxOyYjMTk5ODI7JiMyMzg4NDsmIzIyODcxOyYjMzYzMzU7JiMzMDAwMTs8L3RleHQ+PHBhdGggZD0iTTQ3MC42Nzc5LDUwMjAuNDIxOSBMNDgwLjY3NzksNTAyMC40MjE5IEM0OTUuNjc3OSw1MDIwLjQyMTkgNDk1LjY3NzksNDk5Mi4yNzM0IDUxMC42Nzc5LDQ5OTIuMjczNCBMNTIwLjY3NzksNDk5Mi4yNzM0ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjEzMS45OTk1IiB4PSI1MjAuNjc3OSIgeT0iNTAzMC40MjE5Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTExLjk5OTUiIHg9IjUzMC42Nzc5IiB5PSI1MDUzLjQxNyI+JiMzNjMzNTsmIzMwMDAxOyYjMjM0MzI7JiMyMTM1NTsmIzE5OTgyOyYjMjUwNDI7JiMyMTE1MjsmIzM2NzMzOzwvdGV4dD48cGF0aCBkPSJNNDcwLjY3NzksNTAyMC40MjE5IEw0ODAuNjc3OSw1MDIwLjQyMTkgQzQ5NS42Nzc5LDUwMjAuNDIxOSA0OTUuNjc3OSw1MDQ4LjU3MDMgNTEwLjY3NzksNTA0OC41NzAzIEw1MjAuNjc3OSw1MDQ4LjU3MDMgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTE3Ljk5OTYiIHg9IjUyMC42Nzc5IiB5PSI1MDg2LjcxODgiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI5Ny45OTk2IiB4PSI1MzAuNjc3OSIgeT0iNTEwOS43MTM5Ij4mIzIzNTQ4OyYjMzMzMjI7JiMyMzQzMjsmIzIxMzU1OyYjMzAzNDA7JiMyMDM1MTsmIzI5OTkyOzwvdGV4dD48cGF0aCBkPSJNNDcwLjY3NzksNTAyMC40MjE5IEw0ODAuNjc3OSw1MDIwLjQyMTkgQzQ5NS42Nzc5LDUwMjAuNDIxOSA0OTUuNjc3OSw1MTA0Ljg2NzIgNTEwLjY3NzksNTEwNC44NjcyIEw1MjAuNjc3OSw1MTA0Ljg2NzIgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNMzQ0LjY3ODEsNTA0OC41NzAzIEwzNTQuNjc4MSw1MDQ4LjU3MDMgQzM2OS42NzgxLDUwNDguNTcwMyAzNjkuNjc4MSw1MDIwLjQyMTkgMzg0LjY3ODEsNTAyMC40MjE5IEwzOTQuNjc4MSw1MDIwLjQyMTkgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iNzUuOTk5OCIgeD0iMzk0LjY3ODEiIHk9IjUxOTkuMzEyNSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjU1Ljk5OTgiIHg9IjQwNC42NzgxIiB5PSI1MjIyLjMwNzYiPiYjMzQ5MjA7JiMyMTMzMzsmIzIyNzg4OyYjMjk3MDI7PC90ZXh0PjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxMTcuOTk5NiIgeD0iNTIwLjY3NzkiIHk9IjUxNDMuMDE1NiIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9Ijk3Ljk5OTYiIHg9IjUzMC42Nzc5IiB5PSI1MTY2LjAxMDciPiYjMzQ5MjA7JiMyMTMzMzsmIzMyNDY1OyYjMjM0NTA7JiMxOTk4MjsmIzM5NTY0OyYjMzU3Nzc7PC90ZXh0PjxwYXRoIGQ9Ik00NzAuNjc3OSw1MjE3LjQ2MDkgTDQ4MC42Nzc5LDUyMTcuNDYwOSBDNDk1LjY3NzksNTIxNy40NjA5IDQ5NS42Nzc5LDUxNjEuMTY0MSA1MTAuNjc3OSw1MTYxLjE2NDEgTDUyMC42Nzc5LDUxNjEuMTY0MSAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSI3NS45OTk4IiB4PSI1MjAuNjc3OSIgeT0iNTE5OS4zMTI1Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNTUuOTk5OCIgeD0iNTMwLjY3NzkiIHk9IjUyMjIuMzA3NiI+JiMzNDkyMDsmIzIxMzMzOyYjMzk1NjQ7JiMzNTc3Nzs8L3RleHQ+PHBhdGggZD0iTTQ3MC42Nzc5LDUyMTcuNDYwOSBMNDgwLjY3NzksNTIxNy40NjA5IEM0OTUuNjc3OSw1MjE3LjQ2MDkgNDk1LjY3NzksNTIxNy40NjA5IDUxMC42Nzc5LDUyMTcuNDYwOSBMNTIwLjY3NzksNTIxNy40NjA5ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjExNy45OTk2IiB4PSI1MjAuNjc3OSIgeT0iNTI1NS42MDk0Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTcuOTk5NiIgeD0iNTMwLjY3NzkiIHk9IjUyNzguNjA0NSI+JiMzMzI1ODsmIzIzNDUwOyYjMjAwNDE7JiMzNDkyMDsmIzIxMzMzOyYjMzI0NTI7JiMyMDIxNDs8L3RleHQ+PHBhdGggZD0iTTQ3MC42Nzc5LDUyMTcuNDYwOSBMNDgwLjY3NzksNTIxNy40NjA5IEM0OTUuNjc3OSw1MjE3LjQ2MDkgNDk1LjY3NzksNTI3My43NTc4IDUxMC42Nzc5LDUyNzMuNzU3OCBMNTIwLjY3NzksNTI3My43NTc4ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTM0NC42NzgxLDUwNDguNTcwMyBMMzU0LjY3ODEsNTA0OC41NzAzIEMzNjkuNjc4MSw1MDQ4LjU3MDMgMzY5LjY3ODEsNTIxNy40NjA5IDM4NC42NzgxLDUyMTcuNDYwOSBMMzk0LjY3ODEsNTIxNy40NjA5ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9Ijg5Ljk5OTciIHg9IjM5NC42NzgxIiB5PSI1MzY4LjIwMzEiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI2OS45OTk3IiB4PSI0MDQuNjc4MSIgeT0iNTM5MS4xOTgyIj4mIzIxMTYwOyYjMzAwMTE7JiMxOTk4MjsmIzM2ODA3OyYjMjgxOTM7PC90ZXh0PjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxMTcuOTk5NiIgeD0iNTM0LjY3NzgiIHk9IjUzMTEuOTA2MyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9Ijk3Ljk5OTYiIHg9IjU0NC42Nzc4IiB5PSI1MzM0LjkwMTQiPiYjMzY4MDc7JiMyODE5MzsmIzMwMzQwOyYjMjI1MjI7JiMyNjQxMjsmIzIwMzUxOyYjMjk5OTI7PC90ZXh0PjxwYXRoIGQ9Ik00ODQuNjc3OCw1Mzg2LjM1MTYgTDQ5NC42Nzc4LDUzODYuMzUxNiBDNTA5LjY3NzgsNTM4Ni4zNTE2IDUwOS42Nzc4LDUzMzAuMDU0NyA1MjQuNjc3OCw1MzMwLjA1NDcgTDUzNC42Nzc4LDUzMzAuMDU0NyAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxNTQuNjYwOSIgeD0iNTM0LjY3NzgiIHk9IjUzNjguMjAzMSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjEzNC42NjA5IiB4PSI1NDQuNjc3OCIgeT0iNTM5MS4xOTgyIj4mIzIwMzUxOyYjMjk5OTI7IFRyYW5zaXRpb24gJiMzMjQ1MjsmIzIwMjE0OzwvdGV4dD48cGF0aCBkPSJNNDg0LjY3NzgsNTM4Ni4zNTE2IEw0OTQuNjc3OCw1Mzg2LjM1MTYgQzUwOS42Nzc4LDUzODYuMzUxNiA1MDkuNjc3OCw1Mzg2LjM1MTYgNTI0LjY3NzgsNTM4Ni4zNTE2IEw1MzQuNjc3OCw1Mzg2LjM1MTYgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTE3Ljk5OTYiIHg9IjUzNC42Nzc4IiB5PSI1NDI0LjUiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI5Ny45OTk2IiB4PSI1NDQuNjc3OCIgeT0iNTQ0Ny40OTUxIj4mIzIxMTYwOyYjMzAwMTE7JiMzMDM0MDsmIzM5NjQwOyYjMzI0MjM7JiMyOTk5MjsmIzI3ODYxOzwvdGV4dD48cGF0aCBkPSJNNDg0LjY3NzgsNTM4Ni4zNTE2IEw0OTQuNjc3OCw1Mzg2LjM1MTYgQzUwOS42Nzc4LDUzODYuMzUxNiA1MDkuNjc3OCw1NDQyLjY0ODQgNTI0LjY3NzgsNTQ0Mi42NDg0IEw1MzQuNjc3OCw1NDQyLjY0ODQgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNMzQ0LjY3ODEsNTA0OC41NzAzIEwzNTQuNjc4MSw1MDQ4LjU3MDMgQzM2OS42NzgxLDUwNDguNTcwMyAzNjkuNjc4MSw1Mzg2LjM1MTYgMzg0LjY3ODEsNTM4Ni4zNTE2IEwzOTQuNjc4MSw1Mzg2LjM1MTYgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTQ5Ljk1MDciIHg9IjM5NC42NzgxIiB5PSI1NTM3LjA5MzgiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxMjkuOTUwNyIgeD0iNDA0LjY3ODEiIHk9IjU1NjAuMDg4OSI+U1NSICYjMTk5ODI7JiMzODc0NTsmIzI0NTc3OyYjMzI1OTM7JiMzMTQ0OTsmIzI5OTgzOyYjMjUxMDQ7PC90ZXh0PjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxNjIuMjQ4OCIgeD0iNTk0LjYyODgiIHk9IjU0ODAuNzk2OSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjE0Mi4yNDg4IiB4PSI2MDQuNjI4OCIgeT0iNTUwMy43OTIiPlZ1ZSAzICYjMTk5ODI7IE51eHQgMyAmIzI3MDEwOyYjMzY4NDg7PC90ZXh0PjxwYXRoIGQ9Ik01NDQuNjI4OCw1NTU1LjI0MjIgTDU1NC42Mjg4LDU1NTUuMjQyMiBDNTY5LjYyODgsNTU1NS4yNDIyIDU2OS42Mjg4LDU0OTguOTQ1MyA1ODQuNjI4OCw1NDk4Ljk0NTMgTDU5NC42Mjg4LDU0OTguOTQ1MyAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIyMjkuNTAwMiIgeD0iNTk0LjYyODgiIHk9IjU1MzcuMDkzOCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjIwOS41MDAyIiB4PSI2MDQuNjI4OCIgeT0iNTU2MC4wODg5Ij4mIzI2MzgxOyYjMjExNTM7JiMzMTQ3MTsmIzI4MjEwOyYjMjY1Nzk7JiM2NTI4ODtTU1ImIzY1Mjg5OyYjMzAzNDA7JiMzNzE5NzsmIzMyNjIyOyYjMTk5ODI7JiMyMDM1MTsmIzI5OTkyOzwvdGV4dD48cGF0aCBkPSJNNTQ0LjYyODgsNTU1NS4yNDIyIEw1NTQuNjI4OCw1NTU1LjI0MjIgQzU2OS42Mjg4LDU1NTUuMjQyMiA1NjkuNjI4OCw1NTU1LjI0MjIgNTg0LjYyODgsNTU1NS4yNDIyIEw1OTQuNjI4OCw1NTU1LjI0MjIgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMjQ0LjYyMTIiIHg9IjU5NC42Mjg4IiB5PSI1NTkzLjM5MDYiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIyMjQuNjIxMiIgeD0iNjA0LjYyODgiIHk9IjU2MTYuMzg1NyI+JiMzODc0NTsmIzI0NTc3OyYjMzI1OTM7JiMzMTQ0OTsmIzI5OTgzOyYjMjUxMDQ7JiM2NTI4ODtTU0cmIzY1Mjg5OyYjMzAzNDA7JiMzNzE5NzsmIzMyNjIyOyYjMTk5ODI7JiMyMDM1MTsmIzI5OTkyOzwvdGV4dD48cGF0aCBkPSJNNTQ0LjYyODgsNTU1NS4yNDIyIEw1NTQuNjI4OCw1NTU1LjI0MjIgQzU2OS42Mjg4LDU1NTUuMjQyMiA1NjkuNjI4OCw1NjExLjUzOTEgNTg0LjYyODgsNTYxMS41MzkxIEw1OTQuNjI4OCw1NjExLjUzOTEgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNMzQ0LjY3ODEsNTA0OC41NzAzIEwzNTQuNjc4MSw1MDQ4LjU3MDMgQzM2OS42NzgxLDUwNDguNTcwMyAzNjkuNjc4MSw1NTU1LjI0MjIgMzg0LjY3ODEsNTU1NS4yNDIyIEwzOTQuNjc4MSw1NTU1LjI0MjIgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iODkuOTk5NyIgeD0iMzk0LjY3ODEiIHk9IjU3NjIuMjgxMyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjY5Ljk5OTciIHg9IjQwNC42NzgxIiB5PSI1Nzg1LjI3NjQiPiYjMjE3MDk7JiMyNDIxMjsmIzI0MzM1OyYjMjE0MDc7JiMyOTcwMjs8L3RleHQ+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjE1OS45OTk0IiB4PSI1MzQuNjc3OCIgeT0iNTY0OS42ODc1Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTM5Ljk5OTQiIHg9IjU0NC42Nzc4IiB5PSI1NjcyLjY4MjYiPiYjMjE3MDk7JiMyNDIxMjsmIzI0MzM1OyYjMzE5OTU7JiMzMjQ3OTsmIzMwMzQwOyYjMjI1MjI7JiMyNjQxMjsmIzI3MDEwOyYjMjQ1NjU7PC90ZXh0PjxwYXRoIGQ9Ik00ODQuNjc3OCw1NzgwLjQyOTcgTDQ5NC42Nzc4LDU3ODAuNDI5NyBDNTA5LjY3NzgsNTc4MC40Mjk3IDUwOS42Nzc4LDU2NjcuODM1OSA1MjQuNjc3OCw1NjY3LjgzNTkgTDUzNC42Nzc4LDU2NjcuODM1OSAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxOTMuNTcwOSIgeD0iNTM0LjY3NzgiIHk9IjU3MDUuOTg0NCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjE3My41NzA5IiB4PSI1NDQuNjc3OCIgeT0iNTcyOC45Nzk1Ij5yZWFjdGl2ZSAmIzE5OTgyOyByZWYgJiMzMDM0MDsmIzIzNDU0OyYjMjk2MTY7JiMyMTQwNzsmIzI5NzAyOzwvdGV4dD48cGF0aCBkPSJNNDg0LjY3NzgsNTc4MC40Mjk3IEw0OTQuNjc3OCw1NzgwLjQyOTcgQzUwOS42Nzc4LDU3ODAuNDI5NyA1MDkuNjc3OCw1NzI0LjEzMjggNTI0LjY3NzgsNTcyNC4xMzI4IEw1MzQuNjc3OCw1NzI0LjEzMjggIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMjM0LjU1OTIiIHg9IjUzNC42Nzc4IiB5PSI1NzYyLjI4MTMiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIyMTQuNTU5MiIgeD0iNTQ0LjY3NzgiIHk9IjU3ODUuMjc2NCI+Q29tcHV0ZWQgJiMxOTk4MjsgV2F0Y2ggJiMzMDM0MDsmIzI0MDM3OyYjMjAzMTY7JiMyNjQyNjsmIzIxMDQ2OzwvdGV4dD48cGF0aCBkPSJNNDg0LjY3NzgsNTc4MC40Mjk3IEw0OTQuNjc3OCw1NzgwLjQyOTcgQzUwOS42Nzc4LDU3ODAuNDI5NyA1MDkuNjc3OCw1NzgwLjQyOTcgNTI0LjY3NzgsNTc4MC40Mjk3IEw1MzQuNjc3OCw1NzgwLjQyOTcgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMjMyLjI0MTgiIHg9IjUzNC42Nzc4IiB5PSI1ODE4LjU3ODEiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIyMTIuMjQxOCIgeD0iNTQ0LjY3NzgiIHk9IjU4NDEuNTczMiI+UHJveHkgJiMyMzU0NTsmIzM1OTM3OyYjMTk5ODI7IFJlZmxlY3QgQVBJICYjMzAzNDA7JiMyMDM1MTsmIzI5OTkyOzwvdGV4dD48cGF0aCBkPSJNNDg0LjY3NzgsNTc4MC40Mjk3IEw0OTQuNjc3OCw1NzgwLjQyOTcgQzUwOS42Nzc4LDU3ODAuNDI5NyA1MDkuNjc3OCw1ODM2LjcyNjYgNTI0LjY3NzgsNTgzNi43MjY2IEw1MzQuNjc3OCw1ODM2LjcyNjYgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTczLjk5OTMiIHg9IjUzNC42Nzc4IiB5PSI1ODc0Ljg3NSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjE1My45OTkzIiB4PSI1NDQuNjc3OCIgeT0iNTg5Ny44NzAxIj4mIzIxNzA5OyYjMjQyMTI7JiMyNDMzNTsmIzMxOTk1OyYjMzI0Nzk7JiMyMDAxMzsmIzMwMzQwOyYjMjAyNDg7JiMyMTI3MDsmIzMxNTc0OyYjMzAwNTM7PC90ZXh0PjxwYXRoIGQ9Ik00ODQuNjc3OCw1NzgwLjQyOTcgTDQ5NC42Nzc4LDU3ODAuNDI5NyBDNTA5LjY3NzgsNTc4MC40Mjk3IDUwOS42Nzc4LDU4OTMuMDIzNCA1MjQuNjc3OCw1ODkzLjAyMzQgTDUzNC42Nzc4LDU4OTMuMDIzNCAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik0zNDQuNjc4MSw1MDQ4LjU3MDMgTDM1NC42NzgxLDUwNDguNTcwMyBDMzY5LjY3ODEsNTA0OC41NzAzIDM2OS42NzgxLDU3ODAuNDI5NyAzODQuNjc4MSw1NzgwLjQyOTcgTDM5NC42NzgxLDU3ODAuNDI5NyAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSI0Ny45OTk5IiB4PSIzOTQuNjc4MSIgeT0iNTk4Ny40Njg4Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMjcuOTk5OSIgeD0iNDA0LjY3ODEiIHk9IjYwMTAuNDYzOSI+JiMyNzk3OTsmIzM1Nzk3OzwvdGV4dD48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTQ1Ljk5OTUiIHg9IjQ5Mi42NzgiIHk9IjU5MzEuMTcxOSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjEyNS45OTk1IiB4PSI1MDIuNjc4IiB5PSI1OTU0LjE2NyI+JiMyMTMzMzsmIzIwODAzOyYjMjc5Nzk7JiMzNTc5NzsmIzE5OTgyOyYjMzI0NTI7JiMyMDIxNDsmIzI3OTc5OyYjMzU3OTc7PC90ZXh0PjxwYXRoIGQ9Ik00NDIuNjc4LDYwMDUuNjE3MiBMNDUyLjY3OCw2MDA1LjYxNzIgQzQ2Ny42NzgsNjAwNS42MTcyIDQ2Ny42NzgsNTk0OS4zMjAzIDQ4Mi42NzgsNTk0OS4zMjAzIEw0OTIuNjc4LDU5NDkuMzIwMyAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxOTcuNTk3NSIgeD0iNDkyLjY3OCIgeT0iNTk4Ny40Njg4Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTc3LjU5NzUiIHg9IjUwMi42NzgiIHk9IjYwMTAuNDYzOSI+JiMyMDM1MTsmIzI5OTkyOyBKZXN0ICYjMjE2NDQ7IFZ1ZSBUZXN0IFV0aWxzPC90ZXh0PjxwYXRoIGQ9Ik00NDIuNjc4LDYwMDUuNjE3MiBMNDUyLjY3OCw2MDA1LjYxNzIgQzQ2Ny42NzgsNjAwNS42MTcyIDQ2Ny42NzgsNjAwNS42MTcyIDQ4Mi42NzgsNjAwNS42MTcyIEw0OTIuNjc4LDYwMDUuNjE3MiAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxNDQuNTk4MiIgeD0iNDkyLjY3OCIgeT0iNjA0My43NjU2Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTI0LjU5ODIiIHg9IjUwMi42NzgiIHk9IjYwNjYuNzYwNyI+JiMzMTQ3MTsmIzIxMDQwOyYjMzE0NzE7JiMyNzk3OTsmIzM1Nzk3OyYjNjUyODg7RTJFJiM2NTI4OTs8L3RleHQ+PHBhdGggZD0iTTQ0Mi42NzgsNjAwNS42MTcyIEw0NTIuNjc4LDYwMDUuNjE3MiBDNDY3LjY3OCw2MDA1LjYxNzIgNDY3LjY3OCw2MDYxLjkxNDEgNDgyLjY3OCw2MDYxLjkxNDEgTDQ5Mi42NzgsNjA2MS45MTQxICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTM0NC42NzgxLDUwNDguNTcwMyBMMzU0LjY3ODEsNTA0OC41NzAzIEMzNjkuNjc4MSw1MDQ4LjU3MDMgMzY5LjY3ODEsNjAwNS42MTcyIDM4NC42NzgxLDYwMDUuNjE3MiBMMzk0LjY3ODEsNjAwNS42MTcyICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTIzOS45OTk0LDQ3MTAuNzg5MSBMMjQ5Ljk5OTQsNDcxMC43ODkxIEMyNjQuOTk5NCw0NzEwLjc4OTEgMjY0Ljk5OTQsNTA0OC41NzAzIDI3OS45OTk0LDUwNDguNTcwMyBMMjg5Ljk5OTQsNTA0OC41NzAzICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9Ijk0Ljk0MjQiIHg9IjI4OS45OTk0IiB5PSI2MjY4Ljk1MzEiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI3NC45NDI0IiB4PSIyOTkuOTk5NCIgeT0iNjI5MS45NDgyIj5UeXBlU2NyaXB0PC90ZXh0PjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxNjQuOTQyMSIgeD0iNDM0Ljk0MTgiIHk9IjYxMDAuMDYyNSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjE0NC45NDIxIiB4PSI0NDQuOTQxOCIgeT0iNjEyMy4wNTc2Ij5UeXBlU2NyaXB0JiMzMDM0MDsmIzIyNTIyOyYjMjY0MTI7JiMzNTgyMTsmIzI3ODYxOzwvdGV4dD48cGF0aCBkPSJNMzg0Ljk0MTgsNjI4Ny4xMDE2IEwzOTQuOTQxOCw2Mjg3LjEwMTYgQzQwOS45NDE4LDYyODcuMTAxNiA0MDkuOTQxOCw2MTE4LjIxMDkgNDI0Ljk0MTgsNjExOC4yMTA5IEw0MzQuOTQxOCw2MTE4LjIxMDkgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iNzUuOTk5OCIgeD0iNDM0Ljk0MTgiIHk9IjYxNTYuMzU5NCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjU1Ljk5OTgiIHg9IjQ0NC45NDE4IiB5PSI2MTc5LjM1NDUiPiYjMzE4Njc7JiMyMjQxMTsmIzIzNDUwOyYjMjAwNDE7PC90ZXh0PjxwYXRoIGQ9Ik0zODQuOTQxOCw2Mjg3LjEwMTYgTDM5NC45NDE4LDYyODcuMTAxNiBDNDA5Ljk0MTgsNjI4Ny4xMDE2IDQwOS45NDE4LDYxNzQuNTA3OCA0MjQuOTQxOCw2MTc0LjUwNzggTDQzNC45NDE4LDYxNzQuNTA3OCAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxMTcuOTk5NiIgeD0iNDM0Ljk0MTgiIHk9IjYyMTIuNjU2MyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9Ijk3Ljk5OTYiIHg9IjQ0NC45NDE4IiB5PSI2MjM1LjY1MTQiPiYjMjU1MDk7JiMyMTQ3NTsmIzE5OTgyOyYjMzE4Njc7JiMyMjQxMTsmIzIxMDM1OyYjMjE1MTc7PC90ZXh0PjxwYXRoIGQ9Ik0zODQuOTQxOCw2Mjg3LjEwMTYgTDM5NC45NDE4LDYyODcuMTAxNiBDNDA5Ljk0MTgsNjI4Ny4xMDE2IDQwOS45NDE4LDYyMzAuODA0NyA0MjQuOTQxOCw2MjMwLjgwNDcgTDQzNC45NDE4LDYyMzAuODA0NyAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSI3NS45OTk4IiB4PSI0MzQuOTQxOCIgeT0iNjI2OC45NTMxIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNTUuOTk5OCIgeD0iNDQ0Ljk0MTgiIHk9IjYyOTEuOTQ4MiI+JiMzMTg2NzsmIzE5OTgyOyYjMzI0ODc7JiMyNTIxNTs8L3RleHQ+PHBhdGggZD0iTTM4NC45NDE4LDYyODcuMTAxNiBMMzk0Ljk0MTgsNjI4Ny4xMDE2IEM0MDkuOTQxOCw2Mjg3LjEwMTYgNDA5Ljk0MTgsNjI4Ny4xMDE2IDQyNC45NDE4LDYyODcuMTAxNiBMNDM0Ljk0MTgsNjI4Ny4xMDE2ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjQ3Ljk5OTkiIHg9IjQzNC45NDE4IiB5PSI2MzI1LjI1Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMjcuOTk5OSIgeD0iNDQ0Ljk0MTgiIHk9IjYzNDguMjQ1MSI+JiMyNzg2NzsmIzIyNDExOzwvdGV4dD48cGF0aCBkPSJNMzg0Ljk0MTgsNjI4Ny4xMDE2IEwzOTQuOTQxOCw2Mjg3LjEwMTYgQzQwOS45NDE4LDYyODcuMTAxNiA0MDkuOTQxOCw2MzQzLjM5ODQgNDI0Ljk0MTgsNjM0My4zOTg0IEw0MzQuOTQxOCw2MzQzLjM5ODQgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iNzUuOTk5OCIgeD0iNDM0Ljk0MTgiIHk9IjYzODEuNTQ2OSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjU1Ljk5OTgiIHg9IjQ0NC45NDE4IiB5PSI2NDA0LjU0MiI+JiMyNzE2OTsmIzIyMzU5OyYjMzE5OTU7JiMzMjQ3OTs8L3RleHQ+PHBhdGggZD0iTTM4NC45NDE4LDYyODcuMTAxNiBMMzk0Ljk0MTgsNjI4Ny4xMDE2IEM0MDkuOTQxOCw2Mjg3LjEwMTYgNDA5Ljk0MTgsNjM5OS42OTUzIDQyNC45NDE4LDYzOTkuNjk1MyBMNDM0Ljk0MTgsNjM5OS42OTUzICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjE5NS44MTMyIiB4PSI0MzQuOTQxOCIgeT0iNjQzNy44NDM4Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTc1LjgxMzIiIHg9IjQ0NC45NDE4IiB5PSI2NDYwLjgzODkiPiYjMjIzMTI7VnVlIDMgJiMyMDAxMzsmIzIwMzUxOyYjMjk5OTI7VHlwZVNjcmlwdDwvdGV4dD48cGF0aCBkPSJNMzg0Ljk0MTgsNjI4Ny4xMDE2IEwzOTQuOTQxOCw2Mjg3LjEwMTYgQzQwOS45NDE4LDYyODcuMTAxNiA0MDkuOTQxOCw2NDU1Ljk5MjIgNDI0Ljk0MTgsNjQ1NS45OTIyIEw0MzQuOTQxOCw2NDU1Ljk5MjIgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNMjM5Ljk5OTQsNDcxMC43ODkxIEwyNDkuOTk5NCw0NzEwLjc4OTEgQzI2NC45OTk0LDQ3MTAuNzg5MSAyNjQuOTk5NCw2Mjg3LjEwMTYgMjc5Ljk5OTQsNjI4Ny4xMDE2IEwyODkuOTk5NCw2Mjg3LjEwMTYgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNMTEzLjk5OTYsNDU3MC4wNDY5IEwxMjMuOTk5Niw0NTcwLjA0NjkgQzEzOC45OTk2LDQ1NzAuMDQ2OSAxMzguOTk5Niw0NzEwLjc4OTEgMTUzLjk5OTYsNDcxMC43ODkxIEwxNjMuOTk5Niw0NzEwLjc4OTEgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iNzUuOTk5OCIgeD0iMTYzLjk5OTYiIHk9IjY5NzIuNjY0MSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjU1Ljk5OTgiIHg9IjE3My45OTk2IiB5PSI2OTk1LjY1OTIiPiYjMjM0NTQ7JiMzODQ2OTsmIzI2Njk2OyYjMjAzNjM7PC90ZXh0PjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSI3NS45OTk4IiB4PSIyODkuOTk5NCIgeT0iNjUyMi4yODkxIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNTUuOTk5OCIgeD0iMjk5Ljk5OTQiIHk9IjY1NDUuMjg0MiI+JiMyNDAzNzsmIzMxMjQzOyYjMzI0Njc7JiMyNjUwMDs8L3RleHQ+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjEwMy45OTk2IiB4PSI0MTUuOTk5MSIgeT0iNjQ5NC4xNDA2Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iODMuOTk5NiIgeD0iNDI1Ljk5OTEiIHk9IjY1MTcuMTM1NyI+JiMzOTAzMzsmIzMwNDQ2OyYjMzA0NDY7JiMyNDQwNTsmIzMyNDY3OyYjMjY1MDA7PC90ZXh0PjxwYXRoIGQ9Ik0zNjUuOTk5MSw2NTQwLjQzNzUgTDM3NS45OTkxLDY1NDAuNDM3NSBDMzkwLjk5OTEsNjU0MC40Mzc1IDM5MC45OTkxLDY1MTIuMjg5MSA0MDUuOTk5MSw2NTEyLjI4OTEgTDQxNS45OTkxLDY1MTIuMjg5MSAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxMDMuOTk5NiIgeD0iNDE1Ljk5OTEiIHk9IjY1NTAuNDM3NSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjgzLjk5OTYiIHg9IjQyNS45OTkxIiB5PSI2NTczLjQzMjYiPiYjMzczMjU7JiMzNTIwMTsmIzI1OTkxOyYjMjAyMTQ7JiMyMDE3MTsmIzMyNDYxOzwvdGV4dD48cGF0aCBkPSJNMzY1Ljk5OTEsNjU0MC40Mzc1IEwzNzUuOTk5MSw2NTQwLjQzNzUgQzM5MC45OTkxLDY1NDAuNDM3NSAzOTAuOTk5MSw2NTY4LjU4NTkgNDA1Ljk5OTEsNjU2OC41ODU5IEw0MTUuOTk5MSw2NTY4LjU4NTkgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNMjM5Ljk5OTQsNjk5MC44MTI1IEwyNDkuOTk5NCw2OTkwLjgxMjUgQzI2NC45OTk0LDY5OTAuODEyNSAyNjQuOTk5NCw2NTQwLjQzNzUgMjc5Ljk5OTQsNjU0MC40Mzc1IEwyODkuOTk5NCw2NTQwLjQzNzUgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iNzUuOTk5OCIgeD0iMjg5Ljk5OTQiIHk9IjcwMjguOTYwOSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjU1Ljk5OTgiIHg9IjI5OS45OTk0IiB5PSI3MDUxLjk1NjEiPiYjMjQzMjA7JiMyMTQ1NzsmIzIxMTUxOyYjMzMwMjE7PC90ZXh0PjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSI3NS45OTk4IiB4PSI0MTUuOTk5MSIgeT0iNjY5MS4xNzk3Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNTUuOTk5OCIgeD0iNDI1Ljk5OTEiIHk9IjY3MTQuMTc0OCI+JiMzNjMzNTsmIzMwMDAxOyYjMjEwMTk7JiMyNDMxNDs8L3RleHQ+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjEwMy45OTk2IiB4PSI1NDEuOTk4OSIgeT0iNjYwNi43MzQ0Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iODMuOTk5NiIgeD0iNTUxLjk5ODkiIHk9IjY2MjkuNzI5NSI+JiMyMTA2OTsmIzMxNDcxOyYjMzYzMzU7JiMzMDAwMTsmIzI3MDEwOyYjMjQ1NjU7PC90ZXh0PjxwYXRoIGQ9Ik00OTEuOTk4OSw2NzA5LjMyODEgTDUwMS45OTg5LDY3MDkuMzI4MSBDNTE2Ljk5ODksNjcwOS4zMjgxIDUxNi45OTg5LDY2MjQuODgyOCA1MzEuOTk4OSw2NjI0Ljg4MjggTDU0MS45OTg5LDY2MjQuODgyOCAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxMzAuOTg4MiIgeD0iNTQxLjk5ODkiIHk9IjY2NjMuMDMxMyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjExMC45ODgyIiB4PSI1NTEuOTk4OSIgeT0iNjY4Ni4wMjY0Ij5WdWUgUm91dGVyICYjMjI1MjI7JiMzMDc4NDs8L3RleHQ+PHBhdGggZD0iTTQ5MS45OTg5LDY3MDkuMzI4MSBMNTAxLjk5ODksNjcwOS4zMjgxIEM1MTYuOTk4OSw2NzA5LjMyODEgNTE2Ljk5ODksNjY4MS4xNzk3IDUzMS45OTg5LDY2ODEuMTc5NyBMNTQxLjk5ODksNjY4MS4xNzk3ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjE1NC44OTk4IiB4PSI1NDEuOTk4OSIgeT0iNjcxOS4zMjgxIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTM0Ljg5OTgiIHg9IjU1MS45OTg5IiB5PSI2NzQyLjMyMzIiPiYjMjExNjA7JiMyNDU3NzsmIzM2MzM1OyYjMzAwMDE7ICYjMTk5ODI7ICYjMjM4ODQ7JiMyMjg3MTsmIzM2MzM1OyYjMzAwMDE7PC90ZXh0PjxwYXRoIGQ9Ik00OTEuOTk4OSw2NzA5LjMyODEgTDUwMS45OTg5LDY3MDkuMzI4MSBDNTE2Ljk5ODksNjcwOS4zMjgxIDUxNi45OTg5LDY3MzcuNDc2NiA1MzEuOTk4OSw2NzM3LjQ3NjYgTDU0MS45OTg5LDY3MzcuNDc2NiAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxMzEuOTk5NSIgeD0iNTQxLjk5ODkiIHk9IjY3NzUuNjI1Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTExLjk5OTUiIHg9IjU1MS45OTg5IiB5PSI2Nzk4LjYyMDEiPiYjMzYzMzU7JiMzMDAwMTsmIzIzNDMyOyYjMjEzNTU7JiMxOTk4MjsmIzI1MDQyOyYjMjExNTI7JiMzNjczMzs8L3RleHQ+PHBhdGggZD0iTTQ5MS45OTg5LDY3MDkuMzI4MSBMNTAxLjk5ODksNjcwOS4zMjgxIEM1MTYuOTk4OSw2NzA5LjMyODEgNTE2Ljk5ODksNjc5My43NzM0IDUzMS45OTg5LDY3OTMuNzczNCBMNTQxLjk5ODksNjc5My43NzM0ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTM2NS45OTkxLDcwNDcuMTA5NCBMMzc1Ljk5OTEsNzA0Ny4xMDk0IEMzOTAuOTk5MSw3MDQ3LjEwOTQgMzkwLjk5OTEsNjcwOS4zMjgxIDQwNS45OTkxLDY3MDkuMzI4MSBMNDE1Ljk5OTEsNjcwOS4zMjgxICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9Ijc1Ljk5OTgiIHg9IjQxNS45OTkxIiB5PSI2ODg4LjIxODgiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI1NS45OTk4IiB4PSI0MjUuOTk5MSIgeT0iNjkxMS4yMTM5Ij4mIzM5MDI5OyYjMzg3NTQ7JiMyNTY0NTsmIzI0MzE0OzwvdGV4dD48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iNzUuOTk5OCIgeD0iNTQxLjk5ODkiIHk9IjY4MzEuOTIxOSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjU1Ljk5OTgiIHg9IjU1MS45OTg5IiB5PSI2ODU0LjkxNyI+JiMyNDA2NzsmIzIzNjE2OyYjMzI0NTI7JiMyMDIxNDs8L3RleHQ+PHBhdGggZD0iTTQ5MS45OTg5LDY5MDYuMzY3MiBMNTAxLjk5ODksNjkwNi4zNjcyIEM1MTYuOTk4OSw2OTA2LjM2NzIgNTE2Ljk5ODksNjg1MC4wNzAzIDUzMS45OTg5LDY4NTAuMDcwMyBMNTQxLjk5ODksNjg1MC4wNzAzICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9Ijg5Ljk5OTciIHg9IjU0MS45OTg5IiB5PSI2ODg4LjIxODgiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI2OS45OTk3IiB4PSI1NTEuOTk4OSIgeT0iNjkxMS4yMTM5Ij4mIzI3MTY5OyYjMjkyNTY7JiMxOTk4MjsmIzI1NTU0OyYjMjcxMzM7PC90ZXh0PjxwYXRoIGQ9Ik00OTEuOTk4OSw2OTA2LjM2NzIgTDUwMS45OTg5LDY5MDYuMzY3MiBDNTE2Ljk5ODksNjkwNi4zNjcyIDUxNi45OTg5LDY5MDYuMzY3MiA1MzEuOTk4OSw2OTA2LjM2NzIgTDU0MS45OTg5LDY5MDYuMzY3MiAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSI4OS45OTk3IiB4PSI1NDEuOTk4OSIgeT0iNjk0NC41MTU2Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNjkuOTk5NyIgeD0iNTUxLjk5ODkiIHk9IjY5NjcuNTEwNyI+JiMyMTcwOTsmIzI0MjEyOyYjMjQzMzU7JiMzNTc3NDsmIzM1NzQ1OzwvdGV4dD48cGF0aCBkPSJNNDkxLjk5ODksNjkwNi4zNjcyIEw1MDEuOTk4OSw2OTA2LjM2NzIgQzUxNi45OTg5LDY5MDYuMzY3MiA1MTYuOTk4OSw2OTYyLjY2NDEgNTMxLjk5ODksNjk2Mi42NjQxIEw1NDEuOTk4OSw2OTYyLjY2NDEgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNMzY1Ljk5OTEsNzA0Ny4xMDk0IEwzNzUuOTk5MSw3MDQ3LjEwOTQgQzM5MC45OTkxLDcwNDcuMTA5NCAzOTAuOTk5MSw2OTA2LjM2NzIgNDA1Ljk5OTEsNjkwNi4zNjcyIEw0MTUuOTk5MSw2OTA2LjM2NzIgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iNzUuOTk5OCIgeD0iNDE1Ljk5OTEiIHk9IjcxMTMuNDA2MyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjU1Ljk5OTgiIHg9IjQyNS45OTkxIiB5PSI3MTM2LjQwMTQiPiYjMzI0NTI7JiMyMDIxNDsmIzI0MzQxOyYjMjk5OTI7PC90ZXh0PjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSI3NS45OTk4IiB4PSI1NDEuOTk4OSIgeT0iNzA1Ny4xMDk0Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNTUuOTk5OCIgeD0iNTUxLjk5ODkiIHk9IjcwODAuMTA0NSI+JiMyMDg2OTsmIzM3MDk2OyYjMzI0NTI7JiMyMDIxNDs8L3RleHQ+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjExNy45OTk2IiB4PSI2NjcuOTk4NyIgeT0iNzAwMC44MTI1Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTcuOTk5NiIgeD0iNjc3Ljk5ODciIHk9IjcwMjMuODA3NiI+JiMzMjQ1MjsmIzIwMjE0OyYjMjM0NTA7JiMyMDA0MTsmIzE5OTgyOyYjMjc4ODA7JiMyMDg3Njs8L3RleHQ+PHBhdGggZD0iTTYxNy45OTg3LDcwNzUuMjU3OCBMNjI3Ljk5ODcsNzA3NS4yNTc4IEM2NDIuOTk4Nyw3MDc1LjI1NzggNjQyLjk5ODcsNzAxOC45NjA5IDY1Ny45OTg3LDcwMTguOTYwOSBMNjY3Ljk5ODcsNzAxOC45NjA5ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjIwOC44NDIzIiB4PSI2NjcuOTk4NyIgeT0iNzA1Ny4xMDk0Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTg4Ljg0MjMiIHg9IjY3Ny45OTg3IiB5PSI3MDgwLjEwNDUiPiYjMjkyMzg7JiMyMzM3NjsmIzMyNDUyOyYjMjAyMTQ7JiMzNjg5MDsmIzIwNDQ5Oyhwcm9wcyAmIzE5OTgyOyBlbWl0KTwvdGV4dD48cGF0aCBkPSJNNjE3Ljk5ODcsNzA3NS4yNTc4IEw2MjcuOTk4Nyw3MDc1LjI1NzggQzY0Mi45OTg3LDcwNzUuMjU3OCA2NDIuOTk4Nyw3MDc1LjI1NzggNjU3Ljk5ODcsNzA3NS4yNTc4IEw2NjcuOTk4Nyw3MDc1LjI1NzggIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iODkuOTk5NyIgeD0iNjY3Ljk5ODciIHk9IjcxMTMuNDA2MyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjY5Ljk5OTciIHg9IjY3Ny45OTg3IiB5PSI3MTM2LjQwMTQiPiYjMjU1NTQ7JiMyNzEzMzsmIzMwMzQwOyYjMjAzNTE7JiMyOTk5Mjs8L3RleHQ+PHBhdGggZD0iTTYxNy45OTg3LDcwNzUuMjU3OCBMNjI3Ljk5ODcsNzA3NS4yNTc4IEM2NDIuOTk4Nyw3MDc1LjI1NzggNjQyLjk5ODcsNzEzMS41NTQ3IDY1Ny45OTg3LDcxMzEuNTU0NyBMNjY3Ljk5ODcsNzEzMS41NTQ3ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTQ5MS45OTg5LDcxMzEuNTU0NyBMNTAxLjk5ODksNzEzMS41NTQ3IEM1MTYuOTk4OSw3MTMxLjU1NDcgNTE2Ljk5ODksNzA3NS4yNTc4IDUzMS45OTg5LDcwNzUuMjU3OCBMNTQxLjk5ODksNzA3NS4yNTc4ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9Ijg5Ljk5OTciIHg9IjU0MS45OTg5IiB5PSI3MTk3Ljg1MTYiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI2OS45OTk3IiB4PSI1NTEuOTk4OSIgeT0iNzIyMC44NDY3Ij4mIzMxNTMyOyYjMTk5Nzc7JiMyNjA0MTsmIzMyNDUyOyYjMjAyMTQ7PC90ZXh0PjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIzNDkuNjAxIiB4PSI2ODEuOTk4NiIgeT0iNzE2OS43MDMxIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMzI5LjYwMSIgeD0iNjkxLjk5ODYiIHk9IjcxOTIuNjk4MiI+JiMyMDM1MTsmIzI5OTkyOyYjMzE1MzI7JiMxOTk3NzsmIzI2MDQxOyYjMzI0NTI7JiMyMDIxNDsmIzI0MjExOyBFbGVtZW50IFBsdXMmIzEyMjg5O0FudCBEZXNpZ24gVnVlPC90ZXh0PjxwYXRoIGQ9Ik02MzEuOTk4Niw3MjE2IEw2NDEuOTk4Niw3MjE2IEM2NTYuOTk4Niw3MjE2IDY1Ni45OTg2LDcxODcuODUxNiA2NzEuOTk4Niw3MTg3Ljg1MTYgTDY4MS45OTg2LDcxODcuODUxNiAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSI4OS45OTk3IiB4PSI2ODEuOTk4NiIgeT0iNzIyNiIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjY5Ljk5OTciIHg9IjY5MS45OTg2IiB5PSI3MjQ4Ljk5NTEiPiYjMzMyNTg7JiMyMzQ1MDsmIzIwMDQxOyYjMjAwMjc7JiMzOTA2NDs8L3RleHQ+PHBhdGggZD0iTTYzMS45OTg2LDcyMTYgTDY0MS45OTg2LDcyMTYgQzY1Ni45OTg2LDcyMTYgNjU2Ljk5ODYsNzI0NC4xNDg0IDY3MS45OTg2LDcyNDQuMTQ4NCBMNjgxLjk5ODYsNzI0NC4xNDg0ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTQ5MS45OTg5LDcxMzEuNTU0NyBMNTAxLjk5ODksNzEzMS41NTQ3IEM1MTYuOTk4OSw3MTMxLjU1NDcgNTE2Ljk5ODksNzIxNiA1MzEuOTk4OSw3MjE2IEw1NDEuOTk4OSw3MjE2ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTM2NS45OTkxLDcwNDcuMTA5NCBMMzc1Ljk5OTEsNzA0Ny4xMDk0IEMzOTAuOTk5MSw3MDQ3LjEwOTQgMzkwLjk5OTEsNzEzMS41NTQ3IDQwNS45OTkxLDcxMzEuNTU0NyBMNDE1Ljk5OTEsNzEzMS41NTQ3ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9Ijc1Ljk5OTgiIHg9IjQxNS45OTkxIiB5PSI3MzY2Ljc0MjIiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI1NS45OTk4IiB4PSI0MjUuOTk5MSIgeT0iNzM4OS43MzczIj4mIzI1NTA5OyYjMjE0NzU7JiMzNTgzMTsmIzI3NzE0OzwvdGV4dD48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iNTcuNjExMyIgeD0iNTQxLjk5ODkiIHk9IjczNjYuNzQyMiIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjM3LjYxMTMiIHg9IjU1MS45OTg5IiB5PSI3Mzg5LjczNzMiPkF4aW9zPC90ZXh0PjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxMzIuMDYxMiIgeD0iNjQ5LjYxMDIiIHk9IjcyODIuMjk2OSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjExMi4wNjEyIiB4PSI2NTkuNjEwMiIgeT0iNzMwNS4yOTIiPkF4aW9zICYjMzAzNDA7JiMyMjUyMjsmIzI2NDEyOyYjMjAzNTE7JiMyOTk5Mjs8L3RleHQ+PHBhdGggZD0iTTU5OS42MTAyLDczODQuODkwNiBMNjA5LjYxMDIsNzM4NC44OTA2IEM2MjQuNjEwMiw3Mzg0Ljg5MDYgNjI0LjYxMDIsNzMwMC40NDUzIDYzOS42MTAyLDczMDAuNDQ1MyBMNjQ5LjYxMDIsNzMwMC40NDUzICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjExOC4wNjEzIiB4PSI2NDkuNjEwMiIgeT0iNzMzOC41OTM4Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTguMDYxMyIgeD0iNjU5LjYxMDIiIHk9IjczNjEuNTg4OSI+JiMyMTAxOTsmIzI0MzE0O0F4aW9zICYjMjM0NTQ7JiMyMDM2Mzs8L3RleHQ+PHBhdGggZD0iTTU5OS42MTAyLDczODQuODkwNiBMNjA5LjYxMDIsNzM4NC44OTA2IEM2MjQuNjEwMiw3Mzg0Ljg5MDYgNjI0LjYxMDIsNzM1Ni43NDIyIDYzOS42MTAyLDczNTYuNzQyMiBMNjQ5LjYxMDIsNzM1Ni43NDIyICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjEwMy45OTk2IiB4PSI2NDkuNjEwMiIgeT0iNzM5NC44OTA2Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iODMuOTk5NiIgeD0iNjU5LjYxMDIiIHk9Ijc0MTcuODg1NyI+JiMyNTMxODsmIzI1MTMwOyYjMjIxMjA7JiMzMDM0MDsmIzIwMzUxOyYjMjk5OTI7PC90ZXh0PjxwYXRoIGQ9Ik01OTkuNjEwMiw3Mzg0Ljg5MDYgTDYwOS42MTAyLDczODQuODkwNiBDNjI0LjYxMDIsNzM4NC44OTA2IDYyNC42MTAyLDc0MTMuMDM5MSA2MzkuNjEwMiw3NDEzLjAzOTEgTDY0OS42MTAyLDc0MTMuMDM5MSAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSI3NS45OTk4IiB4PSI2NDkuNjEwMiIgeT0iNzQ1MS4xODc1Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNTUuOTk5OCIgeD0iNjU5LjYxMDIiIHk9Ijc0NzQuMTgyNiI+JiMyNDMyMjsmIzI0MTIwOyYjMjI3ODg7JiMyOTcwMjs8L3RleHQ+PHBhdGggZD0iTTU5OS42MTAyLDczODQuODkwNiBMNjA5LjYxMDIsNzM4NC44OTA2IEM2MjQuNjEwMiw3Mzg0Ljg5MDYgNjI0LjYxMDIsNzQ2OS4zMzU5IDYzOS42MTAyLDc0NjkuMzM1OSBMNjQ5LjYxMDIsNzQ2OS4zMzU5ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTQ5MS45OTg5LDczODQuODkwNiBMNTAxLjk5ODksNzM4NC44OTA2IEM1MTYuOTk4OSw3Mzg0Ljg5MDYgNTE2Ljk5ODksNzM4NC44OTA2IDUzMS45OTg5LDczODQuODkwNiBMNTQxLjk5ODksNzM4NC44OTA2ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTM2NS45OTkxLDcwNDcuMTA5NCBMMzc1Ljk5OTEsNzA0Ny4xMDk0IEMzOTAuOTk5MSw3MDQ3LjEwOTQgMzkwLjk5OTEsNzM4NC44OTA2IDQwNS45OTkxLDczODQuODkwNiBMNDE1Ljk5OTEsNzM4NC44OTA2ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTIzOS45OTk0LDY5OTAuODEyNSBMMjQ5Ljk5OTQsNjk5MC44MTI1IEMyNjQuOTk5NCw2OTkwLjgxMjUgMjY0Ljk5OTQsNzA0Ny4xMDk0IDI3OS45OTk0LDcwNDcuMTA5NCBMMjg5Ljk5OTQsNzA0Ny4xMDk0ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTExMy45OTk2LDQ1NzAuMDQ2OSBMMTIzLjk5OTYsNDU3MC4wNDY5IEMxMzguOTk5Niw0NTcwLjA0NjkgMTM4Ljk5OTYsNjk5MC44MTI1IDE1My45OTk2LDY5OTAuODEyNSBMMTYzLjk5OTYsNjk5MC44MTI1ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9Ijg5Ljk5OTciIHg9IjE2My45OTk2IiB5PSI4Mjk1LjY0MDYiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI2OS45OTk3IiB4PSIxNzMuOTk5NiIgeT0iODMxOC42MzU3Ij4mIzI3OTgzOyYjMzUyNzI7JiMyMjEyMDsmIzM1ODQzOyYjMzU3OTc7PC90ZXh0PjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSI3NS45OTk4IiB4PSIzMDMuOTk5MyIgeT0iNzU5MS45Mjk3Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNTUuOTk5OCIgeD0iMzEzLjk5OTMiIHk9Ijc2MTQuOTI0OCI+JiMyMDE5NTsmIzMwNzIxOyYjMzU4NDM7JiMzNTc5Nzs8L3RleHQ+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjE1OS45OTk0IiB4PSI0MjkuOTk5MSIgeT0iNzUwNy40ODQ0Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTM5Ljk5OTQiIHg9IjQzOS45OTkxIiB5PSI3NTMwLjQ3OTUiPiYjMjAzNTE7JiMyOTk5MjsmIzI3OTgzOyYjMzUyNzI7JiMyMjEyMDsmIzI0MzIwOyYjMjE0NTc7JiMzMjc3MzsmIzI0MDM3OyYjMjA4NTU7PC90ZXh0PjxwYXRoIGQ9Ik0zNzkuOTk5MSw3NjEwLjA3ODEgTDM4OS45OTkxLDc2MTAuMDc4MSBDNDA0Ljk5OTEsNzYxMC4wNzgxIDQwNC45OTkxLDc1MjUuNjMyOCA0MTkuOTk5MSw3NTI1LjYzMjggTDQyOS45OTkxLDc1MjUuNjMyOCAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSI3NS45OTk4IiB4PSI0MjkuOTk5MSIgeT0iNzU2My43ODEzIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iNTUuOTk5OCIgeD0iNDM5Ljk5OTEiIHk9Ijc1ODYuNzc2NCI+JiMyNjAyOTsmIzI4ODU3OyYjMzU4NDM7JiMzNTc5Nzs8L3RleHQ+PHBhdGggZD0iTTM3OS45OTkxLDc2MTAuMDc4MSBMMzg5Ljk5OTEsNzYxMC4wNzgxIEM0MDQuOTk5MSw3NjEwLjA3ODEgNDA0Ljk5OTEsNzU4MS45Mjk3IDQxOS45OTkxLDc1ODEuOTI5NyBMNDI5Ljk5OTEsNzU4MS45Mjk3ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9Ijc1Ljk5OTgiIHg9IjQyOS45OTkxIiB5PSI3NjIwLjA3ODEiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI1NS45OTk4IiB4PSI0MzkuOTk5MSIgeT0iNzY0My4wNzMyIj4mIzIxNDY0OyYjMzczMjc7JiMzMDQxNzsmIzM1MjcwOzwvdGV4dD48cGF0aCBkPSJNMzc5Ljk5OTEsNzYxMC4wNzgxIEwzODkuOTk5MSw3NjEwLjA3ODEgQzQwNC45OTkxLDc2MTAuMDc4MSA0MDQuOTk5MSw3NjM4LjIyNjYgNDE5Ljk5OTEsNzYzOC4yMjY2IEw0MjkuOTk5MSw3NjM4LjIyNjYgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTE5Ljk0ODEiIHg9IjQyOS45OTkxIiB5PSI3Njc2LjM3NSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9Ijk5Ljk0ODEiIHg9IjQzOS45OTkxIiB5PSI3Njk5LjM3MDEiPmNvbnNvbGUgJiMzMDM0MDsmIzIwMzUxOyYjMjk5OTI7PC90ZXh0PjxwYXRoIGQ9Ik0zNzkuOTk5MSw3NjEwLjA3ODEgTDM4OS45OTkxLDc2MTAuMDc4MSBDNDA0Ljk5OTEsNzYxMC4wNzgxIDQwNC45OTkxLDc2OTQuNTIzNCA0MTkuOTk5MSw3Njk0LjUyMzQgTDQyOS45OTkxLDc2OTQuNTIzNCAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik0yNTMuOTk5Myw4MzEzLjc4OTEgTDI2My45OTkzLDgzMTMuNzg5MSBDMjc4Ljk5OTMsODMxMy43ODkxIDI3OC45OTkzLDc2MTAuMDc4MSAyOTMuOTk5Myw3NjEwLjA3ODEgTDMwMy45OTkzLDc2MTAuMDc4MSAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxNDkuNjcwNiIgeD0iMzAzLjk5OTMiIHk9Ijg0MDguMjM0NCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjEyOS42NzA2IiB4PSIzMTMuOTk5MyIgeT0iODQzMS4yMjk1Ij5DaHJvbWUgJiMyNzk4MzsmIzM1MjcyOyYjMjIxMjA7JiMzNTg0MzsmIzM1Nzk3OzwvdGV4dD48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTE2Ljk5NSIgeD0iNTAzLjY2OTkiIHk9Ijc3NjAuODIwMyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9Ijk2Ljk5NSIgeD0iNTEzLjY2OTkiIHk9Ijc3ODMuODE1NCI+RGV2VG9vbHMgJiMyNzAxMDsmIzM2ODQ4OzwvdGV4dD48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTU4Ljk5NDgiIHg9IjY3MC42NjQ5IiB5PSI3NzMyLjY3MTkiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxMzguOTk0OCIgeD0iNjgwLjY2NDkiIHk9Ijc3NTUuNjY3Ij4mIzI1MTcxOyYjMjQzMjA7RGV2VG9vbHMgJiMzMDM0MDsmIzI2MDQxOyYjMjc4NjE7PC90ZXh0PjxwYXRoIGQ9Ik02MjAuNjY0OSw3Nzc4Ljk2ODggTDYzMC42NjQ5LDc3NzguOTY4OCBDNjQ1LjY2NDksNzc3OC45Njg4IDY0NS42NjQ5LDc3NTAuODIwMyA2NjAuNjY0OSw3NzUwLjgyMDMgTDY3MC42NjQ5LDc3NTAuODIwMyAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxNDQuOTk0OSIgeD0iNjcwLjY2NDkiIHk9Ijc3ODguOTY4OCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjEyNC45OTQ5IiB4PSI2ODAuNjY0OSIgeT0iNzgxMS45NjM5Ij5EZXZUb29scyAmIzMwMDI4OyYjMzg3NTQ7JiMyMDE3MTsmIzMyNDYxOzwvdGV4dD48cGF0aCBkPSJNNjIwLjY2NDksNzc3OC45Njg4IEw2MzAuNjY0OSw3Nzc4Ljk2ODggQzY0NS42NjQ5LDc3NzguOTY4OCA2NDUuNjY0OSw3ODA3LjExNzIgNjYwLjY2NDksNzgwNy4xMTcyIEw2NzAuNjY0OSw3ODA3LjExNzIgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNNDUzLjY2OTksODQyNi4zODI4IEw0NjMuNjY5OSw4NDI2LjM4MjggQzQ3OC42Njk5LDg0MjYuMzgyOCA0NzguNjY5OSw3Nzc4Ljk2ODggNDkzLjY2OTksNzc3OC45Njg4IEw1MDMuNjY5OSw3Nzc4Ljk2ODggIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTE3LjcwNTkiIHg9IjUwMy42Njk5IiB5PSI3OTAxLjU2MjUiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI5Ny43MDU5IiB4PSI1MTMuNjY5OSIgeT0iNzkyNC41NTc2Ij5FbGVtZW50cyAmIzM4NzU0OyYjMjY0OTU7PC90ZXh0PjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxMzcuODc4NSIgeD0iNjcxLjM3NTkiIHk9Ijc4NDUuMjY1NiIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjExNy44Nzg1IiB4PSI2ODEuMzc1OSIgeT0iNzg2OC4yNjA3Ij4mIzI2NTk3OyYjMzA0NzU7JiMyMTY0NDsmIzMyNTM0OyYjMzY3NTM7RE9NJiMyNjY0MTs8L3RleHQ+PHBhdGggZD0iTTYyMS4zNzU5LDc5MTkuNzEwOSBMNjMxLjM3NTksNzkxOS43MTA5IEM2NDYuMzc1OSw3OTE5LjcxMDkgNjQ2LjM3NTksNzg2My40MTQxIDY2MS4zNzU5LDc4NjMuNDE0MSBMNjcxLjM3NTksNzg2My40MTQxICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjExNy45OTk2IiB4PSI2NzEuMzc1OSIgeT0iNzkwMS41NjI1Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iOTcuOTk5NiIgeD0iNjgxLjM3NTkiIHk9Ijc5MjQuNTU3NiI+JiMyMDQ2MjsmIzI1OTEzOyYjMjA4MDM7JiMzMjAzMjsmIzMwMzQwOyYjMjY2Nzk7JiMyNDMzNTs8L3RleHQ+PHBhdGggZD0iTTYyMS4zNzU5LDc5MTkuNzEwOSBMNjMxLjM3NTksNzkxOS43MTA5IEM2NDYuMzc1OSw3OTE5LjcxMDkgNjQ2LjM3NTksNzkxOS43MTA5IDY2MS4zNzU5LDc5MTkuNzEwOSBMNjcxLjM3NTksNzkxOS43MTA5ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9Ijc1LjU0ODciIHg9IjY3MS4zNzU5IiB5PSI3OTU3Ljg1OTQiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI1NS41NDg3IiB4PSI2ODEuMzc1OSIgeT0iNzk4MC44NTQ1Ij4mIzM1ODQzOyYjMzU3OTc7Q1NTPC90ZXh0PjxwYXRoIGQ9Ik02MjEuMzc1OSw3OTE5LjcxMDkgTDYzMS4zNzU5LDc5MTkuNzEwOSBDNjQ2LjM3NTksNzkxOS43MTA5IDY0Ni4zNzU5LDc5NzYuMDA3OCA2NjEuMzc1OSw3OTc2LjAwNzggTDY3MS4zNzU5LDc5NzYuMDA3OCAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik00NTMuNjY5OSw4NDI2LjM4MjggTDQ2My42Njk5LDg0MjYuMzgyOCBDNDc4LjY2OTksODQyNi4zODI4IDQ3OC42Njk5LDc5MTkuNzEwOSA0OTMuNjY5OSw3OTE5LjcxMDkgTDUwMy42Njk5LDc5MTkuNzEwOSAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxMDMuNTc2IiB4PSI1MDMuNjY5OSIgeT0iODA3MC40NTMxIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iODMuNTc2IiB4PSI1MTMuNjY5OSIgeT0iODA5My40NDgyIj5Db25zb2xlJiMzODc1NDsmIzI2NDk1OzwvdGV4dD48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTAzLjk5OTYiIHg9IjY1Ny4yNDYiIHk9IjgwMTQuMTU2MyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjgzLjk5OTYiIHg9IjY2Ny4yNDYiIHk9IjgwMzcuMTUxNCI+JiMzNjc1NTsmIzIwOTg2OyYjMjYwODU7JiMyNDUzNTsmIzIwNDQ5OyYjMjQ2ODc7PC90ZXh0PjxwYXRoIGQ9Ik02MDcuMjQ2LDgwODguNjAxNiBMNjE3LjI0Niw4MDg4LjYwMTYgQzYzMi4yNDYsODA4OC42MDE2IDYzMi4yNDYsODAzMi4zMDQ3IDY0Ny4yNDYsODAzMi4zMDQ3IEw2NTcuMjQ2LDgwMzIuMzA0NyAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxNTUuMDc3OSIgeD0iNjU3LjI0NiIgeT0iODA3MC40NTMxIi8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTM1LjA3NzkiIHg9IjY2Ny4yNDYiIHk9IjgwOTMuNDQ4MiI+JiMyNTE5MTsmIzM0ODkyOyBKYXZhU2NyaXB0ICYjMjAxOTU7JiMzMDcyMTs8L3RleHQ+PHBhdGggZD0iTTYwNy4yNDYsODA4OC42MDE2IEw2MTcuMjQ2LDgwODguNjAxNiBDNjMyLjI0Niw4MDg4LjYwMTYgNjMyLjI0Niw4MDg4LjYwMTYgNjQ3LjI0Niw4MDg4LjYwMTYgTDY1Ny4yNDYsODA4OC42MDE2ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjE0NS45OTk1IiB4PSI2NTcuMjQ2IiB5PSI4MTI2Ljc1Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iMTI1Ljk5OTUiIHg9IjY2Ny4yNDYiIHk9IjgxNDkuNzQ1MSI+JiMyNjU5NzsmIzMwNDc1OyYjMzgxNjk7JiMzNTgyMzsmIzIxNjQ0OyYjMzU2ODY7JiMyMTU3ODsmIzIwNDQ5OyYjMjQ2ODc7PC90ZXh0PjxwYXRoIGQ9Ik02MDcuMjQ2LDgwODguNjAxNiBMNjE3LjI0Niw4MDg4LjYwMTYgQzYzMi4yNDYsODA4OC42MDE2IDYzMi4yNDYsODE0NC44OTg0IDY0Ny4yNDYsODE0NC44OTg0IEw2NTcuMjQ2LDgxNDQuODk4NCAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik00NTMuNjY5OSw4NDI2LjM4MjggTDQ2My42Njk5LDg0MjYuMzgyOCBDNDc4LjY2OTksODQyNi4zODI4IDQ3OC42Njk5LDgwODguNjAxNiA0OTMuNjY5OSw4MDg4LjYwMTYgTDUwMy42Njk5LDgwODguNjAxNiAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxMTAuOTA0MiIgeD0iNTAzLjY2OTkiIHk9IjgyMzkuMzQzOCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjkwLjkwNDIiIHg9IjUxMy42Njk5IiB5PSI4MjYyLjMzODkiPk5ldHdvcmsgJiMzODc1NDsmIzI2NDk1OzwvdGV4dD48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTAzLjk5OTYiIHg9IjY2NC41NzQxIiB5PSI4MTgzLjA0NjkiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI4My45OTk2IiB4PSI2NzQuNTc0MSIgeT0iODIwNi4wNDIiPiYjMjY1OTc7JiMzMDQ3NTsmIzMyNTkzOyYjMzI0NzY7JiMzNTgzMTsmIzI3NzE0OzwvdGV4dD48cGF0aCBkPSJNNjE0LjU3NDEsODI1Ny40OTIyIEw2MjQuNTc0MSw4MjU3LjQ5MjIgQzYzOS41NzQxLDgyNTcuNDkyMiA2MzkuNTc0MSw4MjAxLjE5NTMgNjU0LjU3NDEsODIwMS4xOTUzIEw2NjQuNTc0MSw4MjAxLjE5NTMgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTE3Ljk5OTYiIHg9IjY2NC41NzQxIiB5PSI4MjM5LjM0MzgiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI5Ny45OTk2IiB4PSI2NzQuNTc0MSIgeT0iODI2Mi4zMzg5Ij4mIzM2ODA3OyYjMjgzODg7JiMyMTY0NDsmIzI1NjI4OyYjMzIwMzQ7JiMzNTgzMTsmIzI3NzE0OzwvdGV4dD48cGF0aCBkPSJNNjE0LjU3NDEsODI1Ny40OTIyIEw2MjQuNTc0MSw4MjU3LjQ5MjIgQzYzOS41NzQxLDgyNTcuNDkyMiA2MzkuNTc0MSw4MjU3LjQ5MjIgNjU0LjU3NDEsODI1Ny40OTIyIEw2NjQuNTc0MSw4MjU3LjQ5MjIgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTQ1Ljk5OTUiIHg9IjY2NC41NzQxIiB5PSI4Mjk1LjY0MDYiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxMjUuOTk5NSIgeD0iNjc0LjU3NDEiIHk9IjgzMTguNjM1NyI+JiMyMDk5ODsmIzI2NTEyOyYjMzU4MzE7JiMyNzcxNDsmIzIxNjQ0OyYjMjE3MDk7JiMyNDIxMjsmIzI1OTY4OyYjMjU0NTQ7PC90ZXh0PjxwYXRoIGQ9Ik02MTQuNTc0MSw4MjU3LjQ5MjIgTDYyNC41NzQxLDgyNTcuNDkyMiBDNjM5LjU3NDEsODI1Ny40OTIyIDYzOS41NzQxLDgzMTMuNzg5MSA2NTQuNTc0MSw4MzEzLjc4OTEgTDY2NC41NzQxLDgzMTMuNzg5MSAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxwYXRoIGQ9Ik00NTMuNjY5OSw4NDI2LjM4MjggTDQ2My42Njk5LDg0MjYuMzgyOCBDNDc4LjY2OTksODQyNi4zODI4IDQ3OC42Njk5LDgyNTcuNDkyMiA0OTMuNjY5OSw4MjU3LjQ5MjIgTDUwMy42Njk5LDgyNTcuNDkyMiAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxMzAuNjczNyIgeD0iNTAzLjY2OTkiIHk9Ijg0MDguMjM0NCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjExMC42NzM3IiB4PSI1MTMuNjY5OSIgeT0iODQzMS4yMjk1Ij5BcHBsaWNhdGlvbiAmIzM4NzU0OyYjMjY0OTU7PC90ZXh0PjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSI0ODguNzU5OCIgeD0iNjg0LjM0MzYiIHk9IjgzNTEuOTM3NSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjQ2OC43NTk4IiB4PSI2OTQuMzQzNiIgeT0iODM3NC45MzI2Ij4mIzI2NTk3OyYjMzA0NzU7JiMyMTY0NDsmIzMxNjQ5OyYjMjk3MDI7JiMyNzk4MzsmIzM1MjcyOyYjMjIxMjA7JiMyMzM4NDsmIzIwNjQ4OyYjNjUyODg7TG9jYWxTdG9yYWdlJiMxMjI4OTtTZXNzaW9uU3RvcmFnZSYjMTIyODk7Q29va2llcyAmIzMxNTYxOyYjNjUyODk7PC90ZXh0PjxwYXRoIGQ9Ik02MzQuMzQzNiw4NDI2LjM4MjggTDY0NC4zNDM2LDg0MjYuMzgyOCBDNjU5LjM0MzYsODQyNi4zODI4IDY1OS4zNDM2LDgzNzAuMDg1OSA2NzQuMzQzNiw4MzcwLjA4NTkgTDY4NC4zNDM2LDgzNzAuMDg1OSAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxNTkuMjgyMSIgeD0iNjg0LjM0MzYiIHk9Ijg0MDguMjM0NCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjEzOS4yODIxIiB4PSI2OTQuMzQzNiIgeT0iODQzMS4yMjk1Ij4mIzM1ODQzOyYjMzU3OTc7IFNlcnZpY2UgV29ya2VyPC90ZXh0PjxwYXRoIGQ9Ik02MzQuMzQzNiw4NDI2LjM4MjggTDY0NC4zNDM2LDg0MjYuMzgyOCBDNjU5LjM0MzYsODQyNi4zODI4IDY1OS4zNDM2LDg0MjYuMzgyOCA2NzQuMzQzNiw4NDI2LjM4MjggTDY4NC4zNDM2LDg0MjYuMzgyOCAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxMDMuOTk5NiIgeD0iNjg0LjM0MzYiIHk9Ijg0NjQuNTMxMyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjgzLjk5OTYiIHg9IjY5NC4zNDM2IiB5PSI4NDg3LjUyNjQiPiYjMjA5OTg7JiMyNjUxMjsmIzI0MjEyOyYjMjk5OTI7JiMzMjUzMTsmIzIzMzg0OzwvdGV4dD48cGF0aCBkPSJNNjM0LjM0MzYsODQyNi4zODI4IEw2NDQuMzQzNiw4NDI2LjM4MjggQzY1OS4zNDM2LDg0MjYuMzgyOCA2NTkuMzQzNiw4NDgyLjY3OTcgNjc0LjM0MzYsODQ4Mi42Nzk3IEw2ODQuMzQzNiw4NDgyLjY3OTcgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNNDUzLjY2OTksODQyNi4zODI4IEw0NjMuNjY5OSw4NDI2LjM4MjggQzQ3OC42Njk5LDg0MjYuMzgyOCA0NzguNjY5OSw4NDI2LjM4MjggNDkzLjY2OTksODQyNi4zODI4IEw1MDMuNjY5OSw4NDI2LjM4MjggIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTA4LjEzNTYiIHg9IjUwMy42Njk5IiB5PSI4NjA1LjI3MzQiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI4OC4xMzU2IiB4PSI1MTMuNjY5OSIgeT0iODYyOC4yNjg2Ij5Tb3VyY2VzICYjMzg3NTQ7JiMyNjQ5NTs8L3RleHQ+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9Ijc1Ljk5OTgiIHg9IjY2MS44MDU1IiB5PSI4NTIwLjgyODEiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI1NS45OTk4IiB4PSI2NzEuODA1NSIgeT0iODU0My44MjMyIj4mIzM1Nzc0OyYjMzI2MjI7JiMyNjAyOTsmIzI4ODU3OzwvdGV4dD48cGF0aCBkPSJNNjExLjgwNTUsODYyMy40MjE5IEw2MjEuODA1NSw4NjIzLjQyMTkgQzYzNi44MDU1LDg2MjMuNDIxOSA2MzYuODA1NSw4NTM4Ljk3NjYgNjUxLjgwNTUsODUzOC45NzY2IEw2NjEuODA1NSw4NTM4Ljk3NjYgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTAzLjk5OTYiIHg9IjY2MS44MDU1IiB5PSI4NTc3LjEyNSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjgzLjk5OTYiIHg9IjY3MS44MDU1IiB5PSI4NjAwLjEyMDEiPiYjMjc0OTM7JiMzNjgyNzsmIzI1MTkxOyYjMzQ4OTI7JiMyMDE5NTsmIzMwNzIxOzwvdGV4dD48cGF0aCBkPSJNNjExLjgwNTUsODYyMy40MjE5IEw2MjEuODA1NSw4NjIzLjQyMTkgQzYzNi44MDU1LDg2MjMuNDIxOSA2MzYuODA1NSw4NTk1LjI3MzQgNjUxLjgwNTUsODU5NS4yNzM0IEw2NjEuODA1NSw4NTk1LjI3MzQgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTAzLjk5OTYiIHg9IjY2MS44MDU1IiB5PSI4NjMzLjQyMTkiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI4My45OTk2IiB4PSI2NzEuODA1NSIgeT0iODY1Ni40MTciPiYjMjY1OTc7JiMzMDQ3NTsmIzM1ODQzOyYjMjk5OTI7JiMyMjUzNDsmIzI2NjMyOzwvdGV4dD48cGF0aCBkPSJNNjExLjgwNTUsODYyMy40MjE5IEw2MjEuODA1NSw4NjIzLjQyMTkgQzYzNi44MDU1LDg2MjMuNDIxOSA2MzYuODA1NSw4NjUxLjU3MDMgNjUxLjgwNTUsODY1MS41NzAzIEw2NjEuODA1NSw4NjUxLjU3MDMgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTAzLjk5OTYiIHg9IjY2MS44MDU1IiB5PSI4Njg5LjcxODgiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI4My45OTk2IiB4PSI2NzEuODA1NSIgeT0iODcxMi43MTM5Ij4mIzM1ODQzOyYjMzU3OTc7JiMyNDMyMjsmIzI3NDkzOyYjMjAxOTU7JiMzMDcyMTs8L3RleHQ+PHBhdGggZD0iTTYxMS44MDU1LDg2MjMuNDIxOSBMNjIxLjgwNTUsODYyMy40MjE5IEM2MzYuODA1NSw4NjIzLjQyMTkgNjM2LjgwNTUsODcwNy44NjcyIDY1MS44MDU1LDg3MDcuODY3MiBMNjYxLjgwNTUsODcwNy44NjcyICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHBhdGggZD0iTTQ1My42Njk5LDg0MjYuMzgyOCBMNDYzLjY2OTksODQyNi4zODI4IEM0NzguNjY5OSw4NDI2LjM4MjggNDc4LjY2OTksODYyMy40MjE5IDQ5My42Njk5LDg2MjMuNDIxOSBMNTAzLjY2OTksODYyMy40MjE5ICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjE0MS45MTIiIHg9IjUwMy42Njk5IiB5PSI4ODAyLjMxMjUiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxMjEuOTEyIiB4PSI1MTMuNjY5OSIgeT0iODgyNS4zMDc2Ij5QZXJmb3JtYW5jZSAmIzM4NzU0OyYjMjY0OTU7PC90ZXh0PjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxNDUuOTk5NSIgeD0iNjk1LjU4MTkiIHk9Ijg3NDYuMDE1NiIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjEyNS45OTk1IiB4PSI3MDUuNTgxOSIgeT0iODc2OS4wMTA3Ij4mIzM1NzYwOyYjMjQ0MDU7JiMyMTY0NDsmIzIwOTk4OyYjMjY1MTI7JiMzOTAyOTsmIzM4NzU0OyYjMjQ2MTU7JiMzMzAyMTs8L3RleHQ+PHBhdGggZD0iTTY0NS41ODE5LDg4MjAuNDYwOSBMNjU1LjU4MTksODgyMC40NjA5IEM2NzAuNTgxOSw4ODIwLjQ2MDkgNjcwLjU4MTksODc2NC4xNjQxIDY4NS41ODE5LDg3NjQuMTY0MSBMNjk1LjU4MTksODc2NC4xNjQxICIgZmlsbD0ibm9uZSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjA7Ii8+PHJlY3QgZmlsbD0iI0YxRjFGMSIgaGVpZ2h0PSIzNi4yOTY5IiByeD0iMTIuNSIgcnk9IjEyLjUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS41OyIgd2lkdGg9IjEwMy45OTk2IiB4PSI2OTUuNTgxOSIgeT0iODgwMi4zMTI1Ii8+PHRleHQgZmlsbD0iIzAwMDAwMCIgZm9udC1mYW1pbHk9InNhbnMtc2VyaWYiIGZvbnQtc2l6ZT0iMTQiIGxlbmd0aEFkanVzdD0ic3BhY2luZyIgdGV4dExlbmd0aD0iODMuOTk5NiIgeD0iNzA1LjU4MTkiIHk9Ijg4MjUuMzA3NiI+JiMyNjU5NzsmIzI1MjE0OyYjMjQ2MTU7JiMzMzAyMTsmIzI5OTQyOyYjMzkwNDg7PC90ZXh0PjxwYXRoIGQ9Ik02NDUuNTgxOSw4ODIwLjQ2MDkgTDY1NS41ODE5LDg4MjAuNDYwOSBDNjcwLjU4MTksODgyMC40NjA5IDY3MC41ODE5LDg4MjAuNDYwOSA2ODUuNTgxOSw4ODIwLjQ2MDkgTDY5NS41ODE5LDg4MjAuNDYwOSAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxMDMuOTk5NiIgeD0iNjk1LjU4MTkiIHk9Ijg4NTguNjA5NCIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjgzLjk5OTYiIHg9IjcwNS41ODE5IiB5PSI4ODgxLjYwNDUiPiYjMjAyNDg7JiMyMTI3MDsmIzIxMTUyOyYjMzY3MzM7JiMyNjEwMjsmIzM4Mzg4OzwvdGV4dD48cGF0aCBkPSJNNjQ1LjU4MTksODgyMC40NjA5IEw2NTUuNTgxOSw4ODIwLjQ2MDkgQzY3MC41ODE5LDg4MjAuNDYwOSA2NzAuNTgxOSw4ODc2Ljc1NzggNjg1LjU4MTksODg3Ni43NTc4IEw2OTUuNTgxOSw4ODc2Ljc1NzggIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNNDUzLjY2OTksODQyNi4zODI4IEw0NjMuNjY5OSw4NDI2LjM4MjggQzQ3OC42Njk5LDg0MjYuMzgyOCA0NzguNjY5OSw4ODIwLjQ2MDkgNDkzLjY2OTksODgyMC40NjA5IEw1MDMuNjY5OSw4ODIwLjQ2MDkgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTA5Ljk0MDMiIHg9IjUwMy42Njk5IiB5PSI4OTQzLjA1NDciLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI4OS45NDAzIiB4PSI1MTMuNjY5OSIgeT0iODk2Ni4wNDk4Ij5TZWN1cml0eSAmIzM4NzU0OyYjMjY0OTU7PC90ZXh0PjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxMzEuOTk5NSIgeD0iNjYzLjYxMDIiIHk9Ijg5MTQuOTA2MyIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjExMS45OTk1IiB4PSI2NzMuNjEwMiIgeT0iODkzNy45MDE0Ij4mIzI2NTk3OyYjMzA0NzU7JiMzOTAyOTsmIzM4NzU0OyYjMjM0MzM7JiMyMDg0MDsmIzIwNDQ5OyYjMjQ2ODc7PC90ZXh0PjxwYXRoIGQ9Ik02MTMuNjEwMiw4OTYxLjIwMzEgTDYyMy42MTAyLDg5NjEuMjAzMSBDNjM4LjYxMDIsODk2MS4yMDMxIDYzOC42MTAyLDg5MzMuMDU0NyA2NTMuNjEwMiw4OTMzLjA1NDcgTDY2My42MTAyLDg5MzMuMDU0NyAiIGZpbGw9Im5vbmUiIHN0eWxlPSJzdHJva2U6IzE4MTgxODtzdHJva2Utd2lkdGg6MS4wOyIvPjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxNDAuNDI4NSIgeD0iNjYzLjYxMDIiIHk9Ijg5NzEuMjAzMSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjEyMC40Mjg1IiB4PSI2NzMuNjEwMiIgeT0iODk5NC4xOTgyIj4mIzM1ODQzOyYjMzU3OTc7IFNTTC9UTFMgJiMzODM4MjsmIzM5MDY0OzwvdGV4dD48cGF0aCBkPSJNNjEzLjYxMDIsODk2MS4yMDMxIEw2MjMuNjEwMiw4OTYxLjIwMzEgQzYzOC42MTAyLDg5NjEuMjAzMSA2MzguNjEwMiw4OTg5LjM1MTYgNjUzLjYxMDIsODk4OS4zNTE2IEw2NjMuNjEwMiw4OTg5LjM1MTYgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNNDUzLjY2OTksODQyNi4zODI4IEw0NjMuNjY5OSw4NDI2LjM4MjggQzQ3OC42Njk5LDg0MjYuMzgyOCA0NzguNjY5OSw4OTYxLjIwMzEgNDkzLjY2OTksODk2MS4yMDMxIEw1MDMuNjY5OSw4OTYxLjIwMzEgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTI5LjYwNzMiIHg9IjUwMy42Njk5IiB5PSI5MDU1LjY0ODQiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSIxMDkuNjA3MyIgeD0iNTEzLjY2OTkiIHk9IjkwNzguNjQzNiI+TGlnaHRob3VzZSAmIzM4NzU0OyYjMjY0OTU7PC90ZXh0PjxyZWN0IGZpbGw9IiNGMUYxRjEiIGhlaWdodD0iMzYuMjk2OSIgcng9IjEyLjUiIHJ5PSIxMi41IiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuNTsiIHdpZHRoPSIxMDMuOTk5NiIgeD0iNjgzLjI3NzIiIHk9IjkwMjcuNSIvPjx0ZXh0IGZpbGw9IiMwMDAwMDAiIGZvbnQtZmFtaWx5PSJzYW5zLXNlcmlmIiBmb250LXNpemU9IjE0IiBsZW5ndGhBZGp1c3Q9InNwYWNpbmciIHRleHRMZW5ndGg9IjgzLjk5OTYiIHg9IjY5My4yNzcyIiB5PSI5MDUwLjQ5NTEiPiYjMjk5ODM7JiMyNTEwNDsmIzI0NjE1OyYjMzMwMjE7JiMyNTI1MzsmIzIxNTc4OzwvdGV4dD48cGF0aCBkPSJNNjMzLjI3NzIsOTA3My43OTY5IEw2NDMuMjc3Miw5MDczLjc5NjkgQzY1OC4yNzcyLDkwNzMuNzk2OSA2NTguMjc3Miw5MDQ1LjY0ODQgNjczLjI3NzIsOTA0NS42NDg0IEw2ODMuMjc3Miw5MDQ1LjY0ODQgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cmVjdCBmaWxsPSIjRjFGMUYxIiBoZWlnaHQ9IjM2LjI5NjkiIHJ4PSIxMi41IiByeT0iMTIuNSIgc3R5bGU9InN0cm9rZTojMTgxODE4O3N0cm9rZS13aWR0aDoxLjU7IiB3aWR0aD0iMTAzLjk5OTYiIHg9IjY4My4yNzcyIiB5PSI5MDgzLjc5NjkiLz48dGV4dCBmaWxsPSIjMDAwMDAwIiBmb250LWZhbWlseT0ic2Fucy1zZXJpZiIgZm9udC1zaXplPSIxNCIgbGVuZ3RoQWRqdXN0PSJzcGFjaW5nIiB0ZXh0TGVuZ3RoPSI4My45OTk2IiB4PSI2OTMuMjc3MiIgeT0iOTEwNi43OTIiPiYjMzM3MTk7JiMyMTQ2MjsmIzI1OTEzOyYjMzY4Mjc7JiMyNDMxNDsmIzM1NzU4OzwvdGV4dD48cGF0aCBkPSJNNjMzLjI3NzIsOTA3My43OTY5IEw2NDMuMjc3Miw5MDczLjc5NjkgQzY1OC4yNzcyLDkwNzMuNzk2OSA2NTguMjc3Miw5MTAxLjk0NTMgNjczLjI3NzIsOTEwMS45NDUzIEw2ODMuMjc3Miw5MTAxLjk0NTMgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNNDUzLjY2OTksODQyNi4zODI4IEw0NjMuNjY5OSw4NDI2LjM4MjggQzQ3OC42Njk5LDg0MjYuMzgyOCA0NzguNjY5OSw5MDczLjc5NjkgNDkzLjY2OTksOTA3My43OTY5IEw1MDMuNjY5OSw5MDczLjc5NjkgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNMjUzLjk5OTMsODMxMy43ODkxIEwyNjMuOTk5Myw4MzEzLjc4OTEgQzI3OC45OTkzLDgzMTMuNzg5MSAyNzguOTk5Myw4NDI2LjM4MjggMjkzLjk5OTMsODQyNi4zODI4IEwzMDMuOTk5Myw4NDI2LjM4MjggIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48cGF0aCBkPSJNMTEzLjk5OTYsNDU3MC4wNDY5IEwxMjMuOTk5Niw0NTcwLjA0NjkgQzEzOC45OTk2LDQ1NzAuMDQ2OSAxMzguOTk5Niw4MzEzLjc4OTEgMTUzLjk5OTYsODMxMy43ODkxIEwxNjMuOTk5Niw4MzEzLjc4OTEgIiBmaWxsPSJub25lIiBzdHlsZT0ic3Ryb2tlOiMxODE4MTg7c3Ryb2tlLXdpZHRoOjEuMDsiLz48IS0tU1JDPVtoTFhSTG5GOTVkeEZod1g3UElzVHlOQUVpdG1RWnBlVUZRMkNHTnNFZU9OTWYza2hxcTV1Mm8wYTBHODlMdjVtMk9oNEluOE8xRzk5bzh5dmdVaEVhdF9YeEJmcmtZQ3lkQk5jMVRBeFRrdFFqVlV0Ul9MeHIwbU9QYlpMLWlFMVlBeUJ1TEpRLWJCNmpKWVVvdkJLRDl3U3lOS3ZyQmFpdGJfMlN0eTEyTVo5azFyVmlhUV9NQmpmSWtYMkJtRDMwTl9HSzJFY3pVd0RWTjE0Slo5dVZlUWlWMkF2SlJ3TnlHNVpiM0FLRHdwNUpLNFhrSlhFaFdGTE1Zb3F1ZWttM1VfN013aVBrU25hYThDdlVwVTlMbWwwSG5SQlA2UUtaNF9Xb0dFY0poRUlpNUFWUzdzLU1PYUJUVndDQVNPODBjUnlWR3RLYU9TcGlnRTBGSnYzTGlrVURSZzVSNUxtT25uRm1OaHpmeUxjeElzVVFiMGJ3X2p1OFZ0SmtmdFZpcERyTUJUY3p2aEx6c0lqME5fbm1ZWEpyNWV6blFOM3ZhY2dMTmRGNVJzYjNTSDIwVUZvby1YX3V3RUZiSzNHWEZ6Rk91aDdQY3FjSlcyWkMxTjlucDdTRTkwcWsxMjlacmhWZ2JQckt6OW1RUUVyRWU1RjVpNnM5OXppZGF1QmFVb2VjeVlnbGNiTTNfN0NDaHJHVVdiZGljSGZad0hCdjYzcVJwaUFSbEVaemV2S0NkUFozVFZjSTd3SVIxcC1GVDgxRXZfOS1Xdk9Za0pNazQ3blFPYVpMZm1VTFJNMWE3OGY2V2E4R2Uta3dPT0lxSmN4TnA2NjUyRWFIQmJmcUpGYi1RcmVMMGFfM3VybW1acVo0MWR5aXJqdXdwd3Jhb2pDUTgxT2lzTXlGVHV5TlJTRmJmYkkzX0wtSFZlQTU0X1B4b1Y4eVo3djlqdFBoNHBSek5ncENpbE52MUxWR28zZ2hucU5YbUYxSHR3bmVfTHZuWXdGVWphckUwTFQ2ZDgtOHM3dlhRbktha0ktTWdNeWJQYUs0aElYQzhpNjlXOGtxUW10bTlBMmRMcTBweHJqOVVQUTRzY2hObDg5WVJ1a3BtelNnUzBjZEFxdGduLVM5SEhiT0kta1FvVzNRakk0S0MzOTE0YmxvekVEeXF2N2FLM21MTTIwc2FsTmswWW9kMDFDTWpLNWlsNzZ0ZHJGRGNHY3EwOVhIVm00ZHFMTGlRNEJ6SWpTWHBPYjc1M2JKeFR3YjNNWVFGc0E1YklMRGNkZXBpeksyZjZlUWtoNlkyMnlLYVBVd3FRX04wXzRwNDdUNDF5WERRWGVLS0xPQUxGNkt5OUFUbGFaTjg3SkVLQlNsaDZBb3pSSVpqWnJTUW5QTnY5ZXNRRmZ5RWxOUFlLNW9FNFJ5T25tbE8wS1g2a3B5bGNTakdfbHBic3BLaVV1ejR3ZTBWY2lhc2NZMEVjTml2dVpkMjdWWk5oOThQcnZBUUc3TnA2RlljbEhZNHZjeURuS2l2d0paWHpJSk00bS1lbDIwcElwbmV1WEJkWUV6SXdzeWlWTU1XYUExVHdUWGRwYk1rSUd2UVhueDh0aVNYNFloYmNUamdlaUlRRDFDbnBZa194VHJ6RERxUlh2R2F0MFNFUjZEemJBTUNMSkpoN3AxUGVNOXlRanhyazJLWXVzWnJFVzBNVVo1ZEk1NFhOejNvSnlicGVjeUxzMXdUbk5kRGwzblJUdWgyMG5lbVMzOEp5MDMwbWNlR2ZmMjMzaTlHUHJfUE5BRmIxR1BZZHV1TG8wTnZKSk1fNEtjVnU0TEhBQTJEeFZXRURmbGVoTkg5b2xwUEQyN2N6Q296a0VXd1RiYkpxZUtUMndJTzJJUFp0ajlUTmViSlc5X1FXYl9tV2ZteV9ydUgtcmI2Mm13YmNvTFVDQ2k3eEZLRmxiOGJOdzZaRURvb3ZHR0k2ZEdyTW1Jd1RzQUstcl9KcFZoMi1HcEhzeGwycWtqVnE2VnRXM3VHQnRhZU9BSDZLU29qSURYY0JBREk1cXl5SkFub3FnT2g5VFd6MHJ2RFpDTk16RzF4ODBWLXFhMkNrdHpKM0IxRTBPVEFsdEZlQXpUY0ZGeVBXUFlvMlNnNEZQVENNd2dBX2dhOEJXSWYxQk5ZMGxLNVlIV25JMWltTGVSYmhwZHQwbjhfM0xNNmt6RlZHZTI0S1FQdjlXOTdPLXc4U1VpTG1OUFRfcUtrTFpLYndLck9NNTlGYk1tMUN4dTg5VUduekktdkxWeGNpbGJRM1B6ZklULTRtVFY5bVlDbWNQcGk1cUttTFFVYmJORzBqS1JPbUtUX1lkMTRlWEp6T1JrME9uTlEyZ21EdDRJZnlJV2ZuZmNDWjVad29mR29oR05PaDA1eUZla2pVRVZaRFdBVzNRVXVmZkFXUnl3OGExMVV1OEZzeTVjVXF4M0tZWGxCdTIzWmxaMkN4dWEtajRyY055bWpmN1BNam5sckN6ejVZRldIZ1dmOENPcHo3U0lkbWxqVEIxM0R2UHVQX0lra20zYnY4dV9HS3VJNjhVSnNyMXFQUzJvWkt4LVBhbFRzR0dhTjRPdUFLbUhoQWdNVWVtRzJUaDFabmhOZkJxaERwTnpXT2VSWXJNR09SVEk5MUFOY3ZXN3NUVkxMWW9wbVhlbWYwVUQ3MjFEM3JfVU1rVHhEQmlBTkVIdF8tT09oTXJsYWd6S3l6UU5yUHY2VjI0OThOR216WW0ySnl6VzIydkQ5eEFHdno1QWQtSHBHSzBDaVczekRBWk03SklDazVNekVUcHM5dnh2LXpmOW55eWt6Y3NqYUZiM1VaUEVTRUd1SXIyVzdTdDZ6M3BVc0hIMDBBSS1YZFJpdTBQNzZJQ0hwakcxcWRrMTJVYjdJNUFYdzVkQVhfUi10ZEEtclh2NE85bWJHN2tIUHpObU1RYkFDT0kyMExOR3E0RWZrc29SM2J2NFVDYWFDenp3RTRHWmR3V0g0c01pd1h4LWtaNzRyQ0RvTUhCLXp4YTdsS0FzbWVNbGRscmhpV2ZnNnlhZWwwSGEybEdfWndwTGJkeExJWDU3QWIydXphVEZGVVVnaVVOYWJ6bTlrcW1DeEx0SUtocTFVSlJjYkY5VTJmbTNHbTh2bWVJTnFMLUN1enNPZm5tM0hCVzR3aW14TXU2VTVjV2JHN3c1cFN6YVJPX1psOXNtekxVeUF4OERKSkE3OTFTbXpLSndHT3NFbDA1M3Z2U0lPVE5ocENvM0dGSF92amh1MWU3aFZMamFZY3dqNjNia0pFaEdxVDhUeV9EYXpydzl6OXVUVlI5UWFIN0hiTzA5RF9hSDZreXUxUmVpMzd0S2hiR1p6WHgwYnpDN2FCMXVvb2otQmpjOHR5WE9rWUhBQmtZNGJSRFl5dnlvRkp2Z05aQXJqWHg5a1ZmTUNHZDItWGtJMGFoY2Vid0dwNHdQei0yZHRVS2czZ1dLU0ZCdEt4VVI1UWdoVXN0UmFwUXZJRW9Gb1FkeU01TFR3T3F6ZDVzY1EzRjlESnRkMEtHdnVwNDg3Unc4dTQybTl1cEVsUktuZzBEVFY4X1NYdS14QnJuNFFzZU1OcmxST3NzMlZCYzNZeTdlbnNWMDVaWllJQ3ZMbk1YbE5SbHVZRVZqUFFyVG9UNVptUFRYSHZJbDNhN3RIdXF6QjFvYllmVE9DVVhGYnFGSEpsSVRzZTFUNzNNd0FFQVVtOWtCb3BEMDNoUk9UR2JOSEw1NUJOaDNJYmxTeVZBSlRETmJUZ29WUGd6eXdZN1I2TGJ2Y2dLb0U4bnh6N1B3eXFIODVSNjFqRnFqZnlGcWYyRnNWS3lla3RKMVBtdThJaXhrQjQyRzJJWlBVU0VrdFAtMVpybU5oUTR0SnFnakhQTnhOOFA1QkVCN3Q1c29ZSzBGTEhDNjFYVmROS0hNZ1FnRUctZ1ExNmtWZzFsUGZjU3pOdFJpdVFKYXAwNVNuOWphTGJPeWVTUXlJdUhZUzA4b1hnY3ktcDZNZm1zR0RXYTBsY3hzcE01RzZKdUZIQzg0Nndwd0dDU0xLb3ZVYVRjTFZQczBlQ2xVV1F0TDBvRmhsb1huZ2VqbTQ2WTdUMVpIYjNmUzJsYTVKUXdLTTFBWk9peHEwOXBzdnpYUnBZUUZhNWlKUEFqZjRTUnRnZ3dUZzFVbk5ZWDYtNjAxWWZzZEJlN0VQcVFha2FnQ2NIeWpfdFMxc1VIcjJhZE1HazdoTXJ2NVktcEZCLUliU0ZNb2RWdloxSUM2UWV2U2ZScmtOb09kTTZxelcxQ2NqN1ZfS2pWam4tckxhZkVza2JNMW1SREdKcU14TDJUVHBQU0NKQXIwdVlKaWNRRnlEbW9uMDV6UEFrVXNBTUl4dFQ1d3ZVRmt4eFVLNDBwZF9IcW92U0pURU5vckwtbE5oenl1dThfTzhCdzRWSmgzTkpib2lxaGx6c3lTV0N6d1JrRHdGOTV0dUx4bFRxZW9kbzcta2RCWmxleUhjNXNxS1ZaMFpzRVFRT1FMY3gySEE5ZTMteHlIbkJHTk1yOEROSURYaEJsbVRFVURpQ19ocl93YnNnQVRwVnFqQ1R0SHRhSFk4TENzMTdLLXJManUyUVNfaVVidHRwVDBNcVcxWTJ5WUhKRFRyaTdrU084aEZkXzFtMDBdLS0+PC9nPjwvc3ZnPg=='>]]></content>
    
    
    <categories>
      
      <category>前端开发手册</category>
      
    </categories>
    
    
    <tags>
      
      <tag>开发手册</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>chrome devtools 介绍</title>
    <link href="/2024/06/01/frontendGuide/browserDebug/chromeDevtools/introduction/"/>
    <url>/2024/06/01/frontendGuide/browserDebug/chromeDevtools/introduction/</url>
    
    <content type="html"><![CDATA[<h2 id="从-Chrome-说起"><a href="#从-Chrome-说起" class="headerlink" title="从 Chrome 说起"></a>从 Chrome 说起</h2><p>谷歌浏览器（通常简称为 Chrome ）是由谷歌开发的网络浏览器。 它于 2008 年首次针对 Microsoft Windows 发布，后来移植到 Linux ，macOS ，iOS 和 Android 。 浏览器也是 Chrome OS 的主要组件，它可以作为 Web 应用的平台。<a href="https://en.wikipedia.org/wiki/Google_Chrome">Chrome-wikipedia</a><br />浏览器的市场天下三分，Chorme，Safari和FireFox，从 2008 年 Chrome 横空出世以来，如今已经一家独大占据了半壁江山：<br /><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-1-1.png"><br />对于大部分人来说，Chrome 可能只是个浏览器，但是对于开发人员来说，它更是一个强大无比的工具，为了方便开发人员调试代码，主流的浏览器都内置了 DevTools， 所以无论你是前端还是后端，掌握 Chrome 的调试技巧意味着效率直接的提高。而接下来要介绍的，就是 Chrome-DevTools 的使用技巧。</p><h2 id="DevTools-简介"><a href="#DevTools-简介" class="headerlink" title="DevTools 简介"></a>DevTools 简介</h2><p>本段内容引用于 <a href="https://developers.google.com/web/tools/chrome-devtools/#_1">Chrome DevTools</a>说明 熟悉的同学可以跳过，也可以选择跳转到原链接访问，这里是为了给没有接触过 chrome-devtools 的同学一些基础概念。</p><h3 id="打开-Chrome-开发者工具"><a href="#打开-Chrome-开发者工具" class="headerlink" title="打开 Chrome 开发者工具"></a>打开 Chrome 开发者工具</h3><ul><li>在 Chrome 菜单中选择 更多工具 &gt; 开发者工具</li><li>在页面元素上右键点击，选择 “检查”</li><li>使用 快捷键 Ctrl + Shift + I (Windows) 或 Cmd + Opt + I (Mac)</li></ul><h3 id="了解面板"><a href="#了解面板" class="headerlink" title="了解面板"></a>了解面板</h3><p>我将从以下 8 个面板来讲述面板内容：</p><ol><li>元素面板</li><li>控制台面板</li><li>源代码面板</li><li>网络面板</li><li>性能面板</li><li>内存面板</li><li>应用面板</li><li>安全面板</li></ol><h4 id="1-元素面板"><a href="#1-元素面板" class="headerlink" title="1. 元素面板"></a>1. 元素面板</h4><p>使用元素面板可以自由的操作 DOM 和 CSS 来迭代布局和设计页面。</p><ul><li>检查和调整页面</li><li>编辑样式</li><li>编辑 DOM</li></ul><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-1-2.png"></p><h4 id="2-控制台面板"><a href="#2-控制台面板" class="headerlink" title="2.控制台面板"></a>2.控制台面板</h4><p>在开发期间，可以使用控制台面板记录诊断信息，或者使用它作为 shell 在页面上与 JavaScript 交互。</p><ul><li>使用控制台面板</li><li>命令行交互</li></ul><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-1-3.png"></p><h4 id="3-源代码面板"><a href="#3-源代码面板" class="headerlink" title="3.源代码面板"></a>3.源代码面板</h4><p>在源代码面板中设置断点来调试 JavaScript ，或者通过 Workspaces（工作区）连接本地文件来使用开发者工具的实时编辑器</p><ul><li>断点调试</li><li>调试混淆的代码</li><li>使用开发者工具的 Workspaces（工作区）进行持久化保存</li></ul><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-1-4.png"></p><h4 id="4-网络面板"><a href="#4-网络面板" class="headerlink" title="4.网络面板"></a>4.网络面板</h4><p>使用网络面板了解请求和下载的资源文件并优化网页加载性能。</p><ul><li>网络面板基础</li><li>了解资源时间轴</li><li>网络带宽限制</li></ul><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-1-5.png"></p><h4 id="5-性能面板"><a href="#5-性能面板" class="headerlink" title="5.性能面板"></a>5.性能面板</h4><p>使用时间轴面板可以通过记录和查看网站生命周期内发生的各种事件来提高页面的运行时性能。<br /><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-1-6.png"></p><h4 id="6-内存面板"><a href="#6-内存面板" class="headerlink" title="6.内存面板"></a>6.内存面板</h4><p>如果需要比时间轴面板提供的更多信息，可以使用“配置”面板，例如跟踪内存泄漏。</p><ul><li>JavaScript CPU 分析器</li><li>内存堆区分析器</li></ul><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-1-7.png"></p><h4 id="7-应用面板"><a href="#7-应用面板" class="headerlink" title="7.应用面板"></a>7.应用面板</h4><p>使用资源面板检查加载的所有资源，包括 IndexedDB 与 Web SQL 数据库，本地和会话存储，cookie ，应用程序缓存，图像，字体和样式表。</p><ul><li>管理数据</li></ul><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-1-8.png"></p><h4 id="8-安全面板"><a href="#8-安全面板" class="headerlink" title="8.安全面板"></a>8.安全面板</h4><p>使用安全面板调试混合内容问题，证书问题等等。</p><ul><li>安全</li></ul><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-1-9.png"></p><h2 id="Chrome-DevTools-原理"><a href="#Chrome-DevTools-原理" class="headerlink" title="Chrome DevTools 原理"></a>Chrome DevTools 原理</h2><p>Chrome DevTools 分为两部分，backend 和 frontend：</p><ul><li>backend 和 Chrome 集成，负责把 Chrome 的网页运行时状态通过调试协议暴露出来。</li><li>frontend 是独立的，负责对接调试协议，做 UI 的展示和交互。</li></ul><p>两者之间的调试协议叫做 Chrome DevTools Protocol，简称 CDP。<br>传输协议数据的方式叫做信道（message channel），有很多种，比如 Chrome DevTools 嵌入在 Chrome 里时，两者通过全局的函数通信；当 Chrome DevTools 远程调试某个目标的代码时，两者通过 WebSocket 通信。<br>frontend、backend、调试协议（CDP）、信道，这是 Chrome DevTools 的 4 个组成部分。<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-1-10.png"><br>backend 可以是 Chromium，也可以是 Node.js 或者 V8，这些 JS 的运行时都支持 Chrome DevTools Protocol。<br>这就是 Chrome DevTools 的调试原理。</p>]]></content>
    
    
    <categories>
      
      <category>前端开发手册</category>
      
      <category>Debug 大作战：浏览器调试全攻略</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器调试,谷歌开发者工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通用篇</title>
    <link href="/2024/06/01/frontendGuide/browserDebug/chromeDevtools/general/"/>
    <url>/2024/06/01/frontendGuide/browserDebug/chromeDevtools/general/</url>
    
    <content type="html"><![CDATA[<h1 id="copying-saving"><a href="#copying-saving" class="headerlink" title="copying &amp; saving"></a>copying &amp; saving</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在调试的过程中，我们总要对 Dev Tools 里面的数据进行 <strong>复制</strong> 或者 <strong>保存</strong> 的操作，所以我们来看看，关于这些，有什么小技巧呢？</p><h2 id="1-copy-…"><a href="#1-copy-…" class="headerlink" title="1. copy(…)"></a>1. copy(…)</h2><p>你可以通过全局的方法 copy() 在 console 里 copy 任何你能拿到的资源，包括我们在后面会提到的那些变量。例如 copy($_) 或 copy($0)<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-2-1.gif"></p><h2 id="2-Store-as-global-存储为一个全局变量"><a href="#2-Store-as-global-存储为一个全局变量" class="headerlink" title="2. Store as global (存储为一个全局变量)"></a>2. Store as global (存储为一个全局变量)</h2><p>如果你在 console 中打印了一堆数据 (例如你在 App 中计算出来的一个数组) ，然后你想对这些数据做一些额外的操作比如我们刚刚说的 copy (在不影响它原来值的情况下) 。 那就可以将它转换成一个全局变量，只需要 <strong>右击</strong> 它，并选择 “Store as global variable” (保存为全局变量) 选项。<br>第一次使用的话，它会创建一个名为 temp1 的变量，第二次创建 temp2，第三次 … 。通过使用这些变量来操作对应的数据，不用再担心影响到他们原来的值:<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-2-2.gif"></p><h2 id="3-保存堆栈信息-Stack-trace"><a href="#3-保存堆栈信息-Stack-trace" class="headerlink" title="3.保存堆栈信息( Stack trace )"></a>3.保存堆栈信息( Stack trace )</h2><p>大多数情况下都不是一个人开发一个项目，而是一个团队协作，那么 <strong>如何准确的描述问题，就成为了沟通的关键</strong> ，这时候 console 打印出来的堆栈跟踪的信息对你和同事来说就起大作用了，可以省去很多沟通成本，所以你可以直接把堆栈跟踪的信息保存为一个文件，而不只是截图发给对方：<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-2-3.gif"></p><h2 id="4-直接Copy-HTML"><a href="#4-直接Copy-HTML" class="headerlink" title="4.直接Copy HTML"></a>4.直接Copy HTML</h2><p>几乎所有人都知道，右击或者点击在 HTML 元素边上的省略号 (…) 就可以将它 copy 到剪贴板中<br>，但是你不知道的是：古老的[ctrl] + [c]大法依旧可用！<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-2-4.gif"></p><h1 id="快捷键和通用技巧"><a href="#快捷键和通用技巧" class="headerlink" title="快捷键和通用技巧"></a>快捷键和通用技巧</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>能直接快速提升开发效率的方式是什么？</p><ul><li>掌握快捷键</li></ul><p>这里是一些我们在日常前端开发中，相当实用的快捷键：</p><h2 id="1-切换-DevTools-窗口的展示布局"><a href="#1-切换-DevTools-窗口的展示布局" class="headerlink" title="1. 切换 DevTools 窗口的展示布局"></a>1. 切换 DevTools 窗口的展示布局</h2><p>一般我在使用 DevTools 时， dock 的展示窗口都在底部 ，但是有时候我想把 dock 的窗口 切换到右边。<br>怎么做呢？<br>这时就可以通过 DevTools 的下拉菜单，或者命令菜单…或者使用一个快捷键 ctrl + shift + D (⌘ + shift + D Mac) 来实现位置的切换（通常是从 开始的位置 到 右边位置， 但是如果一开始就是 右边的位置 那么会切换到 左边的位置）:<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-2-5.gif"></p><h2 id="2-切换-DevTools-的面板"><a href="#2-切换-DevTools-的面板" class="headerlink" title="2. 切换 DevTools 的面板"></a>2. 切换 DevTools 的面板</h2><p>如果可以的话，我想成为一个不需要鼠标的开发者，日常开发中，我们常需要从 元素面板 跳转到 资源面板 并返回，这样往返的来调试我们的代码，怎么来节省鼠标点击的时间呢：</p><ul><li>按下 ctrl + [ 和 ctrl + ] 可以从当前面板的分别向左和向右切换面板。</li><li>按下 ctrl + 1 到 &#96;&#96;ctrl + 9可以直接转到编号1…9的面板(ctrl + 1 转到元素面板，ctrl + 4&#96; 转到 网络信息面板等等)</li></ul><p><strong>请注意!</strong> 我们在上面介绍的第二组快捷键默认被禁用了。你可以通过 DevTools&gt;&gt;Settings &gt;&gt;Preferences&gt;&gt;<em>Appearance</em> 打开这个选项：<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-2-6.gif"></p><h2 id="3-递增-递减"><a href="#3-递增-递减" class="headerlink" title="3. 递增&#x2F;递减"></a>3. 递增&#x2F;递减</h2><p>接下来这个技巧，对调整样式是最有用的：通过使用 带有 或者 不带有修饰键 的 上 &#x2F; 下 箭头按键， 你可以实现递增和递减 0.1 ， 1 或者 10 这样数值类型的值。<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-2-7.png"><br>甚至对颜色都起作用！（虽然没什么卵用，但是真的可以起作用~）</p><h2 id="4-elements，-logs，-sources-network-中的查找"><a href="#4-elements，-logs，-sources-network-中的查找" class="headerlink" title="4. elements， logs， sources &amp; network 中的查找"></a>4. elements， logs， sources &amp; network 中的查找</h2><p>DevTools 中的前4个主要的面板，每一个都支持 [ctrl] + [f] 快捷方式，你可以使用对应的查询方式来查找信息:</p><ul><li>在 Elements 面板中 - 通过 string ，选择器 或者 XPath 来查找</li><li>而在 Console， Network 以及 Source 面板 - 通过区分大小写，或者可以被视为表达式的 strings， 来查找</li></ul><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-2-8.png"></p><h1 id="使用-Command"><a href="#使用-Command" class="headerlink" title="使用 Command"></a>使用 Command</h1><h2 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h2><p>我们直接可以直接看到的 DevTools 的功能，其实只是有限的一部分，怎么去探索更多的功能呢？<br>Command 菜单可以帮助我们快速找到那些被隐藏起来的功能，这也是它本身必不可少的原因。<br>如果你使用过 WebStorm 中的 Find Action (查找动作) 或者 Visual Studio Code 中的 Command Palette 的话，那么在 DevTools 中的 Command 菜单也与之类似：</p><ul><li>在 Chrome 的调试打开的情况下 按下 [ Ctrl] + [Shift] + [P] (Mac： [⌘] + [Shift]+ [P] )</li><li>或者使用 DevTools 的 dropdown 按钮下的这个选项:</li></ul><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-2-9.png"><br>下图中，我整理了可供选择的命令列表，归为几个部分：<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-2-10.png"><br>上面这张图同时也证明了 DevTools 有多么强力!</p><h2 id="1-截屏的新姿势"><a href="#1-截屏的新姿势" class="headerlink" title="1.截屏的新姿势"></a>1.截屏的新姿势</h2><p>当你只想对一个特别的 DOM 节点进行截图时，你可能需要使用其他工具弄半天，但现在你直接选中那个节点，打开 Command 菜单并且使用 <strong>节点截图</strong> 的就可以了。<br>不只是这样，你同样可以用这种方式 <strong>全屏截图</strong> - 通过 Capture full size screenshot 命令。请注意，这里说的是全屏，并不是嵌入页面的一部分。一般来说这可是得使用浏览器插件才能做到的事情！<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-2-11.gif"><br>注：<strong>节点截图有时会失效</strong>，全屏截图暂时没有遇到问题，建议大家使用后者。</p><h2 id="2-快速切换面板"><a href="#2-快速切换面板" class="headerlink" title="2.快速切换面板"></a>2.快速切换面板</h2><p>DevTools 使用双面板布局，形式一般是：元素面板 + 资源面板 ，它根据屏幕可用的部分，经常将不同面板横向或者纵向的排列，以适合阅读的方式展示出来。但有时候我们并不喜欢默认的布局。<br>你是否想过要重置 DevTools 呢？将 样式面板 从 html预览 的底部移动到右边或者周围其他的位置呢？是的，这就是下面要介绍的 😉<br>打开 Commands 菜单并且输入 layout ，你会看到 2 到 3 个可供选择的项(这里不再显示你已经激活的选项)：</p><ul><li>使用横向面板布局</li><li>使用纵向面板布局</li><li>使用自动面板布局</li></ul><p>试试看：<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-2-12.gif"></p><h2 id="3-快速切换主题"><a href="#3-快速切换主题" class="headerlink" title="3.快速切换主题"></a>3.快速切换主题</h2><p>经常在电脑前一坐就是一天，所以我不能忍受一直看着白闪闪的屏幕。而且突然出现的强光也让人讨厌：我们一直都在黑暗的空间中工作，突然太阳出来了，照在你的 DevTools 上，导致你什么都看不到！<br>这个时候 主题 就派上了用场了：在 Commands 菜单中寻找与 theme 相关的选项，实现 明亮 &amp; 暗黑 两种主题之间的切换：<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-2-13.gif"></p><h1 id="代码块的使用"><a href="#代码块的使用" class="headerlink" title="代码块的使用"></a>代码块的使用</h1><h2 id="前言-3"><a href="#前言-3" class="headerlink" title="前言"></a>前言</h2><p>我经常使用 JavaScript 作为我的自动化工具，来处理第三方网站和应用程序：<br>比方说，我想看看有多少人在我的所有媒体帖子上鼓掌。 Medium 没有提供这样的总数，所以我把这个小脚本组合在一起：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">?(<span class="hljs-string">&#x27;td:last-child .sortableTable-number&#x27;</span>)<br>    .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> <span class="hljs-built_in">parseInt</span>(el.<span class="hljs-property">innerText</span>))<br>    .<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">total, value</span>) =&gt;</span> total + value);<br></code></pre></td></tr></table></figure><p>当我打开状态页并且输入这段脚本到 Console 面板的时候，它将会返回这个数值:<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-2-14.png"><br>现在看来，即使这个脚本并没有花费我太多的精力来编写，但也只是偶尔运行一下，所以对于我来说，记住一段这样的脚本会很麻烦：<br>那怎么解决这个问题呢？<br>这就是 Snippets 的用武之地：它允许你存放 JavaScript 代码到 DevTools 中，方便你复用这些 JavaScript 代码块：<br>进入到 Sources 面板，在导航栏里选中 Snippets 这栏，点击 New snippet(新建一个代码块) ，然后输入你的代码之后保存，大功告成！现在你可以通过右击菜单或者快捷键： [ctrl] + [enter] 来运行它了：<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-2-15.gif"></p><h2 id="运行其他来源的代码块"><a href="#运行其他来源的代码块" class="headerlink" title="运行其他来源的代码块"></a>运行其他来源的代码块</h2><p>当我在 DevTools 中预设了一组很棒的代码块以后，甚至都不必再通过 Sources 来运行它们。使用 Command Menu 才是最快的方式。只需在它的输入框中输入 ! ，就可以根据名字来筛选预设代码块：<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-2-16.gif"></p>]]></content>
    
    
    <categories>
      
      <category>前端开发手册</category>
      
      <category>Debug 大作战：浏览器调试全攻略</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器调试,谷歌开发者工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elements面板</title>
    <link href="/2024/06/01/frontendGuide/browserDebug/chromeDevtools/elementsPanel/"/>
    <url>/2024/06/01/frontendGuide/browserDebug/chromeDevtools/elementsPanel/</url>
    
    <content type="html"><![CDATA[<h1 id="基本调试技巧"><a href="#基本调试技巧" class="headerlink" title="基本调试技巧"></a>基本调试技巧</h1><h2 id="1-通过-‘h’-来隐藏元素"><a href="#1-通过-‘h’-来隐藏元素" class="headerlink" title="1. 通过 ‘h’ 来隐藏元素"></a>1. 通过 ‘h’ 来隐藏元素</h2><p>按一下 ‘h’ 就可以隐藏你在元素面板中选择的元素。再次按下 ‘h’ 可以使它出现。某些的时候这很有用：例如你想截图，但你想去掉里面的敏感信息。<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-3-1.gif"></p><h2 id="2-拖动-放置-元素"><a href="#2-拖动-放置-元素" class="headerlink" title="2. 拖动 &amp; 放置 元素"></a>2. 拖动 &amp; 放置 元素</h2><p>当你想看看页面的某一部分在 DOM 树的不同位置的显示效果时，只需要拖动放置它(到指定的位置)，就像在机器上的其他任何地方一样 :-)<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-3-2.gif"></p><h2 id="3-使用-control-按钮-来移动元素"><a href="#3-使用-control-按钮-来移动元素" class="headerlink" title="3. 使用 control (按钮) 来移动元素!"></a>3. 使用 control (按钮) 来移动元素!</h2><p>如果你只是想移动你当前选中的元素，在 DOM 结构中往上挪一点或者往下挪一点，而不是拖动和放置，你同样可以使用[ctrl] + [⬆] &#x2F; [ctrl] + [⬇] ([⌘] + [⬆] &#x2F; [⌘] + [⬇] on Mac).<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-3-3.gif"></p><h2 id="4-元素面板中类似于基础编辑器的操作"><a href="#4-元素面板中类似于基础编辑器的操作" class="headerlink" title="4. 元素面板中类似于基础编辑器的操作"></a>4. 元素面板中类似于基础编辑器的操作</h2><p>从某一点来看，我们可以拖动，放置，编辑，复制(当然，以及使用 [ctrl] + [v] 来粘贴)， 所以我们可以在元素面板里把 HTML 结构搞得一团糟。在任意一个编辑器中都有一个标准，那么如何撤回你的操作呢？<br>使用[ctrl] + [z] ([⌘] + [z] on Mac)撤销我们的任何改动。 使用 [ctrl] + [shift] + [z]重新编辑我们的任何修改。<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-3-4.gif"></p><h2 id="5-Shadow-editor-阴影编辑器"><a href="#5-Shadow-editor-阴影编辑器" class="headerlink" title="5. Shadow editor 阴影编辑器"></a>5. Shadow editor 阴影编辑器</h2><p>听起来很不吉利(译者注：阴影哪里不吉利了！)，但是它也只是一个小部件而已。你可以通过在 Style 面板中点击靠近 box-shadow 属性或者 text-shadow 属性的 阴影方形符号 来打开它：<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-3-5.gif"></p><h2 id="6-Timing-function-editor-定时函数编辑器"><a href="#6-Timing-function-editor-定时函数编辑器" class="headerlink" title="6. Timing function editor 定时函数编辑器"></a>6. Timing function editor 定时函数编辑器</h2><p>也称为 Cubic bezier(贝塞尔) 编辑器。贝塞尔曲线是一串用来定义 CSS 的动画速度在整个动画过程中如何变化的 魔法数值 。我们将其定义为 transition-timing-function 或者 animation-timing-function CSS 属性。<br>像之前说的 Color picker 和 Shadow editor 一样，直接点击我们刚刚提到的属性(或者他们的简写形式：trasition， animation - 请注意：如果timing 函数的值没有设置在这个简写的形式中，这个符号不会显示出来)边上的曲线符号：<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-3-6.gif"><br>顺带说一句，如果你没有试过 3D 动画，也很简单：直接在容器元素中设置一个 perspective 属性。例如：在 body 元素中设置 perspective: 200px;</p><h2 id="7-插入样式规则的按钮"><a href="#7-插入样式规则的按钮" class="headerlink" title="7. 插入样式规则的按钮"></a>7. 插入样式规则的按钮</h2><p>当你把鼠标放在样式选择器的选择区域的最后时，你会看到几个让你可以快速的使用 Color 和 Shadow 编辑器添加 CSS 属性的按钮：</p><ul><li>text-shadow</li><li>box-shadow</li><li>color</li><li>background-color</li></ul><p>…打开相应的编辑器：<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-3-7.gif"></p><h2 id="8-在元素面板中展开所有的子节点"><a href="#8-在元素面板中展开所有的子节点" class="headerlink" title="8. 在元素面板中展开所有的子节点"></a>8. 在元素面板中展开所有的子节点</h2><p>一个一个的去点击级联的 ▶ 按钮太慢了，不如使用右击节点后的 expand recursively 命令：<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-3-8.gif"></p><h2 id="9-DOM-断点"><a href="#9-DOM-断点" class="headerlink" title="9. DOM 断点"></a>9. DOM 断点</h2><p>有时脚本修改了 DOM ，但修改的是哪部分？什么时候修改的呢？<br>这样的情况下，你就可以添加一个 DOM 断点：监听节点被添加或者移除 &#x2F; 属性被改变。</p><ul><li>点击”…” 符号或者右击你想添加监听的元素</li><li>选择 subtree modifications :监听任何它内部的节点被 移除 或者 添加的事件</li><li>选择 attribute modifications :监听任何当前选中的节点被 添加，移除 或者 被修改值的事件</li><li>选择 node removal :监听被选中的元素被 移除 的事件</li></ul><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-3-9.png"><br>页面重新加载时会记住断点。当你设置了一个或多个断点的时候，可能都忘了它们所标记的位置了。怎么找它们呢？：在 Elements 视图中有视觉提示，Sources 中也有专用列表。<br>有时你添加了断点的元素被隐藏在一些折叠起来的父级元素中，不要担心 - 他们会在 Element 中用高亮展示出来。<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-3-10.png"></p><h1 id="颜色选择器"><a href="#颜色选择器" class="headerlink" title="颜色选择器"></a>颜色选择器</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果你从来没有仔细的查看过颜色选择器，很正常，因为它确实毫不起眼：只有一些可以让我们选择的颜色。但仔细查看你会发现：DevTools 的开发团队在这个小玩意里面放了多到你想象不到信息。<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-3-11.gif"></p><h2 id="1-只选择你正在用的颜色"><a href="#1-只选择你正在用的颜色" class="headerlink" title="1. 只选择你正在用的颜色"></a>1. 只选择你正在用的颜色</h2><p>介绍颜色选择器的一部分：</p><ul><li>切换到一个有色调变化的 Material 调色板</li><li>自定义，可以添加和删除颜色</li><li>从 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/Using_CSS_variables">CSS Variables</a> 中选择一个你当前页面使用的样式表中存在的颜色。</li><li>或者所有你在页面的 CSS 中使用的颜色</li></ul><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-3-12.png"></p><h2 id="2-直观的选择你的颜色"><a href="#2-直观的选择你的颜色" class="headerlink" title="2. 直观的选择你的颜色"></a>2. 直观的选择你的颜色</h2><p>打开一个文本的调色选择器(是 color 属性， 而不是 background-color) 你会看到 “Contrast ratio(对比度)” 部分。它显示了 <strong>文本的颜色</strong> 与 <strong>开发者工具认为这段文本应该有的背景颜色</strong> 之间的对比度。如果这个数值很高，那么你的文本相对于背景来说，更显而易见，但如果这个值接近 1 ，那么文本的颜色几乎不能从背景色中区分。</p><ul><li>在数字边上的 “🚫” 意味着对比度太低了。</li><li>一个 “✅” 意味着这个颜色遵从 <a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/conformance.html">Web Content Accessibility Guidelines (WCAG) 2.0</a> 的 <strong>AA</strong> 声明，这意味着对比值至少为 3，</li><li>“✅ ✅” 意味着满足了 <strong>AAA</strong> 声明。</li></ul><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-3-13.gif"><br>另外，你可以通过点击上文提到的 AA ， AAA 或者 🚫 符号来阅读更多关于<a href="https://developers.google.com/web/fundamentals/accessibility/accessible-styles#color_and_contrast">accessibility rules</a> 中颜色的说明。<br>如果你继续探索 对比度 的部分，还可以看到更多的信息，甚至可以选择一个不同的颜色作为背景颜色进行对比，对应的 color spectrum(色谱) 部分现在会显示一个对比的边界线：如果你的背景颜色比这条线上面的颜色更深，代表兼容 <strong>AA</strong> ，如果背景颜色比这条线上面的更亮，你需要在这条线的下面选择一个颜色。</p>]]></content>
    
    
    <categories>
      
      <category>前端开发手册</category>
      
      <category>Debug 大作战：浏览器调试全攻略</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器调试,谷歌开发者工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Console 面板</title>
    <link href="/2024/06/01/frontendGuide/browserDebug/chromeDevtools/consolePanel/"/>
    <url>/2024/06/01/frontendGuide/browserDebug/chromeDevtools/consolePanel/</url>
    
    <content type="html"><![CDATA[<h1 id="console-中的-‘-’"><a href="#console-中的-‘-’" class="headerlink" title="console 中的 ‘$’"></a>console 中的 ‘$’</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>$ 作为 jQuery 的选择器，承载了一代前端的太多记忆，但是你可能没有想到的是，在我们使用 Dev Tools 进行调试的时候，$ 也有大放异彩的一天呢？</p><h2 id="1-0"><a href="#1-0" class="headerlink" title="1. $0"></a>1. $0</h2><p>在 Chrome 的 Elements 面板中， $0 是对我们当前选中的 html 节点的引用。<br>理所当然，$1 是对上一次我们选择的节点的引用，$2 是对在那之前选择的节点的引用，等等。一直到 $4<br>你可以尝试一些相关操作(例如: $1.appendChild($0))<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-4-1.awebp"></p><!-- ## 1. $ 和 ?如果你没有在 App 中定义过 $ 变量 (例如 jQuery )的话，它在 console 中就是对这一大串函数 document.querySelector 的别名。如果是 ? 就更加厉害了，还能节省更多的时间，因为它不仅执行 document.QuearySelectorAll 并且它返回的是：一个节点的 **数组** ，而不是一个 Node list本质上来说 Array.from(document.querySelectorAll('div')) === ?('div') ，但是document.querySelectorAll('div') 和 ?('div') 哪一种方式更加优雅呢？ --><h2 id="2"><a href="#2" class="headerlink" title="2. $_"></a>2. $_</h2><p>调试的过程中，你经常会通过打印查看一些变量的值，但如果你想看一下上次执行的结果呢？再输一遍表达式吗？<br>这时候 $_ 就派上了用场，$_ 是对上次执行的结果的 <strong>引用</strong> ：<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-4-2.awebp"></p><h2 id="3-i"><a href="#3-i" class="headerlink" title="3. $i"></a>3. $i</h2><p>现在的前端开发过程，离不开各种 npm 插件，但你可能没有想过，有一天我们竟然可以在 Dev Tools 里面来使用 npm 插件！<br>有时你只是想玩玩新出的 npm 包，现在不用再大费周章去建一个项目测试了，只需要在 <a href="https://chrome.google.com/webstore/detail/console-importer/hgajpakhafplebkdljleajgbpdmplhie/related">Chrome插件:Console Importer</a> 的帮助之下，快速的在 console 中引入和测试一些 npm 库。<br>运行 $i(‘lodash’) 或者 $i(‘moment’) 几秒钟后，你就可以获取到 lodash &#x2F; momentjs 了:<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-4-3.awebp"></p><h1 id="console-log-的-“bug”"><a href="#console-log-的-“bug”" class="headerlink" title="console.log 的 “bug” ?"></a>console.log 的 “bug” ?</h1><p>一般来说，我们会使用 console.log() 来打印某个对象，并且，两次打印之间，还会对这个对象进行修改，最后我们查看打印的结果发现，修改前的打印和修改后的打印，竟然是一样的？这样出乎意料的情况，让我们难以继续 console.log 的调试。<br>口说无凭，举个例子把：<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-4-4.awebp"><br>我们可以看到，一共有两次打印，一次是打印原始信息，一次是打印我们修改后的信息，并且我们把属性 a 从 0 改成 1 ，name 属性从 Tomek 改成 Not Tomek<br>但打印的时候，两次都是我们修改之后的值？<br>那，为什么会出现这一现象？<br>说明：<br>console 中打印出的对象，在你打印出他内容之前，是以引用的方式保存的。<br>知道了原因，对应的就知道该怎么处理这样的情况了：</p><ul><li>打印一个从这个对象复制出来的对象。</li><li>使用资源面中的断点来调试</li><li>使用 JSON.stringify() 方法处理打印的结果</li><li>更多你可以想到的好方法~</li></ul><h1 id="异步的-console"><a href="#异步的-console" class="headerlink" title="异步的 console"></a>异步的 console</h1><p>如今，越来越多与浏览器有关的 API 都是 <em>基于 Promise 的</em> 。当你使用 promise 的时候通常配套用 .then(处理方法) 或者 将 promise 包裹在 async 方法中，再使用 await 来接收结果。<br>我们在 JavaScript&#x2F;TypeScript 中大量使用的东西，但如果在 Console 中书写这样的结构很不方便。<br>像下面这样<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-4-5.awebp"><br>或者这样<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-4-6.awebp"><br>这样太难用了！不是输入之前就被触发了，就是括号漏写了…<br><strong>但如果 console 默认就被 async 包裹呢？</strong><br>你猜怎么着，还真是这样！你可以直接使用 await ：<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-4-7.awebp"><br>事实上,在 Console 中使用 promise 比在源码中使用起来还要简单！</p><h2 id="1-用你的异步console-来看一些更酷的东西"><a href="#1-用你的异步console-来看一些更酷的东西" class="headerlink" title="1. 用你的异步console 来看一些更酷的东西"></a>1. 用你的异步console 来看一些更酷的东西</h2><p>我和你一样，觉得 fetch 的例子相当无聊 – 所以再来一个新玩法：通过 console 来获取到更多有意思的信息。</p><ul><li><p>Storage 系统的 <strong>占用数</strong> 和 <strong>空闲数</strong></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">await navigator<span class="hljs-selector-class">.storage</span><span class="hljs-selector-class">.estimate</span>()<br></code></pre></td></tr></table></figure><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-4-8.awebp"></p></li><li><p>设备的 <strong>电池信息</strong></p></li></ul><p>为了达到更好的效果，我们将这个技巧和前几天中提到的 console.table 来合并使用：<br>敲黑板：这是一条<a href="https://developer.mozilla.org/en-US/docs/Web/API/Battery_Status_API">不推荐使用的API</a>,尽管看起来这么酷炫…<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-4-9.awebp"></p><ul><li><strong>媒体能力</strong></li></ul><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-4-10.awebp"></p><ul><li><strong>Cache storage keys</strong></li></ul><p>(注：<a href="https://developer.mozilla.org/en-US/docs/Web/API/CacheStorage">Cache storage keys</a> 一般用来对 request 和 response 进行缓存)<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-4-11.awebp"><br>更多的例子就不一一举例了。</p><h1 id="Ninja-console-log-（忍者打印）"><a href="#Ninja-console-log-（忍者打印）" class="headerlink" title="Ninja console.log （忍者打印）"></a>Ninja console.log （忍者打印）</h1><p>有时你设置的断点是不是被执行了太多次？假设有一个包含 200 个元素的循环，但是你只对第 110 次循环的结果感兴趣，又或者你只对一些满足某些条件的结果感兴趣，怎么办呢？这就是我们要说的条件断点：</p><h2 id="1-Conditional-breakpoints-条件断点"><a href="#1-Conditional-breakpoints-条件断点" class="headerlink" title="1. Conditional breakpoints 条件断点"></a>1. Conditional breakpoints 条件断点</h2><p>这样的情况下，你可以设置一个条件断点：</p><ul><li>右击行号，选择 Add conditional breakpoint…(添加条件断点)</li><li>或者右击一个已经设置的断点并且选择 Edit breakpoint(编辑断点)</li><li>然后输入一个执行结果为 true 或者 false 的表达式（它的值其实不需要完全为 true 或者 false 尽管那个弹出框的描述是这样说的）。</li></ul><p>在这个表达式中你可以使用任何这段代码可以获取到的值（当前行的作用域）。<br>如果条件成立，这个断点就会暂停代码的执行：<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-4-12.awebp"></p><h2 id="2-The-ninja（忍者）-console-log"><a href="#2-The-ninja（忍者）-console-log" class="headerlink" title="2. The ninja（忍者） console.log"></a>2. The ninja（忍者） console.log</h2><p>得益于条件断点， console.log 也有了新玩法：</p><ul><li>每一个条件都必须经过判断 - 当应用执行到这一行的时候进行判断</li><li>并且如果条件返回的是 falsy 的值(这里的 falsy并非是笔误，falsy 指的是被判定为 false 的值，例如 undefined )，它并不会暂停..</li></ul><p>与其在你的源码的不同地方去添加 console.log &#x2F; console.table &#x2F; console.time 等等，不如你直接使用条件判断来将它们“连接”到 Source 面板中。 这样的话，它们会一直执行，并且当你不再需要它们的时候，在 Breakpoints section 会清晰的列出它们。点两下鼠标你就可以把所有的都移除，就像一堆忍者一样突然消失！</p><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-4-13.awebp"></p><p>这个技术在调试生产环境的问题时同样很有用，因为你通过这样的方式轻松将 console logs 插入到 source 里。</p><h1 id="自定义格式转换器"><a href="#自定义格式转换器" class="headerlink" title="自定义格式转换器"></a>自定义格式转换器</h1><h2 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h2><p>大多数的情况下，我们习惯使用 DevTools 的 console 默认对 object 的转换，但有时候我们想用与众不同的方式来处理。 那我们就可以自定义输出对象的函数，它通常被称为 Custom Formatter 。<br>请注意: 在我们写一个之前，需要在 DevTools 进行设置 (在 DevTools 的 ⋮ 下拉框找到设置，或者按下 F1 ) 中把对应的设置打开:<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-4-14.awebp"><br>formatter 长什么样呢？ 它是一个对象，最多包含三个方法：</p><ul><li>header : 处理如何展示在 console 的日志中的主要部分。</li><li>hasbody : 如果你想显示一个用来展开对象的 ▶ 箭头，返回 true</li><li>body : 定义将会被显示在展开部分的内容中。</li></ul><p>一个基础的自定义 formatter<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-4-15.awebp"><br>例子里移除了循环的结构的错误处理，让它看起来更加简洁<br>header 方法返回了一个 <a href="http://www.jsonml.org/">JsonML</a> (注： JsonML : JSON Markup Language - JSON 标记语言) 数组，由这些组成：</p><ol><li>标签名</li><li>属性对象</li><li>内容 (文本值或者其他元素)</li></ol><p>(如果看起来很眼熟的话，那可能是因为你之前写过一些 <a href="https://reactjs.org/docs/react-without-jsx.html">React 代码</a> :D)<br>在输出的时候，这个简单的 formatter 对于每一层嵌套，直接以 7 个空格的缩进打印这个对象。所以现在我们的输出看起来是这样：<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-4-16.awebp"></p><h2 id="1-自定义格式化转换器的应用实践"><a href="#1-自定义格式化转换器的应用实践" class="headerlink" title="1. 自定义格式化转换器的应用实践"></a>1. 自定义格式化转换器的应用实践</h2><p>现有好几种 custom formatter 可供选择，例如：你可以在这个 <a href="https://github.com/andrewdavey/immutable-devtools">immutable-devtools</a>仓库中找到对于 <a href="https://facebook.github.io/immutable-js/">Immutable.js</a> 结构的完美展示。但你同样可以自己造一个。<br>一般来说，每当你遇到结构不寻常的对象时，或大量的日志(最好避免这样的情况，但是有时候很有用)而你想从中做区分时，你可以采用 custom formatter 来处理。<br>一个很实用的窍门：直接将你不关心，不需要区别对待的对象过滤出来，直接在 header 方法里面 return null。让 DevTools 使用默认的格式化方式来处理这些值。<br>撇开实用性，我们还可以找点乐子：<br>这是一个关于 console 的蠢萌例子：它叫做 console.clown() :将打印对象进行转换，而且在对象前面加上一个 emoji 表情 …<br><a href="https://gist.github.com/sulco/e635a7511d5ff17d44fe9bb2ab8b3cc6">源码在这里</a>为了方便大家尝试，源码贴在下面：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">window</span>.<span class="hljs-property">devtoolsFormatters</span> = [&#123;<br>    <span class="hljs-attr">header</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>)&#123;<br>      <span class="hljs-keyword">if</span> (!obj.<span class="hljs-property">__clown</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>      &#125;<br>      <span class="hljs-keyword">delete</span> obj.<span class="hljs-property">__clown</span>;<br>      <span class="hljs-keyword">const</span> style = <span class="hljs-string">`</span><br><span class="hljs-string">        color: red;</span><br><span class="hljs-string">        border: dotted 2px gray;</span><br><span class="hljs-string">        border-radius: 4px;</span><br><span class="hljs-string">        padding: 5px;</span><br><span class="hljs-string">      `</span><br>      <span class="hljs-keyword">const</span> content = <span class="hljs-string">`🤡 <span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(obj, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>)&#125;</span>`</span>;<br><br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> [<span class="hljs-string">&#x27;div&#x27;</span>, &#123;style&#125;, content]<br>      &#125; <span class="hljs-keyword">catch</span> (err) &#123; <span class="hljs-comment">// for circular structures</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <span class="hljs-comment">// use the default formatter</span><br>      &#125;<br>    &#125;,<br>    <span class="hljs-attr">hasBody</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;]<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-property">clown</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(&#123;...obj, <span class="hljs-attr">__clown</span>: <span class="hljs-literal">true</span>&#125;);<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(&#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;hello!&#x27;</span>&#125;);   <span class="hljs-comment">// normal log</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">clown</span>(&#123;<span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;hello!&#x27;</span>&#125;); <span class="hljs-comment">// a silly log</span><br></code></pre></td></tr></table></figure><p>如你所见，我使用 console.clown 方法打印出来的对象被添加了一个特殊的属性，便于将它区分出来，并且在 formatter 中对它区别处理，但在大部分现实的案例中，这样更好：比如检查这个对象是不是某一个特殊类的实例等等。<br>对了，clown 打印出来了什么东西呢？ 在下面：<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-4-17.awebp"></p><h1 id="console中骚操作"><a href="#console中骚操作" class="headerlink" title="console中骚操作"></a>console中骚操作</h1><h2 id="前言-2"><a href="#前言-2" class="headerlink" title="前言"></a>前言</h2><p>我最开始接触前端的时候，学会用的就是 console.log ，甚至现在，大部分情况也还在用它调试，但是，在不同的场景下，除了 log ，其实有更好的选择。</p><h2 id="1-console-assert"><a href="#1-console-assert" class="headerlink" title="1. console.assert"></a>1. console.assert</h2><p>在 <a href="https://link.juejin.cn/?target=https://developer.mozilla.org/en-US/docs/Web/API/console/assert">MDN</a> 中是这样定义的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">assert</span>(assertion, obj1 [, obj2, ..., objN]);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">assert</span>(assertion, msg [, subst1, ..., substN]); <span class="hljs-comment">// c-like message formatting</span><br></code></pre></td></tr></table></figure><p>当我们传入的第一个参数为 <strong>假</strong> 时，console.assert 打印跟在这个参数后面的值。<br>这个方法适用于什么情况呢？举个栗子：<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-4-22.awebp"><br>通过它，你可以摆脱令人讨厌的 if 表达式，还可以获得堆栈信息。<br>请注意，<strong>如果你使用的 NodeJS 版本 ≤ 10.0 ， console.assert 可能会中断后面代码的执行</strong>，但是在 .10 的版本中被修复了(当然，在浏览器中不存在这个问题)</p><h2 id="2-增强-log-的阅读体验"><a href="#2-增强-log-的阅读体验" class="headerlink" title="2. 增强 log 的阅读体验"></a>2. 增强 log 的阅读体验</h2><p>有时即使你 console.log 一个简单的变量，你可能会忘记（或混淆）哪一个是那个。那当你有不同的变量需要打印的时候，阅读起来会更费劲。<br>假如有这么一堆你想要输出但看起来并不易读的数据 <img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-4-23.awebp"><br><strong>“哪一个值对应哪一个变量来着？”</strong><br>为了让它变得更加易读，你可以打印一个对象 - 只需将所有 console.log 的参数包装在大括号中。感谢 ECMAScript 2015 中引入了 enhanced object literal(增强对象文字面量) ，所以加上 {} 已经是你需要做的全部事情了：<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-4-24.awebp"></p><h2 id="3-console-table"><a href="#3-console-table" class="headerlink" title="3.console.table"></a>3.console.table</h2><p>console.table 这个小技巧在开发者中可能并没有多少人知道: 如果有一个 <strong>数组</strong> (或者是 <strong>类数组</strong> 的对象，或者就是一个 <strong>对象</strong> )需要打印，你可以使用 console.table 方法将它以一个漂亮的表格的形式打印出来。它不仅会根据数组中包含的对象的所有属性，去计算出表中的列名，而且这些列都是可以 <strong>缩放</strong> 甚至 <strong>还可以排序!!!</strong><br>如果你觉得展示的列太多了，使用第二个参数，传入你想要展示的列的名字:<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-4-25.awebp"><br>对于后台而言，只有 node 版本大于 10 以上， console.table 才能起作用</p><h2 id="4-table-和-的配合"><a href="#4-table-和-的配合" class="headerlink" title="4. table 和 {} 的配合"></a>4. table 和 {} 的配合</h2><p>我们刚刚看到了 console.table 这个技巧，也了解了在他上面的 {} ，那么我们为什么不将他们结合起来打造一个终极 log 呢？<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-4-26.awebp"></p><h2 id="5-console-dir"><a href="#5-console-dir" class="headerlink" title="5. console.dir"></a>5. console.dir</h2><p>有时候你想要打印一个 DOM 节点。 console.log 会将这个交互式的元素渲染成像是从 Elements 中剪切出来的一样。如果说你想要查看 <strong>这个节点所关联到的真实的js对象</strong> 呢？并且想要查看他的 <strong>属性</strong> 等等？<br>在那样的情况下，就可以使用console.dir:<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-4-27.awebp"></p><h2 id="6-给-logs-加上时间戳"><a href="#6-给-logs-加上时间戳" class="headerlink" title="6. 给 logs 加上时间戳"></a>6. 给 logs 加上时间戳</h2><p>我们总是需要打印各式各样的信息，之前我们讨论了如何让输出的信息更加直观，但是如果我们需要打印相关的时间信息呢？这就用到了计时的相关操作。<br>如果你想要给你的应用中发生的事件加上一个确切的时间记录，开启 <em>timestamps</em> 。你可以在设置(在调试工具中的 ⋮ 下拉中找到它，或者按下 F1 )中来开启或者使用 <a href="https://medium.com/@tomsu/devtools-tips-day-6-thecommand-menu-449eb3966d9#7404">Commands Menu</a>：<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-4-28.awebp"></p><h2 id="7-监测执行时间"><a href="#7-监测执行时间" class="headerlink" title="7.监测执行时间"></a>7.监测执行时间</h2><p>与其在所有事上展示一个时间戳，或许你对脚本中的特殊的节点之间执行的时间跨度更加感兴趣，对于这样的情况，我们可以采用一对有效的 console 方法</p><ul><li>console.time() — 开启一个计时器</li><li>console.timeEnd() — 结束计时并且将结果在 console 中打印出来</li></ul><p>如果你想一次记录多件事，可以往这些函数中传入不同的标签值。(例如: console.time(‘loading’) ， console.timeEnd(‘loading’) )<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-4-29.awebp"></p><h2 id="8-给你的-console-log-加上-CSS-样式"><a href="#8-给你的-console-log-加上-CSS-样式" class="headerlink" title="8. 给你的 console.log 加上 CSS 样式"></a>8. 给你的 console.log 加上 CSS 样式</h2><p>如果你给打印文本加上 %c 那么 console.log 的第二个参数就变成了CSS 规则！这个特性可以让你的日志脱颖而出(例如 <a href="https://www.facebook.com/">Facebook</a> 在你打开 console 的时候所做的一样)<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-4-30.awebp"></p><h2 id="9-让-console-log-基于调用堆栈自动缩进"><a href="#9-让-console-log-基于调用堆栈自动缩进" class="headerlink" title="9. 让 console.log 基于调用堆栈自动缩进"></a>9. 让 console.log 基于调用堆栈自动缩进</h2><p>配合 Error 对象的 stack 属性，让你的 log 可以根据堆栈的调用自动缩进：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">log</span>(<span class="hljs-params">message</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<br>        <span class="hljs-comment">// 这句话是重点当我们 new 出来的 Error 对象时，会匹配它的stack 信息中的换行符，换行符出现的次数也等同于它在堆栈调用时的深度。</span><br>        <span class="hljs-string">&#x27; &#x27;</span>.<span class="hljs-title function_">repeat</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>().<span class="hljs-property">stack</span>.<span class="hljs-title function_">match</span>(<span class="hljs-regexp">/\n/g</span>).<span class="hljs-property">length</span> - <span class="hljs-number">2</span>) + message<br>      );<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">bar</span>() + <span class="hljs-title function_">bar</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;bar&#x27;</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">baz</span>() + <span class="hljs-title function_">baz</span>();<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;baz&#x27;</span>);<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">17</span>;<br>    &#125;<br><br>    <span class="hljs-title function_">foo</span>();<br></code></pre></td></tr></table></figure><p>运行结果如下：<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-4-31.awebp"></p><h2 id="10-直接在回调中使用-console-log"><a href="#10-直接在回调中使用-console-log" class="headerlink" title="10. 直接在回调中使用 console.log"></a>10. 直接在回调中使用 console.log</h2><p>是不是经常有这样的情况，就是我确定要将什么传递给回调函数。在这种情况下，我会在里面添加一个 console.log 来检查。<br>有两种方式来实现：</p><ul><li>在回调方法的内部使用 console.log</li><li><strong>直接使用 consolelog 来作为回调方法</strong>。</li></ul><p>我推荐使用第二种，因为这不仅减少了输入，还可能在回调中接收多个参数。(这在第一个解决方案中是没有的)<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-4-32.awebp"></p><h2 id="11-使用实时表达式"><a href="#11-使用实时表达式" class="headerlink" title="11. 使用实时表达式"></a>11. 使用实时表达式</h2><p>在本文形成的不久前，DevTools 在 Console 面板中引入了一个非常漂亮的附加功能，这是一个名为 Live expression 的工具<br>只需按下 “眼睛” 符号，你就可以在那里定义任何 JavaScript 表达式。 它会不断更新，所以表达的结果将永远，存在 :-)<br>同时支持定义好几个：<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-4-33.awebp"></p>]]></content>
    
    
    <categories>
      
      <category>前端开发手册</category>
      
      <category>Debug 大作战：浏览器调试全攻略</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器调试,谷歌开发者工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Network面板</title>
    <link href="/2024/06/01/frontendGuide/browserDebug/chromeDevtools/networkPanel/"/>
    <url>/2024/06/01/frontendGuide/browserDebug/chromeDevtools/networkPanel/</url>
    
    <content type="html"><![CDATA[<h2 id="1-隐藏-network-overview"><a href="#1-隐藏-network-overview" class="headerlink" title="1. 隐藏 network overview"></a>1. 隐藏 network overview</h2><p>你经常查看 Network 面板是为了:</p><ul><li>我想看看请求的时间轴信息</li><li>我就想看看请求列表- 确认下请求状态，资源大小和响应结果呢</li></ul><p>我赌你是后者，如果是这样，那么 Overview 的部分就没有任何理由占用 Network 接近一半的空间。隐藏它！<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-5-1.png"></p><h2 id="2-Request-initiator-显示了调用堆栈信息"><a href="#2-Request-initiator-显示了调用堆栈信息" class="headerlink" title="2. Request initiator 显示了调用堆栈信息"></a>2. Request initiator 显示了调用堆栈信息</h2><p>initiator 可以翻译为 启动器，但是太过生硬，大家理解意思就好。<br>Network 面板中的 initiator 这一列显明了是哪个脚本的哪一行触发了请求。它显示了在调用堆栈中触发请求的最后一步。但如果你用的是，例如：一个本地化的 fetch API， 那它将会指向一些低层级的类库的代码 - 例如 当我们在 Angular 配合使用 Axios 或者 zone.js 的时候，这时指向的是 xhr.js<br>除了这些外部库之外，如果你希望查看代码的哪一部分触发了请求。 将鼠标悬停在显示的 initiator（例如 外部库）上，你将看到完整的调用堆栈，包括你的文件：<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-5-2.gif"></p><h2 id="3-请求过滤"><a href="#3-请求过滤" class="headerlink" title="3. 请求过滤"></a>3. 请求过滤</h2><p>Network 面板中的过滤器输入框接受字符串或正则表达式，对应显示匹配的请求。 但是你也可以使用它来过滤很多属性。<br>只需输入 例如 method 或者 mime-type :<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-5-3.gif"><br>如果想要显示所有可能的关键字，在空白的输入框按下 [ctrl] + [space]</p><h2 id="4-自定义请求表"><a href="#4-自定义请求表" class="headerlink" title="4. 自定义请求表"></a>4. 自定义请求表</h2><p>在请求表中，你可以看到有关每个请求的几条信息，例如：Status， Type， Initiator， Size 和 Time。但是你同样可以添加更多(例如 我经常添加 Method)。更多：<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-5-4.png"><br>你可以添加所有 Network 面板里展示出来的信息。<br>要自定义显示哪些列，右键单击请求表标题上的任意位置。<br>请注意，Response Headers 是一个有更多选项的完整的子菜单，甚至可以定义你自己的选项。<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-5-5.gif"></p><h2 id="5-重新发送-XHR-的请求"><a href="#5-重新发送-XHR-的请求" class="headerlink" title="5. 重新发送 XHR 的请求"></a>5. 重新发送 XHR 的请求</h2><p>如何重新发送 XHR 的请求？刷新页面？太老套了，试试这么做：<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-5-6.gif"></p><h2 id="6-XHR-fetch-断点"><a href="#6-XHR-fetch-断点" class="headerlink" title="6. XHR&#x2F;fetch 断点"></a>6. XHR&#x2F;fetch 断点</h2><p>在某一特定时刻，你想要对已发送的 “ajax” 请求进行捕获怎么做呢？ 可以使用 XHR&#x2F;fetch breakpoint 。<br>这些只能在 Source 面板中设置。（我也同样希望可以直接在 Network 面板中设置，但事实并非如此）<br>你可以添加部分 URL 作为触发器或监听任何请求：<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-5-7.png"></p>]]></content>
    
    
    <categories>
      
      <category>前端开发手册</category>
      
      <category>Debug 大作战：浏览器调试全攻略</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器调试,谷歌开发者工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Performance面板</title>
    <link href="/2024/06/01/frontendGuide/browserDebug/chromeDevtools/performancePanel/"/>
    <url>/2024/06/01/frontendGuide/browserDebug/chromeDevtools/performancePanel/</url>
    
    <content type="html"><![CDATA[<h1 id="如何用-Performance-工具分析并优化性能"><a href="#如何用-Performance-工具分析并优化性能" class="headerlink" title="如何用 Performance 工具分析并优化性能"></a>如何用 Performance 工具分析并优化性能</h1><p>Chrome DevTools 的 Performance 工具是性能分析和优化的利器，因为它可以记录每一段代码的耗时，进而分析出性能瓶颈，然后做针对性的优化。<br>这么强大的工具肯定是要好好掌握的，今天我们就来做一个性能优化的案例来快速上手 Performance 吧。</p><h2 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h2><p>首先，我们准备这样一段代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>worker performance optimization<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">           <span class="hljs-title function_">b</span>();</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">b</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;</span><br><span class="language-javascript">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i&lt; <span class="hljs-number">10</span>*<span class="hljs-number">10000</span>*<span class="hljs-number">10000</span>; i++) &#123;</span><br><span class="language-javascript">                total += i;</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;b:&#x27;</span>, total);</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-title function_">a</span>();</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">c</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-title function_">d</span>();</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        <span class="hljs-keyword">function</span> <span class="hljs-title function_">d</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;</span><br><span class="language-javascript">            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i&lt; <span class="hljs-number">1</span>*<span class="hljs-number">10000</span>*<span class="hljs-number">10000</span>; i++) &#123;</span><br><span class="language-javascript">                total += i;</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;c:&#x27;</span>, total);</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">        <span class="hljs-title function_">c</span>();</span><br><span class="language-javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>很明显，两个 script 标签是两个宏任务，第一个宏任务的调用栈是 a、b，第二个宏任务的调用栈是 c、d。<br>我们用 Performance 来看一下是不是这样：<br>首先用无痕模式打开 chrome，无痕模式下没有插件，分析性能不会受插件影响。<br>打开 chrome devtools 的 Performance 面板，点击 reload 按钮，会重新加载页面并开始记录耗时：<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-6-1.png"><br>过几秒点击结束。<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-6-2.png"><br>这时候界面就会展示出记录的信息：<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-6-3.png"><br>图中标出的 Main 就是主线程。其余的 Frames、Network 等是浏览器的其他线程。<br>主线程是不断执行 Event Loop 的，可以看到有两个 Task（宏任务），调用栈分别是 a、b 和 c、d，和我们分析的对上了。（当然，还有一些浏览器内部的函数，比如 parseHtml、evaluateScript 等，这些可以忽略）<br><strong>Performance 工具最重要的是分析主线程的 Event Loop，分析每个 Task 的耗时、调用栈等信息。</strong><br>当你点击某个宏任务的时候，在下面的面板会显示调用栈的详情（选择 bottom-up 是列表展示， call tree 是树形展示）<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-6-4.png"><br>每个函数的耗时也都显示在左侧，右侧有源码地址，点击就可以跳到 Sources 对应的代码。<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-6-5.png"><br>直接展示了每行代码的耗时，太方便了！<br>工具介绍完了，我们来分析下代码哪里有性能问题。<br>很明显， b 和 d 两个函数的循环累加耗时太高了。<br>在 Performance 中也可以看到 Task 被标红了，下面的 summary 面板也显示了 long task 的警告。<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-6-6.png"><br>有同学可能会问：为什么要优化 long task 呢？<br><strong>因为渲染和 JS 执行都在主线程，在一个 Event Loop 中，会相互阻塞，如果 JS 有长时间执行的 Task，就会阻塞渲染，导致页面卡顿。所以，性能分析主要的目的是找到 long task，之后消除它。</strong><br>找到了要优化的代码，也知道了优化的目标（消除 long task），那么就开始优化吧。</p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>我们优化的目标是把两个 long task 中的耗时逻辑（循环累加）给去掉或者拆分成多个 task。<br>关于拆分 task 这点，可以参考 React 从递归渲染 vdom 转为链表的可打断的渲染 vdom 的优化，也就是 fiber 的架构，它的目的也是为了拆分 long task。<br>但明显我们这里的逻辑没啥好拆分的，它就是一个大循环。<br>那么能不能不放在主线程跑，放到其他线程跑呢？浏览器的 web worker 好像就是做耗时计算的性能优化的。<br>我们来试一下：<br>封装这样一个函数，传入 url 和数字，函数会创建一个 worker 线程，通过 postMessage 传递 num 过去，并且监听 message 事件来接收返回的数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">runWorker</span>(<span class="hljs-params">url, num</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(url);<br>        worker.<span class="hljs-title function_">postMessage</span>(num);<br>        worker.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">evt</span>) &#123;<br>            <span class="hljs-title function_">resolve</span>(evt.<span class="hljs-property">data</span>);<br>        &#125;);<br>        worker.<span class="hljs-property">onerror</span> = reject;<br>    &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><p>然后 b 和 c 函数就可以改成这样了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">b</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">runWorker</span>(<span class="hljs-string">&#x27;./worker.js&#x27;</span>, <span class="hljs-number">10</span>*<span class="hljs-number">10000</span>*<span class="hljs-number">10000</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;b:&#x27;</span>, res);<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>耗时逻辑移到了 worker 线程：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">evt</span>) &#123;<br>    <span class="hljs-keyword">let</span> total = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> num = evt.<span class="hljs-property">data</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i&lt; num; i++) &#123;<br>        total += i;<br>    &#125;<br>    <span class="hljs-title function_">postMessage</span>(total);<br>&#125;);<br></code></pre></td></tr></table></figure><p>完美。我们再跑一下试试：<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-6-7.png"><br>哇，long task 一个都没有了！<br>然后你还会发现 Main 线程下面多了两个 Worker 线程：<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-6-8.png"><br>虽然 Worker 还有 long task，但是不重要，毕竟计算量在那，只要主线程没有 long task 就行。<br>这样，我们通过把计算量拆分到 worker 线程，充分利用了多核 cpu 的能力，解决了主线程的 long task 问题，界面交互会很流畅。<br>我们再看下 Sources 面板：<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-6-9.png"><br>对比下之前的：<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-6-10.png"><br>这优化力度，肉眼可见！<br>就这样，我们一起完成了一次网页的性能优化，通过 Peformance 分析出 long task，定位到耗时代码，然后通过 worker 拆分计算量进行优化，成功消除了主线程的 long task。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Chrome DevTools 的 Performance 工具是网页性能分析的利器，它可以记录一段时间内的代码执行情况，比如 Main 线程的 Event Loop、每个 Event loop 的 Task，每个 Task 的调用栈，每个函数的耗时等，还可以定位到 Sources 中的源码位置。<br>性能优化的目标就是找到 Task 中的 long task，然后消除它。因为网页的渲染是一个宏任务，和 JS 的宏任务在同一个 Event Loop 中，是相互阻塞的。<br>我们做了一个真实的优化案例，通过 Performance 分析出了代码中的耗时部分，发现是计算量大导致的，所以我们把计算逻辑拆分到了 worker 线程以充分利用多核 cpu 的并行处理能力，消除了主线程的 long task。<br>做完这个性能优化的案例之后，是不是觉得 Peformance 工具用起来也不难呢？<br>其实会分析主线程的 Event Loop，会分析 Task 和 Task 的调用栈，找出 long task，并能定位到耗时的代码，Performance 工具就算是掌握了大部分了，常用的功能也就是这些。</p>]]></content>
    
    
    <categories>
      
      <category>前端开发手册</category>
      
      <category>Debug 大作战：浏览器调试全攻略</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器调试,谷歌开发者工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Application面板</title>
    <link href="/2024/06/01/frontendGuide/browserDebug/chromeDevtools/applicationPanel/"/>
    <url>/2024/06/01/frontendGuide/browserDebug/chromeDevtools/applicationPanel/</url>
    
    <content type="html"><![CDATA[<h2 id="面板概览"><a href="#面板概览" class="headerlink" title="面板概览"></a>面板概览</h2><blockquote><p>使用 Application 面板可以检查、修改和调试 Web 应用的许多方面，包括其清单、Service Worker、存储和缓存数据。</p></blockquote><p>Application（应用）面板分为四个部分，其中包含子菜单。</p><ul><li>Application：包含有关应用的整体信息，包括其清单、Service Worker 和存储空间。</li><li>Storage 存储：查看和修改 Web 应用使用的不同存储方法。<ul><li>借助本地和会话存储列表，您可以选择来源并修改关联存储方法的键值对。</li><li>IndexedDB 列表包含数据库，可让您通过浏览器检查对象存储。</li><li>通过 Cookie 列表，您可以选择来源并修改键值对。</li><li>借助私密状态令牌和兴趣群体，您可以检查相应的令牌和群组（如果有）。</li><li>通过共享存储空间列表，您可以选择源站，并检查和修改关联的键值对。</li><li>Cache storage 列表包含可用的缓存，可让您检查、过滤和删除其资源。</li></ul></li><li>Background services： 检查、测试和调试后台服务。</li><li>Frames：将网页和资源划分为多个视图，并显示相关信息，例如安全与隔离、内容安全政策、API 可用性等。</li></ul><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-7-1.png" alt="面板截图"></p><h2 id="存储的查看、添加、修改和删除"><a href="#存储的查看、添加、修改和删除" class="headerlink" title="存储的查看、添加、修改和删除"></a>存储的查看、添加、修改和删除</h2><blockquote><p>以下以Cookie为例，其他localStorage、sessionStorage、IndexedDB、Web SQL等类似。</p></blockquote><h3 id="打开“Cookies”窗格"><a href="#打开“Cookies”窗格" class="headerlink" title="打开“Cookies”窗格"></a>打开“Cookies”窗格</h3><ol><li><a href="https://developer.chrome.com/docs/devtools/open?hl=zh-cn">打开 Chrome 开发者工具</a>。</li><li>依次打开 <strong>Application</strong> &gt; <strong>Storage</strong> &gt; <strong>Cookies</strong>，然后选择一个来源。</li></ol><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-7-2.png"></p><h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><p><strong>Cookies</strong> 表包含以下字段：</p><ul><li><strong>名称</strong>：Cookie 的名称。</li><li><strong>值</strong>。Cookie 的值。</li><li><strong>网域</strong>。获准接收 Cookie 的主机。</li><li><strong>Path</strong>。所请求网址中必须存在的网址才能发送 Cookie 标头。</li><li><strong>到期时间 &#x2F; Max-Age</strong>。Cookie 的失效日期或最长存在时间。 对于<a href="https://developer.mozilla.org/docs/Web/HTTP/Cookies#define_the_lifetime_of_a_cookie">会话 Cookie</a>，此值始终为 Session。</li><li><strong>大小</strong>。Cookie 的大小（以字节为单位）。</li><li><strong>HttpOnly</strong>。如果为 true，此字段表示 Cookie 应仅通过 HTTP 使用，并且不允许修改 JavaScript。</li><li><strong>安全</strong>。如果为 true，此字段表示只能通过安全的 HTTPS 连接将 Cookie 发送到服务器。</li><li><strong>SameSite</strong>。如果 Cookie 使用的是实验性 SameSite 属性，则包含 Strict 或 Lax。</li><li><strong>分区键</strong>。对于<a href="https://developer.chrome.com/docs/privacy-sandbox/chips?hl=zh-cn">处于独立分区状态的 Cookie</a>，分区键是指在开始向设置 Cookie 的端点发出请求时，浏览器访问的顶级网址的网站。</li><li><strong>优先级</strong>。包含 Low、Medium（默认）或 High（如果使用的是已废弃的 <a href="https://bugs.chromium.org/p/chromium/issues/detail?id=232693">Cookie 优先级</a>属性）。</li></ul><p>要查看 Cookie 的值，请在表格中选中该 Cookie。如需查看未采用百分比编码的值，请勾选 check_box <strong>显示已解码的网址</strong>。</p><h3 id="过滤-Cookie"><a href="#过滤-Cookie" class="headerlink" title="过滤 Cookie"></a>过滤 Cookie</h3><p>使用<strong>过滤</strong>框按<strong>名称</strong>或<strong>值</strong>过滤 Cookie。</p><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-7-3.png"></p><p>不支持按其他字段过滤。过滤条件不区分大小写。</p><h3 id="添加-Cookie"><a href="#添加-Cookie" class="headerlink" title="添加 Cookie"></a>添加 Cookie</h3><p>要添加任意 Cookie，请执行以下操作：</p><ol><li>双击表格中的空行。</li><li>输入<strong>名称</strong>和<strong>值</strong>，然后按 Enter 键。</li></ol><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-7-4.gif"></p><p>开发者工具会自动填充其他必填字段。您可以按照下文所述修改它们。</p><h3 id="修改-Cookie"><a href="#修改-Cookie" class="headerlink" title="修改 Cookie"></a>修改 Cookie</h3><p>除了自动更新的 <strong>Size</strong>，其他所有字段都可修改。<br>双击某个字段即可进行修改。<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-7-5.png"></p><p>开发者工具以红色突出显示<a href="https://developer.chrome.com/docs/devtools/application/cookies?hl=zh-cn#fields">字段</a>值的 Cookie。</p><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-7-6.png"></p><p>如需滤除有效的 Cookie，请选中顶部操作栏中的 check_box <strong>仅显示存在问题的 Cookie</strong>。</p><h3 id="删除-Cookie"><a href="#删除-Cookie" class="headerlink" title="删除 Cookie"></a>删除 Cookie</h3><p>要删除 Cookie，请选择相应 Cookie，然后点击顶部操作栏中的 delete <strong>删除所选项</strong>。</p><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-7-7.png"></p><p>点击 <strong>全部清除</strong>以删除所有 Cookie。</p><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-7-8.png"></p><h3 id="识别和检查第三方-Cookie"><a href="#识别和检查第三方-Cookie" class="headerlink" title="识别和检查第三方 Cookie"></a>识别和检查第三方 Cookie</h3><p>第三方 Cookie 是由与当前顶级网页不同的网站设置的 Cookie。第三方 Cookie 具有 SameSite&#x3D;None 属性。<br>开发者工具会在<strong>应用</strong> &gt; <strong>存储</strong> &gt; <strong>Cookie</strong> 中列出此类 Cookie，并在它们旁边显示警告警告图标。将鼠标悬停在该图标上即可查看提示，点击该图标即可转到 <strong>Issues</strong> 面板了解详情。</p><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-7-9.png"></p><p>您还可在<a href="https://developer.chrome.com/docs/devtools/network/reference?hl=zh-cn#cookies">网络&gt; 点击请求 &gt;Cookie</a> 下找到第三方 Cookie。</p><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-7-10.png"></p><p><strong>网络</strong>面板会<a href="https://developer.chrome.com/docs/devtools/network/reference?hl=zh-cn#show-blocked-cookies">突出显示存在问题的 Cookie</a>，并在受<a href="https://developer.chrome.com/privacy-sandbox/3pcd?hl=zh-cn">第三方 Cookie 逐步淘汰</a>影响的 Cookie 旁边显示警告警告图标。</p>]]></content>
    
    
    <categories>
      
      <category>前端开发手册</category>
      
      <category>Debug 大作战：浏览器调试全攻略</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器调试,谷歌开发者工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Security面板</title>
    <link href="/2024/06/01/frontendGuide/browserDebug/chromeDevtools/securityPanel/"/>
    <url>/2024/06/01/frontendGuide/browserDebug/chromeDevtools/securityPanel/</url>
    
    <content type="html"><![CDATA[<p>Chrome 48 中引入的新“安全”面板可让您更轻松地查看证书和混合内容方面的任何问题。您可以直接在开发者工具中前往该页面，也可以点击网址栏的锁形图标，然后点击“详细信息”链接。</p><h2 id="解决“连接信息”问题"><a href="#解决“连接信息”问题" class="headerlink" title="解决“连接信息”问题"></a>解决“连接信息”问题</h2><p>对于那些想要获得网页安全性相关数据的用户，我们当前的解决方案是：点击网址旁边的小锁形图标，然后解析“连接”标签页中提供的信息。<br>很抱歉，此标签页存在几个问题：</p><ul><li>这对大多数用户来说太复杂了</li><li>但对大多数开发者来说太基础</li><li>并且不清楚导致锁形图标“降级”的原因</li></ul><h2 id="概览：介绍锁形图标和-Surface-混合内容"><a href="#概览：介绍锁形图标和-Surface-混合内容" class="headerlink" title="概览：介绍锁形图标和 Surface 混合内容"></a>概览：介绍锁形图标和 Surface 混合内容</h2><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-9-1.png"></p><p><strong>锁形图标</strong>表示网页的安全状态，因此了解它何时显示以及为什么显示它极为重要。新版“安全”面板中的“概览”屏幕介绍了构成安全网页的重要组成部分：</p><ul><li><strong>身份</strong>（证书）</li><li><strong>连接</strong>（协议、加密套件）</li><li><strong>子资源</strong></li></ul><p>现在，您一眼就能看出网站为什么会显示“超棒”的绿色小标记。<br>是否突然出现<strong>混合内容</strong>？不用担心。我们会直接在概览中显示该问题，点击一下则会进入网络面板的过滤视图，以便您快速查看违规请求：</p><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-9-2.png"></p><h2 id="源视图：连接类型和证书详情"><a href="#源视图：连接类型和证书详情" class="headerlink" title="源视图：连接类型和证书详情"></a>源视图：连接类型和证书详情</h2><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-9-3.png"></p><p>如果您需要有关特定 TLS 连接的信息，<strong>“源”视图</strong>会有所帮助。重新加载该页面，您会看到左侧导航栏中显示所有资源的每个来源。<br>在这里，您可以了解有关所用<strong>证书</strong>和<strong>连接类型</strong>的所有信息。此外，您还可以通过网络面板进一步深入探究，以检查来自相应来源的所有资源。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>如果网页是安全的，则会显示这样一条消息：This page is secure (valid HTTPS)。<ul><li>通过点击View certificate可以查看main origin的服务器证书信息。</li><li>点击左侧可以查看指定源的连接和证书详情。</li></ul></li><li>如果网页是不安全的，则会显示：This page is not secure。该面板可以区分两种类型的不安全的页面：<ul><li>如果被请求的页面通过HTTP提供服务，那么这个主源就会被标记为不安全。</li><li>如果被请求的页面是通过HTTPS获取的，但这个页面接着通过HTTP继续从其他来源检索内容， 那么这个页面仍然被标记为不安全。这就是所谓的混合内容页面,混合内容页面只是部分受到保护, 因为HTTP内容(非加密的内容)可以被嗅探者入侵,容易受到中间人攻击<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-9-4.png"></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端开发手册</category>
      
      <category>Debug 大作战：浏览器调试全攻略</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器调试,谷歌开发者工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sources面板</title>
    <link href="/2024/06/01/frontendGuide/browserDebug/chromeDevtools/sourcesPanel/"/>
    <url>/2024/06/01/frontendGuide/browserDebug/chromeDevtools/sourcesPanel/</url>
    
    <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><ul><li>Debug : 在源代码面板中可以设置<strong>断点</strong>来调试 JavaScript ，比 console.log()调试更快速高效</li><li>Devtools as IDE : 通过 Workspaces（工作区）连接本地文件来使用开发者工具的<strong>实时编辑器</strong></li></ul><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-8-1.png"></p><h2 id="断点类型"><a href="#断点类型" class="headerlink" title="断点类型"></a>断点类型</h2><ol><li><p>行断点：代码运行到当前行之前暂停执行</p><blockquote><p>在源代码添加debugger关键字或者点击Sources面板中的源代码的行号</p></blockquote></li><li><p>条件行断点：当满足条件时才会触发该断点</p><blockquote><p>右击Sources面板中的源代码的行号<br>选择“Add conditional breakpoint</p></blockquote></li></ol><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-8-2.gif"></p><ol start="3"><li><p>DOM 断点</p><blockquote><p>即Elements面板提及过的三种DOM断点：</p><ul><li>节点属性断点</li><li>节点删除断点</li><li>子树变更断点</li></ul></blockquote></li></ol><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-8-3.gif"></p><ol start="4"><li>XHR&#x2F;Fetch 断点<blockquote><p>在页面发出XHR或Fetch请求前加断点</p></blockquote></li></ol><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-8-6.gif"></p><ol start="5"><li>Event Listener 事件监听断点<blockquote><p>可以在所有类型的事件函数被出发前加断点</p></blockquote></li></ol><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-8-4.png"></p><!-- 6. Exception 异常断点 --><!-- ![](../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-8-5.png) --><ol start="6"><li>Function 函数断点<blockquote><p>把想调试的函数名作为参数，调用debug()函数，可以在每次执行该函数前暂停执行代码<br><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-8-7.gif"></p></blockquote></li></ol><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><ul><li>函数调用栈 Call Stack：Call Stack 是 time traveling 的，即点击栈中的任一节点，当前的作用域和局部变量等信息，都会模拟至该节点执行时的状态</li></ul><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-8-8.png"></p><ul><li>全局作用域 Global ，局部作用域 Local ，闭包作用域 Closure</li></ul><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-8-9.png"></p><ul><li>step over next function<blockquote><p>顾名思义over有跳过的意思，即如果遇到一个函数，它会直接执行完这个函数（注意是直接执行结束返回结果），然后进入下一步，中间不显示细节。</p></blockquote></li><li>step into next function<blockquote><p>顾名思义into是进入的意思，即如果遇到一个函数，它不会一下运行完这个函数，而是进入函数内部，一步一步地执行，这样我们可以更清楚地观察执行过程。</p></blockquote></li><li>step out current function<blockquote><p> step out of current function，顾名思义out是出来的意思，即如果利用 step into已经进入了函数内部，我们可以通过此功能来一下执行完函数内部剩下的代码。</p></blockquote></li><li>step (与 step over&#x2F;into 的区别就是，step 会优先尝试 step into，当没有可步入的代码时，就会执行 step over)</li></ul><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-8-10.png"></p><!-- - long resume：恢复执行，并将断点停用 500ms --><!-- ![](../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-8-11.gif) --><ul><li>Continue to here：继续执行至此行</li></ul><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-8-12.gif"></p><ul><li>Restart Frame：重新执行函数调用堆栈中的某一帧</li></ul><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-8-13.gif"></p><ul><li>行断点内的多个箭头：行内断点（行内的，可 step into 的 执行点</li></ul><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-8-14.png"></p><h2 id="Devtools-Nodejs-debug"><a href="#Devtools-Nodejs-debug" class="headerlink" title="Devtools Nodejs debug"></a>Devtools Nodejs debug</h2><ul><li>node 执行 js 文件，文件名前加–inspect 标志，启用浏览器 nodejs 调试</li></ul><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-8-15.png"></p><ul><li>点击 devtools 中，左上角的 devices mode 右侧的绿色按钮，即可启用 node 服务端中的脚本调试</li><li><a href="https://nodejs.org/en/docs/guides/debugging-getting-started/">更多相关</a></li></ul><h2 id="BlackBox-ignore-list"><a href="#BlackBox-ignore-list" class="headerlink" title="BlackBox - ignore list"></a>BlackBox - ignore list</h2><blockquote><p>BlackBox 的用途：“BlackBox Script”可以在调试中忽略某些脚本(此处的 BlackBox 为动词)，在 Call Stack 堆栈中会将该脚本隐藏，单步调试时也不会步入脚本中的任何函数</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">animate</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">prepare</span>();<br>    lib.<span class="hljs-title function_">doFancyStuff</span>(); <span class="hljs-comment">// A</span><br>    <span class="hljs-title function_">render</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>例如以上代码的 A 行，调用的是第三方库的 doFancyStuff 函数</p><p>如果我确认该第三方库没有 bug</p><p>就可以 BlackBox 整个第三方库的 js 脚本，在调试中跳过这些代码的执行</p><ul><li>三种添加 BlackBox 的方法：</li></ul><ol><li><p>在源代码窗格右键，选择”BlackBox Script”</p><p> <img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-8-16.gif"></p></li><li><p>在 Call Stack 中右键某一帧，选择”BlackBox Script”</p><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-8-17.gif"></p></li><li><p>在设置中的 Blackboxing 面板添加<strong>正则表达式</strong>匹配<strong>文件名</strong></p><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-8-18.gif"></p></li></ol><h2 id="Workspace：Devtools-as-IDE-将更改持久化"><a href="#Workspace：Devtools-as-IDE-将更改持久化" class="headerlink" title="Workspace：Devtools as IDE 将更改持久化"></a>Workspace：Devtools as IDE 将更改持久化</h2><ul><li><p>在 sources 左侧的面板中选择Filesystem，点击Add folder to workspace，将你本地运行的站点的相关源文件添加到 Devtools 的工作区，会自动识别 Page 下和工作区下相对应的文件，在 devtools 更改文件并保存，即持久化保存（目前只支持自动识别，不支持添加映射）</p></li><li><p>绿标文件：成功的映射到本地的文件，在 Styles 和 Sources 中的文件名前，都会添加绿色圆点作为标识</p><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-8-19.png"></p><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-8-20.png"></p></li><li><p>目前 Devtools 已经支持 sass&#x2F;scss、UglifyJS、Grunt、Coffescript、Closure 等等，暂时还不支持 webpack，和其他现代的复杂框架，如 react</p></li><li><p>所有sources面板的文件，都可以右键选择local modifications，查看所有更改</p></li><li><p>对 DOM 树的更改不会持久化至 html 文件：因为 dom 的最终表现，受到 html、css、javascript 的共同影响，DOM 树 !&#x3D;&#x3D; HTML，因此可以在 sources 中直接更改 html 文件并保存</p></li></ul><h2 id="Source-Map"><a href="#Source-Map" class="headerlink" title="Source Map"></a>Source Map</h2><ul><li>组合&#x2F;压缩 css,js 文件是常见的性能优化方案，但是会对开发调试造成困扰</li><li>Source Map 用于将生产代码映射至源代码，Chrome 和 firefox 都内置了对 Source Map 的支持</li><li>在 Chorme devtools 中，settings -&gt; preferen -&gt; sources 中，选中Enable Javascript source maps和Enable CSS source maps</li><li>source map 映射信息存在 json 对象中，保存在 .map 文件中，可以由编译程序添加注释&#x2F;&#x2F;# sourceMappingURL&#x3D;&#x2F;path&#x2F;to&#x2F;script.js.map至生产文件末尾，也可以由服务端在响应头中添加X-SourceMap: &#x2F;path&#x2F;to&#x2F;script.js.map，将 map 文件与生产文件对应。<a href="https://blog.teamtreehouse.com/introduction-source-maps">更多关于 source map 的介绍</a></li></ul><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-8-21.png"></p><h2 id="Local-Overrides"><a href="#Local-Overrides" class="headerlink" title="Local Overrides"></a>Local Overrides</h2><ul><li>用于覆盖网络请求: 在source&#x2F;page右键save for override或直接edit，保存的文件都被存储到overrides 指定目录(按照域名建立文件夹). 这种改写是临时的</li><li>在 Sources 面板左侧选择 Overrides，指定 DevTools 应保存更改的目录，当在 DevTools 中进行更改时，DevTools 会将修改后的文件的副本保存到所选的本地目录中，重新加载页面时，DevTools 提供本地修改的文件，而不是请求的网络资源。</li><li>与 Workspace 相似的，不支持保存对 DOM 树的更改，需要直接更改 html 源文件。</li><li>只能指定一个目录</li><li>断点debug 时，实时修改文件，然后保存后会恢复到第一个断点，不用重新刷新</li></ul><h2 id="Snippets-代码片段"><a href="#Snippets-代码片段" class="headerlink" title="Snippets 代码片段"></a>Snippets 代码片段</h2><ul><li>在 Sources 面板左侧选择 Snippets，或crlt shift p输入 snippet 打开 Snippets 面板，可以创建并保存常用的代码片段，和用 gist 类似</li><li>snippets 中，选中代码并ctrl enter，或点击右下角的执行按钮，即可执行代码片段</li></ul><p><img src="/../../img/frontendGuide/actualCombat/browserDebug/chrome-devtools-8-22.png"></p><h2 id="Content-scripts"><a href="#Content-scripts" class="headerlink" title="Content scripts"></a>Content scripts</h2><ul><li>这部分脚本是浏览器插件的脚本，在特定网页的上下文中运行。（与插件运行在服务端的脚本，页面上引用的脚本，页面上 script 中的内嵌脚本都不同</li><li>插件在服务端的脚本可以访问所有 WebExtension JavaScript API，但它们无法直接访问网页内容。</li><li>Content scripts 只能访问 WebExtension API 的一小部分，但它们可以使用消息传递系统与后台脚本进行通信，从而间接访问 WebExtension API。</li><li>如果有浏览器插件相关的工作，可以更深入<a href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions">研究</a>，不赘述。</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端开发手册</category>
      
      <category>Debug 大作战：浏览器调试全攻略</category>
      
    </categories>
    
    
    <tags>
      
      <tag>浏览器调试,谷歌开发者工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Vue.js 设计与实现》第六章 原始值的响应式方案</title>
    <link href="/2024/04/25/vue/vue6/"/>
    <url>/2024/04/25/vue/vue6/</url>
    
    <content type="html"><![CDATA[<h1 id="第六章-原始值的响应式方案"><a href="#第六章-原始值的响应式方案" class="headerlink" title="第六章 原始值的响应式方案"></a>第六章 原始值的响应式方案</h1><blockquote><p>在第 5 章中，我们讨论了非原始值的响应式方案，本章我们将讨论原始值的响应式方案。</p></blockquote><h2 id="本章内容"><a href="#本章内容" class="headerlink" title="本章内容"></a>本章内容</h2><ul><li>引入 ref 的概念</li><li>响应丢失问题</li><li>自动脱 ref</li></ul><p>原始值指的是<strong>Boolean、Number、BigInt、String、Symbol、undefined 和 null 等</strong>类型的值。在 JavaScript 中，原始值是按值传递的，而非按引用传递。这意味着，如果一个函数接收原始值作为参数，那么形参与实参之间没有引用关系，它们是两个完全独立的值，对形参的修改不会影响实参。另外，JavaScript 中的 Proxy 无法提供对原始值的代理，因此想要将原始值变成响应式数据，就必须对其做一层包裹，也就是我们接下来要介绍的 ref。</p><h3 id="6-1-引入-ref-的概念"><a href="#6-1-引入-ref-的概念" class="headerlink" title="6.1 引入 ref 的概念"></a>6.1 引入 ref 的概念</h3><p>由于 Proxy 的代理目标必须是非原始值，所以我们没有任何手段拦截对原始值的操作，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-comment">// 无法拦截对值的修改</span><br>str = <span class="hljs-string">&#x27;vue3&#x27;</span><br></code></pre></td></tr></table></figure><p>对于这个问题，我们能够想到的唯一办法是，使用一个非原始值去“包裹”原始值，例如使用一个对象包裹原始值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> wrapper = &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;vue&#x27;</span><br>&#125;<br><span class="hljs-comment">// 可以使用 Proxy 代理 wrapper，间接实现对原始值的拦截</span><br><span class="hljs-keyword">const</span> name = <span class="hljs-title function_">reactive</span>(wrapper)<br>name.<span class="hljs-property">value</span> <span class="hljs-comment">// vue</span><br><span class="hljs-comment">// 修改值可以触发响应</span><br>name.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;vue3&#x27;</span><br></code></pre></td></tr></table></figure><p>但这样做会导致两个问题：</p><ul><li>用户为了创建一个响应式的原始值，不得不顺带创建一个包裹对象；</li><li>包裹对象由用户定义，而这意味着不规范。用户可以随意命名，例如 wrapper.value、wrapper.val 都是可以的。</li></ul><p>为了解决这两个问题，我们可以封装一个函数，将包裹对象的创建工作都封装到该函数中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">// 封装一个 ref 函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ref</span>(<span class="hljs-params">val</span>) &#123;<br>  <span class="hljs-comment">// 在 ref 函数内部创建包裹对象</span><br>  <span class="hljs-keyword">const</span> wrapper = &#123;<br>    <span class="hljs-attr">value</span>: val<br>  &#125;<br>  <span class="hljs-comment">// 将包裹对象变成响应式数据</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">reactive</span>(wrapper)<br>&#125;<br></code></pre></td></tr></table></figure><p>如上面的代码所示，我们把创建 wrapper 对象的工作封装到 ref 函数内部，然后使用 reactive 函数将包裹对象变成响应式数据并返回。这样我们就解决了上述两个问题。运行如下测试代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">// 创建原始值的响应式数据</span><br><span class="hljs-keyword">const</span> refVal = <span class="hljs-title function_">ref</span>(<span class="hljs-number">1</span>)<br><span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 在副作用函数内通过 value 属性读取原始值</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(refVal.<span class="hljs-property">value</span>)<br>&#125;)<br><span class="hljs-comment">// 修改值能够触发副作用函数重新执行</span><br>refVal.<span class="hljs-property">value</span> = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>上面这段代码能够按照预期工作。现在是否一切都完美了呢？并不是，接下来我们面临的第一个问题是，如何区分 refVal 到底是原始值的包裹对象，还是一个非原始值的响应式数据，如以下代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> refVal1 = <span class="hljs-title function_">ref</span>(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">const</span> refVal2 = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">value</span>: <span class="hljs-number">1</span> &#125;)<br></code></pre></td></tr></table></figure><p>思考一下，这段代码中的 refVal1 和 refVal2 有什么区别呢？从我们的实现来看，它们没有任何区别。但是，我们有必要区分一个数据到底是不是 ref，因为这涉及下文讲解的自动脱 ref 能力。<br>想要区分一个数据是否是 ref 很简单，怎么做呢？如下面的代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">// 封装一个 ref 函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ref</span>(<span class="hljs-params">val</span>) &#123;<br>  <span class="hljs-keyword">const</span> wrapper = &#123;<br>    <span class="hljs-attr">value</span>: val<br>  &#125;<br>  <span class="hljs-comment">// 使用 Object.defineProperty 在 wrapper 对象上定义一个不可枚举的属性 __v_isRef，并且值为 true</span><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(wrapper, <span class="hljs-string">&#x27;__v_isRef&#x27;</span>, &#123;<br>    <span class="hljs-attr">value</span>: <span class="hljs-literal">true</span><br>  &#125;)<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">reactive</span>(wrapper)<br>&#125;<br></code></pre></td></tr></table></figure><p>我们使用 Object.defineProperty 为包裹对象 wrapper 定义了一个不可枚举且不可写的属性 <strong>v_isRef，它的值为 true，代表这个对象是一个 ref，而非普通对象。这样我们就可以通过检查</strong>v_isRef 属性来判断一个数据是否是 ref 了</p><h3 id="6-2-响应丢失问题"><a href="#6-2-响应丢失问题" class="headerlink" title="6.2 响应丢失问题"></a>6.2 响应丢失问题</h3><p>ref 除了能够用于原始值的响应式方案之外，还能用来解决响应丢失问题。首先，我们来看什么是响应丢失问题。在编写 Vue.js 组件时，我们通常要把数据暴露到模板中使用，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 响应式数据</span><br>    <span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">bar</span>: <span class="hljs-number">2</span> &#125;)<br><br>    <span class="hljs-comment">// 将数据暴露到模板中</span><br>    <span class="hljs-keyword">return</span> &#123;<br>      ...obj<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着，我们就可以在模板中访问从 setup 中暴露出来的数据：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JS">&lt;template&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; foo &#125;&#125; / &#123;&#123; bar &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br>&lt;/template&gt;<br></code></pre></td></tr></table></figure><p>然而，这么做会导致响应丢失。其表现是，当我们修改响应式数据的值时，不会触发重新渲染：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 响应式数据</span><br>    <span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">bar</span>: <span class="hljs-number">2</span> &#125;)<br>    <span class="hljs-comment">// 1s 后修改响应式数据的值，不会触发重新渲染</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      obj.<span class="hljs-property">foo</span> = <span class="hljs-number">100</span><br>    &#125;, <span class="hljs-number">1000</span>)<br><br>    <span class="hljs-keyword">return</span> &#123;<br>      ...obj<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>为什么会导致响应丢失呢？这是由展开运算符（…）导致的。实际上，下面这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">return</span> &#123;<br>  ...obj<br>&#125;<br><span class="hljs-comment">// 等价于：</span><br><span class="hljs-keyword">return</span> &#123;<br>  <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">bar</span>: <span class="hljs-number">2</span><br>&#125;<br></code></pre></td></tr></table></figure><p>可以发现，这其实就是返回了一个普通对象，它不具有任何响应式能力。把一个普通对象暴露到模板中使用，是不会在渲染函数与响应式数据之间建立响应联系的。所以当我们尝试在一个定时器中修改bj.foo 的值时，不会触发重新渲染。我们可以用另一种方式来描述响应丢失问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">// obj 是响应式数据</span><br><span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">bar</span>: <span class="hljs-number">2</span> &#125;)<br><span class="hljs-comment">// 将响应式数据展开到一个新的对象 newObj</span><br><span class="hljs-keyword">const</span> newObj = &#123;<br>  ...obj<br>&#125;<br><span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 在副作用函数内通过新的对象 newObj 读取 foo 属性值</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newObj.<span class="hljs-property">foo</span>)<br>&#125;)<br><span class="hljs-comment">// 很显然，此时修改 obj.foo 并不会触发响应</span><br>obj.<span class="hljs-property">foo</span> = <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>如上面的代码所示，首先创建一个响应式的数据对象 obj，然后使用展开运算符得到一个新的对象 newObj，它是一个普通对象，不具有响应能力。这里的关键点在于，副作用函数内访问的是普通对象newObj，它没有任何响应能力，所以当我们尝试修改 obj.foo 的值时，不会触发副作用函数重新执行。<br>如何解决这个问题呢？换句话说，有没有办法能够帮助我们实现：在副作用函数内，即使通过普通对象 newObj 来访问属性值，也能够建立响应联系？其实是可以的，代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">// obj 是响应式数据</span><br><span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">bar</span>: <span class="hljs-number">2</span> &#125;)<br><span class="hljs-comment">// newObj 对象下具有与 obj 对象同名的属性，并且每个属性值都是一个对象，</span><br><span class="hljs-comment">// 该对象具有一个访问器属性 value，当读取 value 的值时，其实读取的是 obj对象下相应的属性值</span><br><span class="hljs-keyword">const</span> newObj = &#123;<br>  <span class="hljs-attr">foo</span>: &#123;<br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">value</span>() &#123;<br>      <span class="hljs-keyword">return</span> obj.<span class="hljs-property">foo</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">bar</span>: &#123;<br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">value</span>() &#123;<br>      <span class="hljs-keyword">return</span> obj.<span class="hljs-property">bar</span><br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 在副作用函数内通过新的对象 newObj 读取 foo 属性值</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newObj.<span class="hljs-property">foo</span>.<span class="hljs-property">value</span>)<br>&#125;)<br><span class="hljs-comment">// 这时能够触发响应了</span><br>obj.<span class="hljs-property">foo</span> = <span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><p>在上面这段代码中，我们修改了 newObj 对象的实现方式。可以看到，在现在的 newObj 对象下，具有与 obj 对象同名的属性，而且每个属性的值都是一个对象，例如 foo 属性的值是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JS">&#123;<br> <span class="hljs-keyword">get</span> <span class="hljs-title function_">value</span>() &#123;<br>    <span class="hljs-keyword">return</span> obj.<span class="hljs-property">foo</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该对象有一个访问器属性 value，当读取 value 的值时，最终读取的是响应式数据 obj 下的同名属性值。也就是说，当在副作用函数内读取 newObj.foo 时，等价于间接读取了 obj.foo 的值。这样响应式数据自然能够与副作用函数建立响应联系。于是，当我们尝试修改 obj.foo 的值时，能够触发副作用函数重新执行。<br>观察 newObj 对象，可以发现它的结构存在相似之处：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> newObj = &#123;<br>  <span class="hljs-attr">foo</span>: &#123;<br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">value</span>() &#123;<br>      <span class="hljs-keyword">return</span> obj.<span class="hljs-property">foo</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">bar</span>: &#123;<br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">value</span>() &#123;<br>      <span class="hljs-keyword">return</span> obj.<span class="hljs-property">bar</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>foo 和 bar 这两个属性的结构非常像，这启发我们将这种结构抽象出来并封装成函数，如下面的代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">toRef</span>(<span class="hljs-params">obj, key</span>) &#123;<br>  <span class="hljs-keyword">const</span> wrapper = &#123;<br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">value</span>() &#123;<br>      <span class="hljs-keyword">return</span> obj[key]<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> wrapper<br>&#125;<br><br></code></pre></td></tr></table></figure><p>toRef 函数接收两个参数，第一个参数 obj 是一个响应式数据，第二个参数是 obj 对象的一个键。该函数会返回一个类似于 ref 结构的 wrapper 对象。有了 toRef 函数后，我们就可以重新实现newObj 对象了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> newObj = &#123;<br>  <span class="hljs-attr">foo</span>: <span class="hljs-title function_">toRef</span>(obj, <span class="hljs-string">&#x27;foo&#x27;</span>),<br>  <span class="hljs-attr">bar</span>: <span class="hljs-title function_">toRef</span>(obj, <span class="hljs-string">&#x27;bar&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，代码变得非常简洁。但如果响应式数据 obj 的键非常多，我们还是要花费很大力气来做这一层转换。为此，我们可以封装toRefs 函数，来批量地完成转换：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">toRefs</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">const</span> ret = &#123;&#125;<br>  <span class="hljs-comment">// 使用 for...in 循环遍历对象</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>    <span class="hljs-comment">// 逐个调用 toRef 完成转换</span><br>    ret[key] = <span class="hljs-title function_">toRef</span>(obj, key)<br>  &#125;<br>  <span class="hljs-keyword">return</span> ret<br>&#125;<br></code></pre></td></tr></table></figure><p>现在，我们只需要一步操作即可完成对一个对象的转换：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> newObj = &#123; ...<span class="hljs-title function_">toRefs</span>(obj) &#125;<br><br><span class="hljs-comment">//  可以使用如下代码进行测试：</span><br><span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">bar</span>: <span class="hljs-number">2</span> &#125;)<br><span class="hljs-keyword">const</span> newObj = &#123; ...<span class="hljs-title function_">toRefs</span>(obj) &#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newObj.<span class="hljs-property">foo</span>.<span class="hljs-property">value</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newObj.<span class="hljs-property">bar</span>.<span class="hljs-property">value</span>) <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>但为了概念上的统一，我们会将通过 toRef 或 toRefs 转换后得到的结果视为真正的 ref数据，为此我们需要为 toRef 函数增加一段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">toRef</span>(<span class="hljs-params">obj, key</span>) &#123;<br>  <span class="hljs-keyword">const</span> wrapper = &#123;<br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">value</span>() &#123;<br>      <span class="hljs-keyword">return</span> obj[key]<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 定义 __v_isRef 属性</span><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(wrapper, <span class="hljs-string">&#x27;__v_isRef&#x27;</span>, &#123;<br>    <span class="hljs-attr">value</span>: <span class="hljs-literal">true</span><br>  &#125;)<br>  <span class="hljs-keyword">return</span> wrapper<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，我们使用 Object.defineProperty 函数为wrapper 对象定义了 __v_isRef 属性。这样，toRef 函数的返回值就是真正意义上的 ref 了。通过上述讲解我们能注意到，ref 的作用不仅仅是实现原始值的响应式方案，它还用来解决响应丢失问题。<br>但上文中实现的 toRef 函数存在缺陷，即通过 toRef 函数创建的 ref 是只读的，如下面的代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">bar</span>: <span class="hljs-number">2</span> &#125;)<br><span class="hljs-keyword">const</span> refFoo = <span class="hljs-title function_">toRef</span>(obj, <span class="hljs-string">&#x27;foo&#x27;</span>)<br><br>refFoo.<span class="hljs-property">value</span> = <span class="hljs-number">100</span> <span class="hljs-comment">// 无效</span><br></code></pre></td></tr></table></figure><p>这是因为 toRef 返回的 wrapper 对象的 value 属性只有getter，没有 setter。为了功能的完整性，我们应该为它加上setter 函数，所以最终的实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">toRef</span>(<span class="hljs-params">obj, key</span>) &#123;<br>  <span class="hljs-keyword">const</span> wrapper = &#123;<br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">value</span>() &#123;<br>      <span class="hljs-keyword">return</span> obj[key]<br>    &#125;,<br>    <span class="hljs-comment">// 允许设置值</span><br>    <span class="hljs-keyword">set</span> <span class="hljs-title function_">value</span>(<span class="hljs-params">val</span>) &#123;<br>      obj[key] = val<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">defineProperty</span>(wrapper, <span class="hljs-string">&#x27;__v_isRef&#x27;</span>, &#123;<br>    <span class="hljs-attr">value</span>: <span class="hljs-literal">true</span><br>  &#125;)<br><br>  <span class="hljs-keyword">return</span> wrapper<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，当设置 value 属性的值时，最终设置的是响应式数据的同名属性的值，这样就能正确地触发响应了。</p><h3 id="6-3-自动脱-ref"><a href="#6-3-自动脱-ref" class="headerlink" title="6.3 自动脱 ref"></a>6.3 自动脱 ref</h3><p>toRefs 函数的确解决了响应丢失问题，但同时也带来了新的问题。由于 toRefs 会把响应式数据的第一层属性值转换为 ref，因此必须通过 value 属性访问值，如以下代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">bar</span>: <span class="hljs-number">2</span> &#125;)<br>obj.<span class="hljs-property">foo</span> <span class="hljs-comment">// 1</span><br>obj.<span class="hljs-property">bar</span> <span class="hljs-comment">// 2</span><br><br><span class="hljs-keyword">const</span> newObj = &#123; ...<span class="hljs-title function_">toRefs</span>(obj) &#125;<br><span class="hljs-comment">// 必须使用 value 访问值</span><br>newObj.<span class="hljs-property">foo</span>.<span class="hljs-property">value</span> <span class="hljs-comment">// 1</span><br>newObj.<span class="hljs-property">bar</span>.<span class="hljs-property">value</span> <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>这其实增加了用户的心智负担，因为通常情况下用户是在模板中访问数据的，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JS">&lt;p&gt;&#123;&#123; foo &#125;&#125; / &#123;&#123; bar &#125;&#125;&lt;/p&gt;<br><br><span class="hljs-comment">// 用户肯定不希望编写下面这样的代码：</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; foo.value &#125;&#125; / &#123;&#123; bar.value &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>因此，我们需要自动脱 ref 的能力。所谓自动脱 ref，指的是属性的访问行为，即如果读取的属性是一个 ref，则直接将该 ref 对应的 value 属性值返回，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JS">newObj.<span class="hljs-property">foo</span> <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>可以看到，即使 newObj.foo 是一个 ref，也无须通过newObj.foo.value 来访问它的值。要实现此功能，需要使用Proxy 为 newObj 创建一个代理对象，通过代理来实现最终目标，这时就用到了上文中介绍的 ref 标识，即 __v_isRef 属性，如下面的<br>代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">proxyRefs</span>(<span class="hljs-params">target</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) &#123;<br>      <span class="hljs-keyword">const</span> value = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver)<br>      <span class="hljs-comment">// 自动脱 ref 实现：如果读取的值是 ref，则返回它的 value 属性值</span><br>      <span class="hljs-keyword">return</span> value.<span class="hljs-property">__v_isRef</span> ? value.<span class="hljs-property">value</span> : value<br>    &#125;<br>  &#125;)<br>&#125;<br><br><span class="hljs-comment">// 调用 proxyRefs 函数创建代理</span><br><span class="hljs-keyword">const</span> newObj = <span class="hljs-title function_">proxyRefs</span>(&#123; ...<span class="hljs-title function_">toRefs</span>(obj) &#125;)<br></code></pre></td></tr></table></figure><p>在上面这段代码中，我们定义了 proxyRefs 函数，该函数接收一个对象作为参数，并返回该对象的代理对象。代理对象的作用是拦截 get 操作，当读取的属性是一个 ref 时，则直接返回该 ref 的value 属性值，这样就实现了自动脱 ref：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newObj.<span class="hljs-property">foo</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(newObj.<span class="hljs-property">bar</span>) <span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure><p>实际上，我们在编写 Vue.js 组件时，组件中的 setup 函数所返回的数据会传递给 proxyRefs 函数进行处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyComponent</span> = &#123;<br>  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br><br>    <span class="hljs-comment">// 返回的这个对象会传递给 proxyRefs</span><br>    <span class="hljs-keyword">return</span> &#123; count &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这也是为什么我们可以在模板直接访问一个 ref 的值，而无须通过 value 属性来访问：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JS">&lt;p&gt;&#123;&#123; count &#125;&#125;&lt;/p&gt;<br></code></pre></td></tr></table></figure><p>既然读取属性的值有自动脱 ref 的能力，对应地，设置属性的值也应该有自动为 ref 设置值的能力，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JS">newObj.<span class="hljs-property">foo</span> = <span class="hljs-number">100</span> <span class="hljs-comment">// 应该生效</span><br></code></pre></td></tr></table></figure><p>实现此功能很简单，只需要添加对应的 set 拦截函数即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">proxyRefs</span>(<span class="hljs-params">target</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(target, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) &#123;<br>      <span class="hljs-keyword">const</span> value = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver)<br>      <span class="hljs-keyword">return</span> value.<span class="hljs-property">__v_isRef</span> ? value.<span class="hljs-property">value</span> : value<br>    &#125;,<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, newValue, receiver</span>) &#123;<br>      <span class="hljs-comment">// 通过 target 读取真实值</span><br>      <span class="hljs-keyword">const</span> value = target[key]<br>      <span class="hljs-comment">// 如果值是 Ref，则设置其对应的 value 属性值</span><br>      <span class="hljs-keyword">if</span> (value.<span class="hljs-property">__v_isRef</span>) &#123;<br>        value.<span class="hljs-property">value</span> = newValue<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>      &#125;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, newValue, receiver)<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>如上面的代码所示，我们为 proxyRefs 函数返回的代理对象添加了 set 拦截函数。如果设置的属性是一个 ref，则间接设置该 ref的 value 属性的值即可。</p><p>实际上，自动脱 ref 不仅存在于上述场景。在 Vue.js 中，reactive 函数也有自动脱 ref 的能力，如以下代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)<br><span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">reactive</span>(&#123; count &#125;)<br><br>obj.<span class="hljs-property">count</span> <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><p>可以看到，obj.count 本应该是一个 ref，但由于自动脱 ref能力的存在，使得我们无须通过 value 属性即可读取 ref 的值。这么设计旨在减轻用户的心智负担，因为在大部分情况下，用户并不知道一个值到底是不是 ref。有了自动脱 ref 的能力后，用户在模板中使用响应式数据时，将不再需要关心哪些是 ref，哪些不是 ref。</p><h3 id="6-4-总结"><a href="#6-4-总结" class="headerlink" title="6.4 总结"></a>6.4 总结</h3><ul><li>在本章中，我们首先介绍了 ref 的概念。ref 本质上是一个“包裹对象”。因为 JavaScript 的 Proxy 无法提供对原始值的代理，所以我们需要使用一层对象作为包裹，间接实现原始值的响应式方案。由于“包裹对象”本质上与普通对象没有任何区别，因此为了区分 ref 与普通响应式对象，我们还为“包裹对象”定义了一个值为 true 的属性，即__v_isRef，用它作为 ref 的标识。</li><li>ref 除了能够用于原始值的响应式方案之外，还能用来解决响应丢失问题。为了解决该问题，我们实现了 toRef 以及toRefs 这两个函数。它们本质上是对响应式数据做了一层包装，或者叫作“访问代理”。</li><li>最后，我们讲解了自动脱 ref 的能力。为了减轻用户的心智负担，我们自动对暴露到模板中的响应式数据进行脱 ref 处理。这样，用户在模板中使用响应式数据时，就无须关心一个值是不是 ref 了。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue.js 设计与实现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书分享</tag>
      
      <tag>vue原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Vue.js 设计与实现》第五章 非原始值的响应式方案</title>
    <link href="/2024/04/22/vue/vue5/"/>
    <url>/2024/04/22/vue/vue5/</url>
    
    <content type="html"><![CDATA[<h1 id="第五章-非原始值的响应式方案"><a href="#第五章-非原始值的响应式方案" class="headerlink" title="第五章 非原始值的响应式方案"></a>第五章 非原始值的响应式方案</h1><h2 id="本章内容"><a href="#本章内容" class="headerlink" title="本章内容"></a>本章内容</h2><ul><li>理解 Proxy 和 Reflect</li><li>JavaScript 对象及 Proxy 的工作原理</li><li>如何代理 Object</li><li>合理地触发响应</li><li>浅响应与深响应</li><li>只读和浅只读</li><li>代理数组</li><li>代理 Set 和 Map</li></ul><h2 id="5-1-理解-Proxy-和-Reflect"><a href="#5-1-理解-Proxy-和-Reflect" class="headerlink" title="5.1 理解 Proxy 和 Reflect"></a>5.1 理解 Proxy 和 Reflect</h2><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><blockquote><p>什么是 Proxy 呢？简单地说，使用 Proxy 可以创建一个代理对象。它能够实现对其他对象的代理，这里的关键词是其他对象，也就是说，Proxy 只能代理对象，无法代理非对象值，例如字符串、布尔值等。那么，代理指的是什么呢？所谓代理，指的是对一个对象基本语义的代理。它允许我们拦截并重新定义对一个对象的基本操作。这句话的关键词比较多，我们逐一解释:</p></blockquote><p>什么是基本语义？给出一个对象 obj，可以对它进行一些操作，例如读取属性值、设置属性值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">obj.<span class="hljs-property">foo</span>; <span class="hljs-comment">// 读取属性 foo 的值</span><br>obj.<span class="hljs-property">foo</span>++; <span class="hljs-comment">// 读取和设置属性 foo 的值</span><br></code></pre></td></tr></table></figure><p>类似这种读取、设置属性值的操作，就属于基本语义的操作，即基本操作。既然是基本操作，那么它就可以使用 Proxy 拦截：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>  <span class="hljs-comment">// 拦截读取属性操作</span><br>  <span class="hljs-title function_">get</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">/*...*/</span><br>  &#125;,<br>  <span class="hljs-comment">// 拦截设置属性操作</span><br>  <span class="hljs-title function_">set</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">/*...*/</span><br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>如以上代码所示，Proxy 构造函数接收两个参数。第一个参数是被代理的对象，第二个参数也是一个对象，这个对象是一组夹子（trap）。其中 get 函数用来拦截读取操作，set 函数用来拦截设置操作。</p><p>在 JavaScript 的世界里，万物皆对象。例如一个函数也是一个对象，所以调用函数也是对一个对象的基本操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">fn</span> = (<span class="hljs-params">name</span>) =&gt; &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;我是：&quot;</span>, name);<br>&#125;;<br><span class="hljs-comment">// 调用函数是对对象的基本操作</span><br><span class="hljs-title function_">fn</span>();<br></code></pre></td></tr></table></figure><p>因此，我们可以用 Proxy 来拦截函数的调用操作，这里我们使用 apply 拦截函数的调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(fn, &#123;<br>  <span class="hljs-comment">// 使用 apply 拦截函数调用</span><br>  <span class="hljs-title function_">apply</span>(<span class="hljs-params">target, thisArg, argArray</span>) &#123;<br>    target.<span class="hljs-title function_">call</span>(thisArg, ...argArray);<br>  &#125;,<br>&#125;);<br><br><span class="hljs-title function_">p2</span>(<span class="hljs-string">&quot;hcy&quot;</span>); <span class="hljs-comment">// 输出：&#x27;我是：hcy&#x27;</span><br></code></pre></td></tr></table></figure><p>上面两个例子说明了什么是基本操作。Proxy 只能够拦截对一个对象的基本操作。那么，什么是非基本操作呢？其实调用对象下的方法就是典型的非基本操作，我们叫它复合操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">obj.<span class="hljs-title function_">fn</span>();<br></code></pre></td></tr></table></figure><p>实际上，调用一个对象下的方法，是由两个基本语义组成的，第一个基本语义是 get，即先通过 get 操作得到 obj.fn 属性。第二个基本语义是函数调用，即通过 get 得到 obj.fn 的值后再调用它，也就是我们上面说到的 apply。</p><h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><p>Reflect 是一个全局对象，其下有许多方法，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>();<br><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>();<br><span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">apply</span>();<br></code></pre></td></tr></table></figure><p>Reflect 下的方法与 Proxy 的拦截器方法名字相同，其实这不是偶然。任何在 Proxy 的拦截器中能够找到的方法，都能够在 Reflect 中找到同名函数，那么这些函数的作用是什么呢？其实它们的作用一点儿都不神秘。拿 Reflect.get 函数来说，它的功能就是提供了访问一个对象属性的默认行为，例如下面两个操作是等价的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span> &#125;;<br><span class="hljs-comment">// 直接读取</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">foo</span>); <span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 使用 Reflect.get 读取</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(obj, <span class="hljs-string">&quot;foo&quot;</span>)); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure><p>既然操作等价，那么它存在的意义是什么呢？实际上 Reflect.get 函数还能接收第三个参数，即指定接收者 receiver，你可以把它理解为函数调用过程中的 this，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span> &#125;;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(obj, <span class="hljs-string">&quot;foo&quot;</span>, &#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">2</span> &#125;)); <span class="hljs-comment">// 输出的是 2 而不是 1</span><br></code></pre></td></tr></table></figure><p>在这段代码中，我们指定第三个参数 receiver 为一个对象 {foo: 2 }，这时读取到的值是 receiver 对象的 foo 属性值。实际上，Reflect.* 方法还有很多其他方面的意义，但这里我们只关心并讨论这一点，因为它与响应式数据的实现密切相关。为了说明问题，回顾一下在上一节中实现响应式数据的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span> &#125;;<br><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key</span>) &#123;<br>    <span class="hljs-title function_">track</span>(target, key);<br>    <span class="hljs-comment">// 注意，这里我们没有使用 Reflect.get 完成读取</span><br>    <span class="hljs-keyword">return</span> target[key];<br>  &#125;,<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, newVal</span>) &#123;<br>    <span class="hljs-comment">// 这里同样没有使用 Reflect.set 完成设置</span><br>    target[key] = newVal;<br>    <span class="hljs-title function_">trigger</span>(target, key);<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>这是上一章中用来实现响应式数据的最基本的代码。在 get 和 set 拦截函数中，我们都是直接使用原始对象 target 来完成对属性的读取和设置操作的，其中原始对象 target 就是上述代码中的 obj 对象。</p><p>那么这段代码有什么问题吗？我们借助 effect 让问题暴露出来。首先，我们修改一下 obj 对象，为它添加 bar 属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">bar</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo</span>;<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看到，bar 属性是一个访问器属性，它返回了 this.foo 属性的值。接着，我们在 effect 副作用函数中通过代理对象 p 访问 bar 属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">bar</span>); <span class="hljs-comment">// 1</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>我们来分析一下这个过程发生了什么。当 effect 注册的副作用函数执行时，会读取 p.bar 属性，它发现 p.bar 是一个访问器属性，因此执行 getter 函数。由于在 getter 函数中通过 this.foo 读取了 foo 属性值，因此我们认为副作用函数与属性 foo 之间也会建立联系。当我们修改 p.foo 的值时应该能够触发响应，使得副作用函数重新执行才对。然而实际并非如此，当我们尝试修改 p.foo 的值时：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">p.<span class="hljs-property">foo</span>++;<br></code></pre></td></tr></table></figure><p>副作用函数并没有重新执行，问题出在哪里呢？实际上，问题就出在 bar 属性的访问器函数 getter 里：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">bar</span>() &#123;<br>    <span class="hljs-comment">// 这里的 this 指向的是谁？</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo</span>;<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>当我们使用 this.foo 读取 foo 属性值时，这里的 this 指向的是谁呢？我们回顾一下整个流程。首先，我们通过代理对象 p 访问 p.bar，这会触发代理对象的 get 拦截函数执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key</span>) &#123;<br>    <span class="hljs-title function_">track</span>(target, key);<br>    <span class="hljs-comment">// 注意，这里我们没有使用 Reflect.get 完成读取</span><br>    <span class="hljs-keyword">return</span> target[key];<br>  &#125;,<br>  <span class="hljs-comment">// 省略部分代码</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>在 get 拦截函数内，通过 target[key] 返回属性值。其中 target 是原始对象 obj，而 key 就是字符串 ‘bar’，所以 target[key] 相当于 obj.bar。因此，当我们使用 p.bar 访问 bar 属性时，它的 getter 函数内的 this 指向的其实是原始对象 obj，这说明我们最终访问的其实是 obj.foo。很显然，在副作用函数内通过原始对象访问它的某个属性是不会建立响应联系的，这等价于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// obj 是原始数据，不是代理对象，这样的访问不能够建立响应联系</span><br>  obj.<span class="hljs-property">foo</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><p>因为这样做不会建立响应联系，所以出现了无法触发响应的问题。那么这个问题应该如何解决呢？这时 Reflect.get 函数就派上用场了。先给出解决问题的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>  <span class="hljs-comment">// 拦截读取操作，接收第三个参数 receiver</span><br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) &#123;<br>    <span class="hljs-title function_">track</span>(target, key);<br>    <span class="hljs-comment">// 使用 Reflect.get 返回读取到的属性值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver);<br>  &#125;,<br>  <span class="hljs-comment">// 省略部分代码</span><br>&#125;);<br></code></pre></td></tr></table></figure><p>如上面的代码所示，代理对象的 get 拦截函数接收第三个参数 receiver，它代表谁在读取属性，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">p.<span class="hljs-property">bar</span>; <span class="hljs-comment">// 代理对象 p 在读取 bar</span><br></code></pre></td></tr></table></figure><p>当我们使用代理对象 p 访问 bar 属性时，那么 receiver 就是 p，你可以把它简单地理解为函数调用中的 this。接着关键的一步发生了，我们使用 Reflect.get(target, key, receiver) 代替之前的 target[key]，这里的关键点就是第三个参数 receiver。我们已经知道它就是代理对象 p，所以访问器属性 bar 的 getter 函数内的 this 指向代理对象 p：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">bar</span>() &#123;<br>    <span class="hljs-comment">// 现在这里的 this 为代理对象 p</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">foo</span>;<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p>可以看到，this 由原始对象 obj 变成了代理对象 p。很显然，这会在副作用函数与响应式数据之间建立响应联系，从而达到依赖收集的效果。如果此时再对 p.foo 进行自增操作，会发现已经能够触发副作用函数重新执行了。<br><a href="https://code.juejin.cn/pen/7350559590141935642">△ 运行代码</a><br>正是基于上述原因，后文讲解中将统一使用 Reflect.* 方法。</p><h2 id="5-2-JavaScript-对象及-Proxy-的工作原理"><a href="#5-2-JavaScript-对象及-Proxy-的工作原理" class="headerlink" title="5.2 JavaScript 对象及 Proxy 的工作原理"></a>5.2 JavaScript 对象及 Proxy 的工作原理</h2><p>在 JavaScript 中有两种对象，其中一种叫作常规对象（ordinary object），另一种叫作异质对象（exotic object）。这两种对象包了 JavaScript 世界中的所有对象，任何不属于常规对象的对象都是异质对象。那么到底什么是常规对象，什么是异质对象呢？这需要我们先了解对象的内部方法和内部槽。</p><p>在 JavaScript 中，函数其实也是对象。假设给出一个对象 obj，<strong>如何区分它是普通对象还是函数呢？</strong> 实际上，在 JavaScript 中，对象的实际语义是由对象的内部方法（internal method）指定的。所谓内部方法，指的是当我们对一个对象进行操作时在引擎内部调用的方法，这些方法对于 JavaScript 使用者来说是不可见的。当我们访问对象属性时，引擎内部会调用 [[Get]] 这个内部方法来读取属性值。当然，一个对象不仅部署了 [[Get]] 这个内部方法，表 5-1 列出了规范要求的所有必要的内部方法 。</p><ul><li>表 5-1 对象必要的内部方法<table><thead><tr><th align="center">内部方法</th><th align="center">签名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">[[GetPrototypeOf]]</td><td align="center">( ) → Object&#x2F;Null</td><td align="center">查明为该对象提供继承属性的对象，null 代表没有继承属性</td></tr><tr><td align="center">[[SetPrototypeOf]]</td><td align="center">(Object&#x2F;Null) → Boolean</td><td align="center">将该对象与提供继承属性的另一个对象相关联。传递 null 表示没有继承属性，返回 true 表示操作成功完成，返回 false 表示操作失败</td></tr><tr><td align="center">[[IsExtensible]]</td><td align="center">( ) → Boolean</td><td align="center">查明是否允许向该对象添加其他属性</td></tr><tr><td align="center">[[PreventExtensions]]</td><td align="center">( ) → Boolean</td><td align="center">控制能否向该对象添加新属性。如果操作成功则返回 true，如果操作失败则返回 false</td></tr><tr><td align="center">[[GetOwnProperty]]</td><td align="center">(propertyKey) → Undefined&#x2F;Property Descriptor</td><td align="center">返回该对象自身属性的描述符，其键为 propertyKey，如果不存在这样的属性，则返回 undefined</td></tr><tr><td align="center">[[DefineOwnProperty]]</td><td align="center">(propertyKey, PropertyDescriptor) → Boolean</td><td align="center">创建或更改自己的属性，其键为 propertyKey，以具有由 PropertyDescriptor 描述的状态。如果该属性已成功创建或更新，则返回 true；如果无法创建或更新该属性，则返回 false</td></tr><tr><td align="center">[[HasProperty]]</td><td align="center">(propertyKey) → Boolean</td><td align="center">返回一个布尔值，指示该对象是否已经拥有键为 propertyKey 的自己的或继承的属性</td></tr><tr><td align="center">[[Get]]</td><td align="center">(propertyKey,Receiver) → any</td><td align="center">从该对象返回键为 propertyKey 的属性的值。如果必须运行 ECMAScript 代码来检索属性值，则在运行代码时使用 Receiver 作为 this 值</td></tr><tr><td align="center">[[Set]]</td><td align="center">(propertyKey, value, Receiver) →Boolean</td><td align="center">将键值为 propertyKey 的属性的值设置为 value。如果必须运行 ECMAScript 代码来设置属性值，则在运行代码时使用 Receiver 作为 this 值。如果成功设置了属性值，则返回 true；如果无法设置，则返回 false</td></tr><tr><td align="center">[[Delete]]</td><td align="center">(propertyKey) → Boolean</td><td align="center">从该对象中删除属于自身的键为 propertyKey 的属性。如果该属性未被删除并且仍然存在，则返回 false；如果该属性已被删除或不存在，则返回 true</td></tr><tr><td align="center">[[OwnPropertyKeys]]</td><td align="center">( ) → List of propertyKey</td><td align="center">返回一个 List，其元素都是对象自身的属性键</td></tr></tbody></table></li></ul><p>由表 5-1 可知，包括 [[Get]] 在内，一个对象必须部署 11 个必要的内部方法。除了表 5-1 所列的内部方法之外，还有两个额外的必要内部方法 ：[[Call]] 和 [[Construct]]，如表 5-2 所示。</p><ul><li>表 5-2 额外的必要内部方法<table><thead><tr><th align="center">内部方法</th><th align="center">签名</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">[[Call]]</td><td align="center">(any, a List of any) → any</td><td align="center">将运行的代码与 this 对象关联。由函数调用触发。该内部方法的参数是一个 this 值和参数列表</td></tr><tr><td align="center">[[Construct]]</td><td align="center">(a List of any, Object)→ Object</td><td align="center">创建一个对象。通过 new 运算符或 super 调用触发。该内部方法的第一个参数是一个 List，该 List 的元素是构造函数调用或 super 调用的参数，第二个参数是最初应用 new 运算符的对象。实现该内部方法的对象称为构造函数</td></tr></tbody></table></li></ul><p><strong>如何区分它是普通对象还是函数呢？</strong></p><blockquote><p>通过内部方法和内部槽来区分对象，例如函数对象会部署内部方法 [[Call]]，而普通对象则不会。</p></blockquote><p>内部方法具有多态性，这是什么意思呢？这类似于面向对象里多态的概念。这就是说，不同类型的对象可能部署了相同的内部方法，却具有不同的逻辑。例如，普通对象和 Proxy 对象都部署了[[Get]] 这个内部方法，但它们的逻辑是不同的。了解了内部方法，就可以解释什么是常规对象，什么是异质对象了。满足以下三点要求的对象就是常规对象：</p><ul><li>对于表 5-1 列出的内部方法，必须使用 ECMA 规范 10.1.x 节给出的定义实现；</li><li>对于内部方法 [[Call]]，必须使用 ECMA 规范 10.2.1 节给出的定义实现；</li><li>对于内部方法 [[Construct]]，必须使用 ECMA 规范 10.2.2 节给出的定义实现</li></ul><p>而所有不符合这三点要求的对象都是异质对象。例如，由于 Proxy 对象的内部方法 [[Get]] 没有使用 ECMA 规范的 10.1.8 节给出的定义实现，所以 Proxy 是一个异质对象。</p><p>现在我们对 JavaScript 中的对象有了更加深入的理解。接下来，我们就具体看看 Proxy 对象。既然 Proxy 也是对象，那么它本身也部署了上述必要的内部方法，当我们通过代理对象访问属性值时：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<span class="hljs-comment">/* ... */</span>&#125;)<br>p.<span class="hljs-property">foo</span><br></code></pre></td></tr></table></figure><p>实际上，引擎会调用部署在对象 p 上的内部方法 [[Get]]。到这一步，其实代理对象和普通对象没有太大区别。它们的区别在于对于内部方法 [[Get]] 的实现，这里就体现了内部方法的多态性，即不同的对象部署相同的内部方法，但它们的行为可能不同。<br>如果在创建代理对象时没有指定对应的拦截函数，例如没有指定 get() 拦截函数，那么当我们通过代理对象访问属性值时，代理对象的内部方法 [[Get]] 会调用原始对象的内部方法 [[Get]] 来获取属性值，这其实就是代理透明性质。</p><p>现在相信你已经明白了，创建代理对象时指定的拦截函数，实际上是用来自定义代理对象本身的内部方法和行为的，而不是用来指定被代理对象的内部方法和行为的。表 5-3 列出了 Proxy 对象部署的所有内部方法以及用来自定义内部方法和行为的拦截函数名字 3。</p><ul><li>表 5-3 Proxy 对象部署的所有内部方法<table><thead><tr><th align="center">内部方法</th><th align="center">处理器函数</th></tr></thead><tbody><tr><td align="center">[[GetPrototypeOf]]</td><td align="center">getPrototypeOf</td></tr><tr><td align="center">[[SetPrototypeOf]]</td><td align="center">setPrototypeOf</td></tr><tr><td align="center">[[IsExtensible]]</td><td align="center">isExtensible</td></tr><tr><td align="center">[[PreventExtensions]]</td><td align="center">preventExtensions</td></tr><tr><td align="center">[[GetOwnProperty]]</td><td align="center">getOwnPropertyDescriptor</td></tr><tr><td align="center">[[DefineOwnProperty]]</td><td align="center">defineProperty</td></tr><tr><td align="center">[[HasProperty]]</td><td align="center">has</td></tr><tr><td align="center">[[Get]]</td><td align="center">get</td></tr><tr><td align="center">[[Set]]</td><td align="center">set</td></tr><tr><td align="center">[[Delete]]</td><td align="center">deleteProperty</td></tr><tr><td align="center">[[OwnPropertyKeys]]</td><td align="center">ownKeys</td></tr><tr><td align="center">[[Call]]</td><td align="center">apply</td></tr><tr><td align="center">[[Construct]]</td><td align="center">construct</td></tr></tbody></table></li></ul><p>当然，其中 [[Call]] 和 [[Construct]] 这两个内部方法只有当被代理的对象是函数和构造函数时才会部署。</p><p>由表 5-3 可知，当我们要拦截删除属性操作时，可以使用 deleteProperty 拦截函数实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span> &#125;<br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>  <span class="hljs-title function_">deleteProperty</span>(<span class="hljs-params">target, key</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">deleteProperty</span>(target, key)<br>  &#125;<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">foo</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-keyword">delete</span> p.<span class="hljs-property">foo</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">foo</span>) <span class="hljs-comment">// 未定义</span><br></code></pre></td></tr></table></figure><p>这里需要强调的是，deleteProperty 实现的是代理对象 p 的内部方法和行为，所以为了删除被代理对象上的属性值，我们需要使用 Reflect.deleteProperty(target, key) 来完成。</p><h2 id="5-3-如何代理-Object"><a href="#5-3-如何代理-Object" class="headerlink" title="5.3 如何代理 Object"></a>5.3 如何代理 Object</h2><blockquote><p>从本节开始，我们将着手实现响应式数据。前面我们使用 get 拦截函数去拦截对属性的读取操作。下面列出了对一个普通对象的所有可能的读取操作。</p></blockquote><ul><li>访问属性：obj.foo。</li><li>判断对象或原型上是否存在给定的 key：key in obj。</li><li>使用 for…in 循环遍历对象：for (const key in obj){}。</li></ul><h3 id="5-3-1-首先是对于属性的读取，"><a href="#5-3-1-首先是对于属性的读取，" class="headerlink" title="5.3.1 首先是对于属性的读取，"></a>5.3.1 首先是对于属性的读取，</h3><blockquote><p>例如 obj.foo，我们知道这可以通过 get 拦截函数实现：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span> &#125;<br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) &#123;<br>    <span class="hljs-comment">// 建立联系</span><br>    <span class="hljs-title function_">track</span>(target, key)<br>    <span class="hljs-comment">// 返回属性值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver)<br>  &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="5-3-2-对于-in-操作拦截"><a href="#5-3-2-对于-in-操作拦截" class="headerlink" title="5.3.2 对于 in 操作拦截"></a>5.3.2 对于 in 操作拦截</h3><blockquote><p>通过 has 拦截函数实现对 in 操作符的代理：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span> &#125;<br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>  <span class="hljs-title function_">has</span>(<span class="hljs-params">target, key</span>) &#123;<br>  <span class="hljs-title function_">track</span>(target, key)<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">has</span>(target, key)<br>  &#125;<br>&#125;)<br><br><span class="hljs-comment">// 当我们在副作用函数中通过 in 操作符操作响应式数据时，就能够建立依赖关系：</span><br><span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-string">&#x27;foo&#x27;</span> <span class="hljs-keyword">in</span> p <span class="hljs-comment">// 将会建立依赖关系</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="5-3-3-拦截-for…in-循环"><a href="#5-3-3-拦截-for…in-循环" class="headerlink" title="5.3.3 拦截 for…in 循环"></a>5.3.3 拦截 for…in 循环</h3><blockquote><p>使用 ownKeys 拦截函数来拦截 Reflect.ownKeys 操作：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span> &#125;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">ITERATE_KEY</span> = <span class="hljs-title class_">Symbol</span>()<br><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>  <span class="hljs-title function_">ownKeys</span>(<span class="hljs-params">target</span>) &#123;<br>    <span class="hljs-comment">// 将副作用函数与 ITERATE_KEY 关联</span><br>    <span class="hljs-title function_">track</span>(target, <span class="hljs-variable constant_">ITERATE_KEY</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(target)<br>  &#125;<br>&#125;)<br><br><span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// for...in 循环</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> p) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key) <span class="hljs-comment">// foo</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="5-4-合理地触发响应"><a href="#5-4-合理地触发响应" class="headerlink" title="5.4 合理地触发响应"></a>5.4 合理地触发响应</h2><h3 id="5-4-1-值不变触发响应"><a href="#5-4-1-值不变触发响应" class="headerlink" title="5.4.1 值不变触发响应"></a>5.4.1 值不变触发响应</h3><p>当值没有发生变化时，应该不需要触发响应才对：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span> &#125;<br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123; <span class="hljs-comment">/* ... */</span> &#125;)<br><br><span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">foo</span>)<br>&#125;)<br><br><span class="hljs-comment">// 设置 p.foo 的值，但值没有变化</span><br>p.<span class="hljs-property">foo</span> = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>为了满足需求，我们需要修改 set 拦截函数的代码，在调用 trigger 函数触发响应之前，需要检查值是否真的发生了变化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, newVal, receiver</span>) &#123;<br>    <span class="hljs-comment">// 先获取旧值</span><br>    <span class="hljs-keyword">const</span> oldVal = target[key]<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, newVal, receiver)<br>    <span class="hljs-comment">// 比较新值与旧值，只要当不全等的时候才触发响应</span><br>    <span class="hljs-keyword">if</span> (oldVal !== newVal) &#123;<br>      <span class="hljs-title function_">trigger</span>(target, key)<br>    &#125;<br>   <span class="hljs-keyword">return</span> res<br>  &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><p>然而，仅仅进行全等比较是有缺陷的，这体现在对 NaN 的处理上。我们知道 NaN 与 NaN 进行全等比较总会得到 false：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-title class_">NaN</span> === <span class="hljs-title class_">NaN</span> <span class="hljs-comment">// false</span><br><span class="hljs-title class_">NaN</span> !== <span class="hljs-title class_">NaN</span> <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>为了解决这个问题，我们需要再加一个条件，即在新值和旧值不全等的情况下，要保证它们都不是 NaN：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, newVal, receiver</span>) &#123;<br>    <span class="hljs-comment">// 先获取旧值</span><br>    <span class="hljs-keyword">const</span> oldVal = target[key]<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, newVal, receiver)<br>    <span class="hljs-comment">// 比较新值与旧值，只有当它们不全等，并且不都是 NaN 的时候才触发响应</span><br>    <span class="hljs-keyword">if</span> (oldVal !== newVal &amp;&amp; (oldVal === oldVal || newVal === newVal)) &#123;<br>      <span class="hljs-title function_">trigger</span>(target, key)<br>    &#125;<br>   <span class="hljs-keyword">return</span> res<br>  &#125;,<br>&#125;)<br></code></pre></td></tr></table></figure><p><a href="https://code.juejin.cn/pen/7350962110827855872">△ 运行代码</a></p><h3 id="5-4-2-原型继承属性触发响应"><a href="#5-4-2-原型继承属性触发响应" class="headerlink" title="5.4.2 原型继承属性触发响应"></a>5.4.2 原型继承属性触发响应</h3><p>但想要合理地触发响应，仅仅处理关于 NaN 的问题还不够。接下来，我们讨论一种从原型上继承属性的情况。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>    <span class="hljs-comment">// 省略前文讲解的拦截函数</span><br>  &#125;)<br>&#125;<br><br><span class="hljs-keyword">const</span> obj = &#123;&#125;<br><span class="hljs-keyword">const</span> proto = &#123; <span class="hljs-attr">bar</span>: <span class="hljs-number">1</span> &#125;<br><span class="hljs-keyword">const</span> child = <span class="hljs-title function_">reactive</span>(obj)<br><span class="hljs-keyword">const</span> parent = <span class="hljs-title function_">reactive</span>(proto)<br><span class="hljs-comment">// 使用 parent 作为 child 的原型</span><br><span class="hljs-title class_">Object</span>.<span class="hljs-title function_">setPrototypeOf</span>(child, parent)<br><span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(child.<span class="hljs-property">bar</span>) <span class="hljs-comment">// 1</span><br>&#125;)<br><br><span class="hljs-comment">// 修改 child.bar 的值</span><br>child.<span class="hljs-property">bar</span> = <span class="hljs-number">2</span> <span class="hljs-comment">// 会导致副作用函数重新执行两次</span><br></code></pre></td></tr></table></figure><p>我们定义了空对象 obj 和对象 proto，分别为二者创建了对应的响应式数据 child 和 parent，并且使用 Object.setPrototypeOf 方法将 parent 设置为 child 的原型。接着，在副作用函数内访问 child.bar 的值。从代码中可以看出，child 本身并没有 bar 属性，因此当访问 child.bar 时，值是从原型上继承而来的。但无论如何，既然 child 是响应式数据，那么它与副作用函数之间就会建立联系，因此当我们执行 child.bar &#x3D; 2 时，期望副作用函数会重新执行。<strong>但如果你尝试运行上面的代码，会发现副作用函数不仅执行了，还执行了两次，这会造成不必要的更新。</strong></p><p>为了搞清楚问题的原因，我们需要逐步分析整个过程。</p><ul><li>当在副作用函数中读取 child.bar 的值时，会触发 child 代理对象的 get 拦截函数。我们知道，在拦截函数内是使用 Reflect.get(target,key, receiver) 来得到最终结果的，这其实是实现了通过 obj.bar 来访问属性值的默认行为。也就是说，引擎内部是通过调用 obj 对象所部署的 [[Get]] 内部方法来得到最终结果的</li><li>如果设置的属性不存在于对象上，那么会取得其原型，并调用原型的 [[Set]] 方法，也就是 parent 的 [[Set]] 内部方法。由于 parent 是代理对象，所以这就相当于执行了它的 set 拦截函数。换句话说，虽然我们操作的是 child.bar，但这也会导致 parent 代理对象的 set 拦截函数被执行。前面我们分析过，当读取 child.bar 的值时，副作用函数不仅会被 child.bar 收集，也会被 parent.bar 收集。<strong>所以当 parent 代理对象的 set 拦截函数执行时，就会触发副作用函数重新执行，</strong></li></ul><p>两次更新是由于 set 拦截函数被触发了两次导致的，所以只要我们能够在 set 拦截函数内区分这两次更新就可以了。当我们设置 child.bar 的值时，会执行 child 代理对象的 set 拦截函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">// child 的 set 拦截函数</span><br><span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, value, receiver</span>) &#123;<br>  <span class="hljs-comment">// target 是原始对象 obj</span><br>  <span class="hljs-comment">// receiver 是代理对象 child</span><br>&#125;<br></code></pre></td></tr></table></figure><p>此时的 target 是原始对象 obj，receiver 是代理对象 child，我们发现 <strong>receiver 其实就是 target 的代理对象。</strong></p><p>但由于 obj 上不存在 bar 属性，所以会取得 obj 的原型 parent，并执行 parent 代理对象的 set 拦截函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">// parent 的 set 拦截函数</span><br><span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, value, receiver</span>) &#123;<br>  <span class="hljs-comment">// target 是原始对象 proto</span><br>  <span class="hljs-comment">// receiver 仍然是代理对象 child</span><br>&#125;<br></code></pre></td></tr></table></figure><p>当 parent 代理对象的 set 拦截函数执行时，此时 target 是原始对象 proto，而 receiver 仍然是代理对象 child，而<strong>不再是 target 的代理对象。</strong>通过这个特点，我们可以看到 target 和 receiver 的区别。由于我们最初设置的是 child.bar 的值，所以无论在什么情况下，receiver 都是 child，而 target 则是变化的。<br><strong>根据这个区别，我们很容易想到解决办法，只需要判断 receiver 是否是 target 的代理对象即可，只有当 receiver 是 target 的代理对象时才触发更新</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) &#123;<br>      <span class="hljs-comment">// 代理对象可以通过 raw 属性访问原始数据</span><br>      <span class="hljs-keyword">if</span> (key === <span class="hljs-string">&#x27;raw&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> target<br>      &#125;<br>      <span class="hljs-title function_">track</span>(target, key)<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver)<br>    &#125;<br>  <span class="hljs-comment">// 省略其他拦截函数</span><br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>我们增加了一段代码，它实现的功能是，代理对象可以通过 raw 属性读取原始数据，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JS">child.<span class="hljs-property">raw</span> === obj <span class="hljs-comment">// true</span><br>parent.<span class="hljs-property">raw</span> === proto <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>有了它，我们就能够在 set 拦截函数中判断 receiver 是不是 target 的代理对象了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj &#123;<br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, newVal, receiver</span>) &#123;<br>      <span class="hljs-keyword">const</span> oldVal = target[key]<br>      <span class="hljs-keyword">const</span> res = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, newVal, receiver)<br>      <span class="hljs-comment">// target === receiver.raw 说明 receiver 就是 target 的代理对象</span><br>      <span class="hljs-keyword">if</span> (target === receiver.<span class="hljs-property">raw</span>) &#123;<br>        <span class="hljs-keyword">if</span> (oldVal !== newVal &amp;&amp; (oldVal === oldVal || newVal === newVal)) &#123;<br>          <span class="hljs-title function_">trigger</span>(target, key)<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> res<br>    &#125;<br>  <span class="hljs-comment">// 省略其他拦截函数</span><br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://code.juejin.cn/pen/7350977666033877019">△ 运行代码</a></p><p>如以上代码所示，我们新增了一个判断条件，只有当 receiver 是 target 的代理对象时才触发更新，这样就能屏蔽由原型引起的更新，从而避免不必要的更新操作。</p><h2 id="5-5-浅响应与深响应"><a href="#5-5-浅响应与深响应" class="headerlink" title="5.5 浅响应与深响应"></a>5.5 浅响应与深响应</h2><blockquote><p>本节中我们将介绍 reactive 与 shallowReactive 的区别，即深响应和浅响应的区别。实际上，我们目前所实现的 reactive 是浅响应的。拿如下代码来说：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">reactive</span>(&#123; <span class="hljs-attr">foo</span>: &#123; <span class="hljs-attr">bar</span>: <span class="hljs-number">1</span> &#125; &#125;)<br><span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">foo</span>.<span class="hljs-property">bar</span>)<br>&#125;)<br><span class="hljs-comment">// 修改 obj.foo.bar 的值，并不能触发响应</span><br>obj.<span class="hljs-property">foo</span>.<span class="hljs-property">bar</span> = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>由上面这段代码可知，当我们读取 obj.foo.bar 时，首先要读取 obj.foo 的值。这里我们直接使用 Reflect.get 函数返回 obj.foo 的结果。由于通过 Reflect.get 得到 obj.foo 的结果是一个普通对象，即 { bar: 1 }，它并不是一个响应式对象，所以在副作用函数中访问 obj.foo.bar 时，是不能建立响应联系的。要解决这个问题，我们需要对 Reflect.get 返回的结果做一层包装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) &#123;<br>      <span class="hljs-keyword">if</span> (key === <span class="hljs-string">&#x27;raw&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> target<br>      &#125;<br>      <span class="hljs-title function_">track</span>(target, key)<br>      <span class="hljs-comment">// 得到原始值结果</span><br>      <span class="hljs-keyword">const</span> res = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver)<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> res === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; res !== <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 调用 reactive 将结果包装成响应式数据并返回</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">reactive</span>(res)<br>      &#125;<br>      <span class="hljs-comment">// 返回 res</span><br>      <span class="hljs-keyword">return</span> res<br>    &#125;<br>  <span class="hljs-comment">// 省略其他拦截函数</span><br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://code.juejin.cn/pen/7351236887694180362">△ 运行代码</a></p><p>然而，并非所有情况下我们都希望深响应，这就催生了 shallowReactive，即浅响应。所谓浅响应，指的是只有对象的第一层属性是响应的，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">shallowReactive</span>(&#123; <span class="hljs-attr">foo</span>: &#123; <span class="hljs-attr">bar</span>: <span class="hljs-number">1</span> &#125; &#125;)<br><span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">foo</span>.<span class="hljs-property">bar</span>)<br>&#125;)<br><br><span class="hljs-comment">// obj.foo 是响应的，可以触发副作用函数重新执行</span><br>obj.<span class="hljs-property">foo</span> = &#123; <span class="hljs-attr">bar</span>: <span class="hljs-number">2</span> &#125;<br><span class="hljs-comment">// obj.foo.bar 不是响应的，不能触发副作用函数重新执行</span><br>obj.<span class="hljs-property">foo</span>.<span class="hljs-property">bar</span> = <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>在这个例子中，我们使用 shallowReactive 函数创建了一个浅响应的代理对象 obj。可以发现，只有对象的第一层属性是响应的，第二层及更深层次的属性则不是响应的。实现此功能并不难，如下面的代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">// 封装 createReactive 函数，接收一个参数 isShallow，代表是否为浅响应，默认为 false，即非浅响应</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createReactive</span>(<span class="hljs-params">obj, isShallow = <span class="hljs-literal">false</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>    <span class="hljs-comment">// 拦截读取操作</span><br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) &#123;<br>      <span class="hljs-keyword">if</span> (key === <span class="hljs-string">&#x27;raw&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> target<br>      &#125;<br><br>      <span class="hljs-keyword">const</span> res = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver)<br>      <span class="hljs-title function_">track</span>(target, key)<br><br>      <span class="hljs-comment">// 如果是浅响应，则直接返回原始值</span><br>      <span class="hljs-keyword">if</span> (isShallow) &#123;<br>        <span class="hljs-keyword">return</span> res<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> res === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; res !== <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">reactive</span>(res)<br>      &#125;<br><br>      <span class="hljs-keyword">return</span> res<br>    &#125;<br>  <span class="hljs-comment">// 省略其他拦截函数</span><br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>有了 createReactive 函数后，我们就可以使用它轻松地实现 reactive 以及 shallowReactive 函数了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">createReactive</span>(obj)<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">shallowReactive</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">createReactive</span>(obj, <span class="hljs-literal">true</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://code.juejin.cn/pen/7351244529435213833">△ 运行代码</a></p><h2 id="5-6-只读和浅只读"><a href="#5-6-只读和浅只读" class="headerlink" title="5.6 只读和浅只读"></a>5.6 只读和浅只读</h2><blockquote><p>我们希望一些数据是只读的，当用户尝试修改只读数据时，会收到一条警告信息。这样就实现了对数据的保护，例如组件接收到的 props 对象应该是一个只读数据。这时就要用到接下来要讨论的 readonly 函数，它能够将一个数据变成只读的：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">readonly</span>(&#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span> &#125;)<br><span class="hljs-comment">// 尝试修改数据，会得到警告</span><br>obj.<span class="hljs-property">foo</span> = <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>只读本质上也是对数据对象的代理，我们同样可以使用 createReactive 函数来实现。如下面的代码所示，我们为 createReactive 函数增加第三个参数 isReadonly：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">// 增加第三个参数 isReadonly，代表是否只读，默认为 false，即非只读</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createReactive</span>(<span class="hljs-params">obj, isShallow = <span class="hljs-literal">false</span>, isReadonly = <span class="hljs-literal">false</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>    <span class="hljs-comment">// 拦截读取操作</span><br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) &#123;<br>      <span class="hljs-comment">// 代理对象可以通过 raw 属性访问原始数据</span><br>      <span class="hljs-keyword">if</span> (key === <span class="hljs-string">&#x27;raw&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> target<br>      &#125;<br>      <span class="hljs-comment">// 将副作用函数 activeEffect 添加到存储副作用函数的桶中</span><br>      <span class="hljs-title function_">track</span>(target, key)<br>      <span class="hljs-comment">// 得到原始值结果</span><br>      <span class="hljs-keyword">const</span> res = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver)<br>      <span class="hljs-comment">// 如果是浅响应，则直接返回原始值</span><br>      <span class="hljs-keyword">if</span> (isShallow) &#123;<br>        <span class="hljs-keyword">return</span> res<br>      &#125;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> res === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; res !== <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">reactive</span>(res)<br>      &#125;<br>      <span class="hljs-comment">// 返回 res</span><br>      <span class="hljs-keyword">return</span> res<br>    &#125;,<br>    <span class="hljs-comment">// 拦截设置操作</span><br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, newVal, receiver</span>) &#123;<br>      <span class="hljs-comment">// 如果是只读的，则打印警告信息并返回</span><br>      <span class="hljs-keyword">if</span> (isReadonly) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">`属性 <span class="hljs-subst">$&#123;key&#125;</span> 是只读的`</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>      &#125;<br>      <span class="hljs-comment">// 先获取旧值</span><br>      <span class="hljs-keyword">const</span> oldVal = target[key]<br>      <span class="hljs-comment">// 设置属性值</span><br>      <span class="hljs-keyword">const</span> res = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, newVal, receiver)<br><br>      <span class="hljs-comment">// target === receiver.raw 说明 receiver 就是 target 的代理对象</span><br>      <span class="hljs-keyword">if</span> (target === receiver.<span class="hljs-property">raw</span>) &#123;<br>        <span class="hljs-keyword">if</span> (oldVal !== newVal &amp;&amp; (oldVal === oldVal || newVal === newVal)) &#123;<br>          <span class="hljs-comment">// 把副作用函数从桶里取出并执行</span><br>          <span class="hljs-title function_">trigger</span>(target, key);<br>        &#125;<br>      &#125;<br><br>      <span class="hljs-keyword">return</span> res;<br>    &#125;,<br>    <span class="hljs-comment">// 拦截删除操作</span><br>    <span class="hljs-title function_">deleteProperty</span>(<span class="hljs-params">target, key</span>) &#123;<br>      <span class="hljs-comment">// 如果是只读的，则打印警告信息并返回</span><br>      <span class="hljs-keyword">if</span> (isReadonly) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">`属性 <span class="hljs-subst">$&#123;key&#125;</span> 是只读的`</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>      &#125;<br>      <span class="hljs-keyword">const</span> hadKey = <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title function_">call</span>(target, key)<br>      <span class="hljs-keyword">const</span> res = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">deleteProperty</span>(target, key)<br>      <span class="hljs-keyword">if</span> (res &amp;&amp; hadKey) &#123;<br>        <span class="hljs-title function_">trigger</span>(target, key, <span class="hljs-string">&#x27;DELETE&#x27;</span>)<br>      &#125;<br>      <span class="hljs-keyword">return</span> res<br>    &#125;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>当然，如果一个数据是只读的，那就意味着任何方式都无法修改它。因此，没有必要为只读数据建立响应联系</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">// 增加第三个参数 isReadonly，代表是否只读，默认为 false，即非只读</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createReactive</span>(<span class="hljs-params">obj, isShallow = <span class="hljs-literal">false</span>, isReadonly = <span class="hljs-literal">false</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>    <span class="hljs-comment">// 拦截读取操作</span><br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) &#123;<br>      <span class="hljs-comment">// 代理对象可以通过 raw 属性访问原始数据</span><br>      <span class="hljs-keyword">if</span> (key === <span class="hljs-string">&#x27;raw&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> target<br>      &#125;<br>      <span class="hljs-comment">// 非只读的时候才需要建立响应联系</span><br>      <span class="hljs-keyword">if</span> (!isReadonly) &#123;<br>        <span class="hljs-comment">// 将副作用函数 activeEffect 添加到存储副作用函数的桶中</span><br>        <span class="hljs-title function_">track</span>(target, key)<br>      &#125;<br>      <span class="hljs-comment">// 得到原始值结果</span><br>      <span class="hljs-keyword">const</span> res = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver)<br>      <span class="hljs-comment">// 如果是浅响应，则直接返回原始值</span><br>      <span class="hljs-keyword">if</span> (isShallow) &#123;<br>        <span class="hljs-keyword">return</span> res<br>      &#125;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> res === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; res !== <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">reactive</span>(res)<br>      &#125;<br>      <span class="hljs-comment">// 返回 res</span><br>      <span class="hljs-keyword">return</span> res<br>    &#125;,<br>    <span class="hljs-comment">// 省略其他拦截函数</span><br>  &#125;);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">readonly</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">createReactive</span>(obj, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span> <span class="hljs-comment">/* 只读 */</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>然而，上面实现的 readonly 函数更应该叫作 shallowReadonly，因为它没有做到深只读：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> obj = <span class="hljs-title function_">readonly</span>(&#123; <span class="hljs-attr">foo</span>: &#123; <span class="hljs-attr">bar</span>: <span class="hljs-number">1</span> &#125; &#125;)<br>obj.<span class="hljs-property">foo</span>.<span class="hljs-property">bar</span> = <span class="hljs-number">2</span> <span class="hljs-comment">// 仍然可以修改</span><br></code></pre></td></tr></table></figure><p>所以为了实现深只读，我们还应该在 get 拦截函数内递归地调用 readonly 将数据包装成只读的代理对象，并将其作为返回值返回：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createReactive</span>(<span class="hljs-params">obj, isShallow = <span class="hljs-literal">false</span>, isReadonly = <span class="hljs-literal">false</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>    <span class="hljs-comment">// 拦截读取操作</span><br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) &#123;<br>      <span class="hljs-comment">// 代理对象可以通过 raw 属性访问原始数据</span><br>      <span class="hljs-keyword">if</span> (key === <span class="hljs-string">&#x27;raw&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> target<br>      &#125;<br>      <span class="hljs-comment">// 非只读的时候才需要建立响应联系</span><br>      <span class="hljs-keyword">if</span> (!isReadonly) &#123;<br>      <span class="hljs-comment">// 将副作用函数 activeEffect 添加到存储副作用函数的桶中</span><br>        <span class="hljs-title function_">track</span>(target, key)<br>      &#125;<br>      <span class="hljs-comment">// 得到原始值结果</span><br>      <span class="hljs-keyword">const</span> res = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver)<br>      <span class="hljs-comment">// 如果是浅响应，则直接返回原始值</span><br>      <span class="hljs-keyword">if</span> (isShallow) &#123;<br>        <span class="hljs-keyword">return</span> res<br>      &#125;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> res === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; res !== <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 如果数据为只读，则调用 readonly 对值进行包装</span><br>        <span class="hljs-keyword">return</span> isReadonly ? <span class="hljs-title function_">readonly</span>(res) : <span class="hljs-title function_">reactive</span>(res)<br>      &#125;<br>      <span class="hljs-comment">// 返回 res</span><br>      <span class="hljs-keyword">return</span> res<br>    &#125;,<br>    <span class="hljs-comment">// 省略其他拦截函数</span><br>  &#125;);<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">readonly</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">createReactive</span>(obj, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span> <span class="hljs-comment">/* 只读 */</span>)<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">shallowReadonly</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">createReactive</span>(obj, <span class="hljs-literal">true</span> <span class="hljs-comment">/* shallow */</span>, <span class="hljs-literal">true</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>如上面的代码所示，在 shallowReadonly 函数内调用 createReactive 函数创建代理对象时，将第二个参数 isShallow 设置为 true，这样就可以创建一个浅只读的代理对象了。</p><p><a href="https://code.juejin.cn/pen/7351247406341554226">△ 运行代码</a></p><h2 id="5-7-代理数组"><a href="#5-7-代理数组" class="headerlink" title="5.7 代理数组"></a>5.7 代理数组</h2><blockquote><p>在 JavaScript 中，数组只是一个特殊的对象</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> arr = <span class="hljs-title function_">reactive</span>([<span class="hljs-string">&#x27;foo&#x27;</span>])<br><span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">0</span>]) <span class="hljs-comment">// &#x27;foo&#x27;</span><br>&#125;)<br>arr[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;bar&#x27;</span> <span class="hljs-comment">// 能够触发响应</span><br></code></pre></td></tr></table></figure><p>上面这段代码能够按预期工作。实际上，当我们通过索引读取或设置数组元素的值时，代理对象的 get&#x2F;set 拦截函数也会执行，因此我们不需要做任何额外的工作，就能够让数组索引的读取和设置操作是响应式的了。</p><ul><li>数组的操作与对普通对象的操作仍然存在不同，下面总结了对数组元素或属性的“读取”操作：</li><li>通过索引访问数组元素值：arr[0]。</li><li>访问数组的长度：arr.length。</li><li>把数组作为对象，使用 for…in 循环遍历。</li><li>使用 for…of 迭代遍历数组。</li><li>数组的原型方法，如 concat&#x2F;join&#x2F;every&#x2F;some&#x2F;find&#x2F;findIndex&#x2F;includes 等，以及其他所有不改变原数组的原型方法。</li></ul><h3 id="5-7-1-数组的索引与-length"><a href="#5-7-1-数组的索引与-length" class="headerlink" title="5.7.1 数组的索引与 length"></a>5.7.1 数组的索引与 length</h3><p>拿本节开头的例子来说，当通过数组的索引访问元素的值时，已经能够建立响应联系了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> arr = <span class="hljs-title function_">reactive</span>([<span class="hljs-string">&#x27;foo&#x27;</span>])<br><span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">0</span>]) <span class="hljs-comment">// &#x27;foo&#x27;</span><br>&#125;)<br>arr[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;bar&#x27;</span> <span class="hljs-comment">// 能够触发响应</span><br></code></pre></td></tr></table></figure><p>但通过索引设置数组的元素值与设置对象的属性值仍然存在根本上的不同，这是因为数组对象部署的内部方法[[DefineOwnProperty]] 不同于常规对象。实际上，当我们通过索引设置数组元素的值时，会执行数组对象所部署的内部方法[[Set]]，这一步与设置常规对象的属性值一样。根据规范可知，内部方法 [[Set]] 其实依赖于 [[DefineOwnProperty]]，到了这里就体现出了差异。<br><img src="/../../img/vue/vue5/arr_defineOwnProperty.png"><br>规范中明确说明，如果设置的索引值大于数组当前的长度，那么要更新数组的 length 属性。所以当通过索引设置元素值时，可能会隐式地修改 length 的属性值。因此在触发响应时，也应该触发与 length 属性相关联的副作用函数重新执行，如下面的代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> arr = <span class="hljs-title function_">reactive</span>([<span class="hljs-string">&#x27;foo&#x27;</span>]) <span class="hljs-comment">// 数组的原长度为 1</span><br><span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-property">length</span>) <span class="hljs-comment">// 1</span><br>&#125;)<br><span class="hljs-comment">// 设置索引 1 的值，会导致数组的长度变为 2</span><br>arr[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;bar&#x27;</span><br></code></pre></td></tr></table></figure><p>为了实现目标，我们需要修改 set 拦截函数，如下面的代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createReactive</span>(<span class="hljs-params">obj, isShallow = <span class="hljs-literal">false</span>, isReadonly = <span class="hljs-literal">false</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>    <span class="hljs-comment">// 拦截设置操作</span><br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, newVal, receiver</span>) &#123;<br>      <span class="hljs-comment">// 如果是只读的，则打印警告信息并返回</span><br>      <span class="hljs-keyword">if</span> (isReadonly) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">`属性 <span class="hljs-subst">$&#123;key&#125;</span> 是只读的`</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>      &#125;<br>      <span class="hljs-comment">// 先获取旧值</span><br>      <span class="hljs-keyword">const</span> oldVal = target[key]<br>      <span class="hljs-comment">// 如果属性不存在，则说明是在添加新的属性，否则是设置已有属性</span><br>      <span class="hljs-keyword">const</span> type = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(target)<br>        <span class="hljs-comment">// 如果代理目标是数组，则检测被设置的索引值是否小于数组长度，</span><br>        <span class="hljs-comment">// 如果是，则视作 SET 操作，否则是 ADD 操作</span><br>        ? <span class="hljs-title class_">Number</span>(key) &lt; target.<span class="hljs-property">length</span> ? <span class="hljs-string">&#x27;SET&#x27;</span> : <span class="hljs-string">&#x27;ADD&#x27;</span><br>        : <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title function_">call</span>(target, key) ?<br>          <span class="hljs-string">&#x27;SET&#x27;</span> : <span class="hljs-string">&#x27;ADD&#x27;</span><br>      <span class="hljs-comment">// 设置属性值</span><br>      <span class="hljs-keyword">const</span> res = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, newVal, receiver)<br><br>      <span class="hljs-comment">// target === receiver.raw 说明 receiver 就是 target 的代理对象</span><br>      <span class="hljs-keyword">if</span> (target === receiver.<span class="hljs-property">raw</span>) &#123;<br>        <span class="hljs-keyword">if</span> (oldVal !== newVal &amp;&amp; (oldVal === oldVal || newVal === newVal)) &#123;<br>          <span class="hljs-comment">// 把副作用函数从桶里取出并执行</span><br>          <span class="hljs-title function_">trigger</span>(target, key, type);<br>        &#125;<br>      &#125;<br><br>      <span class="hljs-keyword">return</span> res;<br>    &#125;,<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在判断操作类型时，新增了对数组类型的判断。如果代理的目标对象是数组，那么对于操作类型的判断会有所区别。即被设置的索引值如果小于数组长度，就视作 SET 操作，因为它不会改变数组长度；如果设置的索引值大于数组的当前长度，则视作 ADD 操作，因为这会隐式地改变数组的 length 属性值。有了这些信息，我们就可以在 trigger 函数中正确地触发与数组对象的 length 属性相关联的副作用函数重新执行了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">trigger</span>(<span class="hljs-params">target, key, type</span>) &#123;<br>  <span class="hljs-keyword">const</span> depsMap = bucket.<span class="hljs-title function_">get</span>(target)<br>  <span class="hljs-keyword">if</span> (!depsMap) <span class="hljs-keyword">return</span><br>  <span class="hljs-comment">// 省略部分内容</span><br>  <span class="hljs-comment">// 当操作类型为 ADD 并且目标对象是数组时，应该取出并执行那些与 length属性相关联的副作用函数</span><br>  <span class="hljs-keyword">if</span> (type === <span class="hljs-string">&#x27;ADD&#x27;</span> &amp;&amp; <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(target)) &#123;<br>    <span class="hljs-comment">// 取出与 length 相关联的副作用函数</span><br>    <span class="hljs-keyword">const</span> lengthEffects = depsMap.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;length&#x27;</span>)<br>    <span class="hljs-comment">// 将这些副作用函数添加到 effectsToRun 中，待执行</span><br>    lengthEffects &amp;&amp; lengthEffects.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">effectFn</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (effectFn !== activeEffect) &#123;<br>        effectsToRun.<span class="hljs-title function_">add</span>(effectFn)<br>      &#125;<br>    &#125;)<br>  &#125;<br>  effectsToRun.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">effectFn</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (effectFn.<span class="hljs-property">options</span>.<span class="hljs-property">scheduler</span>) &#123;<br>      effectFn.<span class="hljs-property">options</span>.<span class="hljs-title function_">scheduler</span>(effectFn)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">effectFn</span>()<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://code.juejin.cn/pen/7351292423236304946">△ 运行代码</a></p><p>但是反过来思考，其实修改数组的 length 属性也会隐式地影响数组元素，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> arr = <span class="hljs-title function_">reactive</span>([<span class="hljs-string">&#x27;foo&#x27;</span>])<br><span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 访问数组的第 0 个元素</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr[<span class="hljs-number">0</span>]) <span class="hljs-comment">// foo</span><br>&#125;)<br><span class="hljs-comment">// 将数组的长度修改为 0，导致第 0 个元素被删除，因此应该触发响应</span><br>arr.<span class="hljs-property">length</span> = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>如上面的代码所示，在副作用函数内访问了数组的第 0 个元素，接着将数组的 length 属性修改为 0。我们知道这会隐式地影响数组元素，即所有元素都被删除，所以应该触发副作用函数重新执行。然而并非所有对 length 属性的修改都会影响数组中的已有元素，拿上例来说，如果我们将 length 属性设置为 100，这并不会影响第 0 个元素，所以也就不需要触发副作用函数重新执行。这让我们意识到，当修改 length 属性值时，只有那些索引值大于或等于新的 length 属性值的元素才需要触发响应。但无论如何，目前的实现还做不到这一点，为了实现目标，我们需要修改 set 拦截函数。在调用 trigger 函数触发响应时，应该把新的属性值传递过去：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createReactive</span>(<span class="hljs-params">obj, isShallow = <span class="hljs-literal">false</span>, isReadonly = <span class="hljs-literal">false</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>    <span class="hljs-comment">// 拦截设置操作</span><br>    <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, newVal, receiver</span>) &#123;<br>      <span class="hljs-comment">// 如果是只读的，则打印警告信息并返回</span><br>      <span class="hljs-keyword">if</span> (isReadonly) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">warn</span>(<span class="hljs-string">`属性 <span class="hljs-subst">$&#123;key&#125;</span> 是只读的`</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>      &#125;<br>      <span class="hljs-comment">// 先获取旧值</span><br>      <span class="hljs-keyword">const</span> oldVal = target[key]<br>      <span class="hljs-comment">// 如果属性不存在，则说明是在添加新的属性，否则是设置已有属性</span><br>      <span class="hljs-keyword">const</span> type = <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(target)<br>        <span class="hljs-comment">// 如果代理目标是数组，则检测被设置的索引值是否小于数组长度，</span><br>        <span class="hljs-comment">// 如果是，则视作 SET 操作，否则是 ADD 操作</span><br>        ? <span class="hljs-title class_">Number</span>(key) &lt; target.<span class="hljs-property">length</span> ? <span class="hljs-string">&#x27;SET&#x27;</span> : <span class="hljs-string">&#x27;ADD&#x27;</span><br>        : <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">hasOwnProperty</span>.<span class="hljs-title function_">call</span>(target, key) ?<br>          <span class="hljs-string">&#x27;SET&#x27;</span> : <span class="hljs-string">&#x27;ADD&#x27;</span><br>      <span class="hljs-comment">// 设置属性值</span><br>      <span class="hljs-keyword">const</span> res = <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">set</span>(target, key, newVal, receiver)<br><br>      <span class="hljs-comment">// target === receiver.raw 说明 receiver 就是 target 的代理对象</span><br>      <span class="hljs-keyword">if</span> (target === receiver.<span class="hljs-property">raw</span>) &#123;<br>        <span class="hljs-keyword">if</span> (oldVal !== newVal &amp;&amp; (oldVal === oldVal || newVal === newVal)) &#123;<br>          <span class="hljs-comment">// 把副作用函数从桶里取出并执行</span><br>          <span class="hljs-comment">// 增加第四个参数，即触发响应的新值</span><br>          <span class="hljs-title function_">trigger</span>(target, key, type, newVal);<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> res;<br>    &#125;,<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>接着，我们还需要修改 trigger 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">// 在 set 拦截函数内调用 trigger 函数触发变化</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">trigger</span>(<span class="hljs-params">target, key, type, newVal</span>) &#123;<br>  <span class="hljs-keyword">const</span> depsMap = bucket.<span class="hljs-title function_">get</span>(target);<br>  <span class="hljs-keyword">if</span> (!depsMap) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">const</span> effects = depsMap.<span class="hljs-title function_">get</span>(key);<br><br>  <span class="hljs-keyword">const</span> effectsToRun = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()<br>  <span class="hljs-comment">// 将与 key 相关联的副作用函数添加到 effectsToRun</span><br>  effects &amp;&amp; effects.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">effectFn</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 如果 trigger 触发执行的副作用函数与当前正在执行的副作用函数相同，则不触发执行</span><br>    <span class="hljs-keyword">if</span> (effectFn !== activeEffect) &#123;<br>      effectsToRun.<span class="hljs-title function_">add</span>(effectFn)<br>    &#125;<br>  &#125;)<br><br>  <span class="hljs-comment">// 如果操作目标是数组，并且修改了数组的 length 属性</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(target) &amp;&amp; key === <span class="hljs-string">&#x27;length&#x27;</span>) &#123;<br>    <span class="hljs-comment">// 对于索引大于或等于新的 length 值的元素，</span><br>    <span class="hljs-comment">// 需要把所有相关联的副作用函数取出并添加到 effectsToRun 中待执行</span><br>    depsMap.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">effects, key</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (key &gt;= newVal) &#123;<br>        effects.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">effectFn</span> =&gt;</span> &#123;<br>          <span class="hljs-keyword">if</span> (effectFn == activeEffect) &#123;<br>            effectsToRun.<span class="hljs-title function_">add</span>(effectFn)<br>          &#125;<br>        &#125;)<br>      &#125;<br>    &#125;)<br>  &#125;<br><br>  effectsToRun.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">effectFn</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 如果一个副作用函数存在调度器，则调用该调度器，并将副作用函数作为参数传递</span><br>    <span class="hljs-keyword">if</span> (effectFn?.<span class="hljs-property">options</span>?.<span class="hljs-property">scheduler</span>) &#123; <span class="hljs-comment">// 新增</span><br>      effectFn.<span class="hljs-property">options</span>.<span class="hljs-title function_">scheduler</span>(effectFn) <span class="hljs-comment">// 新增</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 否则直接执行副作用函数（之前的默认行为）</span><br>      <span class="hljs-title function_">effectFn</span>() <span class="hljs-comment">// 新增</span><br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>如上面的代码所示，为 trigger 函数增加了第四个参数，即触发响应时的新值。在本例中，新值指的是新的 length 属性值，它代表新的数组长度。接着，我们判断操作的目标是否是数组，如果是，则需要找到所有索引值大于或等于新的 length 值的元素，然后把与它们相关联的副作用函数取出并执行。</p><p><a href="https://code.juejin.cn/pen/7351292423236304946">△ 运行代码</a></p><h3 id="5-7-2-遍历数组"><a href="#5-7-2-遍历数组" class="headerlink" title="5.7.2 遍历数组"></a>5.7.2 遍历数组</h3><p>既然数组也是对象，就意味着同样可以使用 for…in 循环遍历：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> arr = <span class="hljs-title function_">reactive</span>([<span class="hljs-string">&#x27;foo&#x27;</span>])<br><span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> arr) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key) <span class="hljs-comment">// 0</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>使用 for…in 循环遍历数组与遍历常规对象并无差异，因此同样可以使用 ownKeys 拦截函数进行拦截：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createReactive</span>(<span class="hljs-params">obj, isShallow = <span class="hljs-literal">false</span>, isReadonly = <span class="hljs-literal">false</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>    <span class="hljs-comment">// 省略其他拦截函数</span><br>    <span class="hljs-title function_">ownKeys</span>(<span class="hljs-params">target</span>) &#123;<br>      <span class="hljs-title function_">track</span>(target, <span class="hljs-variable constant_">ITERATE_KEY</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(target)<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>其实，无论是为数组添加新元素，还是直接修改数组的长度，本质上都是因为修改了数组的 length 属性。一旦数组的 length 属性被修改，那么 for…in 循环对数组的遍历结果就会改变，所以在这种情况下我们应该触发响应。很自然的，我们可以在 ownKeys 拦截函数内，判断当前操作目标 target 是否是数组，如果是，则使用 length 作为 key 去建立响应联系：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createReactive</span>(<span class="hljs-params">obj, isShallow = <span class="hljs-literal">false</span>, isReadonly = <span class="hljs-literal">false</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>    <span class="hljs-comment">// 省略其他拦截函数</span><br>    <span class="hljs-title function_">ownKeys</span>(<span class="hljs-params">target</span>) &#123;<br>      <span class="hljs-comment">// 如果操作目标 target 是数组，则使用 length 属性作为 key 并建立响应联系</span><br>      <span class="hljs-title function_">track</span>(target, <span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(target) ? <span class="hljs-string">&#x27;length&#x27;</span> : <span class="hljs-variable constant_">ITERATE_KEY</span>)<br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">ownKeys</span>(target)<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>这样无论是为数组添加新元素，还是直接修改 length 属性，都能够正确地触发响应了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JS"><br><span class="hljs-keyword">const</span> arr = <span class="hljs-title function_">reactive</span>([<span class="hljs-string">&#x27;foo&#x27;</span>])<br><span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> arr) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key)<br>  &#125;<br>&#125;)<br><br>arr[<span class="hljs-number">1</span>] = <span class="hljs-string">&#x27;bar&#x27;</span> <span class="hljs-comment">// 能够触发副作用函数重新执行</span><br>arr.<span class="hljs-property">length</span> = <span class="hljs-number">0</span> <span class="hljs-comment">// 能够触发副作用函数重新执行</span><br></code></pre></td></tr></table></figure><p><a href="https://code.juejin.cn/pen/7351314061654491174">△ 运行代码</a></p><h3 id="5-7-3-数组的查找方法"><a href="#5-7-3-数组的查找方法" class="headerlink" title="5.7.3 数组的查找方法"></a>5.7.3 数组的查找方法</h3><p>通过上一节的介绍我们意识到，数组的方法内部其实都依赖了对象的基本语义。所以大多数情况下，我们不需要做特殊处理即可让这些方法按预期工作，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> arr = <span class="hljs-title function_">reactive</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>])<br><span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">includes</span>(<span class="hljs-number">1</span>)) <span class="hljs-comment">// 初始打印 true</span><br>&#125;)<br>arr[<span class="hljs-number">0</span>] = <span class="hljs-number">3</span> <span class="hljs-comment">// 副作用函数重新执行，并打印 false</span><br></code></pre></td></tr></table></figure><p>然而 includes 方法并不总是按照预期工作，举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> obj = &#123;&#125;<br><span class="hljs-keyword">const</span> arr = <span class="hljs-title function_">reactive</span>([obj])<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">includes</span>(arr[<span class="hljs-number">0</span>])) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>这个操作应该返回 true，但运行这段代码，会发现它返回了 false。<br>这是因为 arr[0] 得到的是一个代理对象，而在 includes 方法内部也会通过 arr 访问数组元素，从而也得到一个代理对象，问题是这两个代理对象是不同的。这是因为每次调用 reactive 函数时都会创建一个新的代理对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-comment">// 每次调用 reactive 时，都会创建新的代理对象</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">createReactive</span>(obj)<br>&#125;<br></code></pre></td></tr></table></figure><p>即使参数 obj 是相同的，每次调用 reactive 函数时，也都会创建新的代理对象。这个问题的解决方案如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">// 定义一个 Map 实例，存储原始对象到代理对象的映射</span><br><span class="hljs-keyword">const</span> reactiveMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reactive</span>(<span class="hljs-params">obj</span>) &#123;<br>  <span class="hljs-comment">// 优先通过原始对象 obj 寻找之前创建的代理对象，如果找到了，直接返回已有的代理对象</span><br>  <span class="hljs-keyword">const</span> existionProxy = reactiveMap.<span class="hljs-title function_">get</span>(obj)<br>  <span class="hljs-keyword">if</span> (existionProxy) <span class="hljs-keyword">return</span> existionProxy<br>  <span class="hljs-comment">// 否则，创建新的代理对象</span><br>  <span class="hljs-keyword">const</span> proxy = <span class="hljs-title function_">createReactive</span>(obj)<br>  <span class="hljs-comment">// 存储到 Map 中，从而避免重复创建</span><br>  reactiveMap.<span class="hljs-title function_">set</span>(obj, proxy)<br>  <span class="hljs-keyword">return</span> proxy<br>&#125;<br></code></pre></td></tr></table></figure><p>我们再次运行本节开头的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> obj = &#123;&#125;<br><span class="hljs-keyword">const</span> arr = <span class="hljs-title function_">reactive</span>([obj])<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">includes</span>(arr[<span class="hljs-number">0</span>])) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>此时的行为已经符合预期了，但如果修改一个值，就发现就会有新的问题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> obj = &#123;&#125;<br><span class="hljs-keyword">const</span> arr = <span class="hljs-title function_">reactive</span>([obj])<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">includes</span>(obj)) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure><p>在上面这段代码中，我们直接把原始对象作为参数传递给 includes 方法，这是很符合直觉的行为。而从用户的角度来看，自己明明把 obj 作为数组的第一个元素了，为什么在数组中却仍然找不到 obj 对象呢？其实原因很简单，因为 includes 内部的 this 指向的是代理对象 arr，并且在获取数组元素时得到的值也是代理对象，所以拿原始对象 obj 去查找肯定找不到，因此返回 false。为此，我们需要重写数组的 includes 方法并实现自定义的行为才能解决这问题。首先，我们来看如何重写 includes 方法，如下面的代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">// 拦截读取操作</span><br><span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) &#123;<br>  <span class="hljs-keyword">if</span> (key === <span class="hljs-string">&#x27;raw&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> target<br>  &#125;<br>  <span class="hljs-comment">// 如果操作的目标对象是数组，并且 key 存在于arrayInstrumentations 上，</span><br>  <span class="hljs-comment">// 那么返回定义在 arrayInstrumentations 上的值</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(target) &amp;&amp; arrayInstrumentations.<span class="hljs-title function_">hasOwnProperty</span>(key)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(arrayInstrumentations, key, receiver)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面这段代码中，我们修改了 get 拦截函数，目的是重写数组的 includes 方法。具体怎么做呢？<br>我们知道，arr.includes 可以理解为读取代理对象 arr 的 includes 属性，这就会触发 get 拦截函数，在该函数内检查 target 是否是数组，如果是数组并且读取的键值存在于 arrayInstrumentations 上，则返回定义在 arrayInstrumentations 对象上相应的值。也就是说，当执行 arr.includes 时，实际执行的是定义在 arrayInstrumentations 上的 includes 函数，这样就实现了重写。<br>接下来，我们就可以自定义 includes 函数了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> originMethod = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">includes</span><br><span class="hljs-keyword">const</span> arrayInstrumentations = &#123;<br><span class="hljs-attr">includes</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) &#123;<br><span class="hljs-comment">// this 是代理对象，先在代理对象中查找，将结果存储到 res 中</span><br><span class="hljs-keyword">let</span> res = originMethod.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args)<br><span class="hljs-keyword">if</span> (res === <span class="hljs-literal">false</span>) &#123;<br><span class="hljs-comment">// res 为 false 说明没找到，通过 this.raw 拿到原始数组，再去其中查找并更新 res 值</span><br>res = originMethod.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">raw</span>, args)<br>&#125;<br><span class="hljs-comment">// 返回最终结果</span><br><span class="hljs-keyword">return</span> res<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上面这段代码所示，其中 includes 方法内的 this 指向的是代理对象，我们先在代理对象中进行查找，这其实是实现了 arr.include(obj) 的默认行为。如果找不到，通过 this.raw 拿到原始数组，再去其中查找，最后返回结果，这样就解决了上述问题。</p><p><a href="https://code.juejin.cn/pen/7351328934342066202">△ 运行代码</a></p><p>除了 includes 方法之外，还需要做类似处理的数组方法有 indexOf 和 lastIndexOf，因为它们都属于根据给定的值返回查找<br>结果的方法。完整的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">// 重写数组方法</span><br><span class="hljs-keyword">const</span> arrayInstrumentations = &#123;&#125;;<br>[<span class="hljs-string">&#x27;includes&#x27;</span>, <span class="hljs-string">&#x27;indexOf&#x27;</span>, <span class="hljs-string">&#x27;lastIndexOf&#x27;</span>].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">method</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> originMethod = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>[method]<br>  arrayInstrumentations[method] = <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-comment">// this 是代理对象，先在代理对象中查找，将结果存储到 res 中</span><br>    <span class="hljs-keyword">let</span> res = originMethod.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args)<br>    <span class="hljs-keyword">if</span> (res === <span class="hljs-literal">false</span> || res === -<span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-comment">// res 为 false 说明没找到，通过 this.raw 拿到原始数组，再去其中查找，并更新 res 值</span><br>      res = originMethod.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">raw</span>, args)<br>    &#125;<br>    <span class="hljs-comment">// 返回最终结果</span><br>    <span class="hljs-keyword">return</span> res<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="5-7-4-隐式修改数组长度的原型方法"><a href="#5-7-4-隐式修改数组长度的原型方法" class="headerlink" title="5.7.4 隐式修改数组长度的原型方法"></a>5.7.4 隐式修改数组长度的原型方法</h3><blockquote><p>本节中我们讲解如何处理那些会隐式修改数组长度的方法，主要指的是数组的栈方法，例如 push&#x2F;pop&#x2F;shift&#x2F;unshift。除此之外，splice 方法也会隐式地修改数组长度</p></blockquote><p>当调用数组的 push 方法向数组中添加元素时，既会读取数组的 length 属性值，也会设置数组的 length 属性值。这会导致两个独立的副作用函数互相影响。以下面的代码为例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> arr = <span class="hljs-title function_">reactive</span>([])<br><span class="hljs-comment">// 第一个副作用函数</span><br><span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">1</span>)<br>&#125;)<br><span class="hljs-comment">// 第二个副作用函数</span><br><span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>arr.<span class="hljs-title function_">push</span>(<span class="hljs-number">1</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>在浏览器中运行上面这段代码，会得到栈溢出的错误（Maximum call stack size exceeded）。<br>我们来详细分析上面这段代码的执行过程:</p><ul><li>第一个副作用函数执行。在该函数内，调用 arr.push 方法向数组中添加了一个元素。我们知道，调用数组的 push 方法会间接读取数组的 length 属性。所以，当第一个副作用函数执行完毕后，会与 length 属性建立响应联系。</li><li>接着，第二个副作用函数执行。同样，它也会与 length 属性建立响应联系。但不要忘记，调用 arr.push 方法不仅会间接读取数组的 length 属性，还会间接设置 length 属性的值。</li><li>第二个函数内的 arr.push 方法的调用设置了数组的 length 属性值。于是，响应系统尝试把与 length 属性相关联的副作用函数全部取出并执行，其中就包括第一个副作用函数。问题就出在这里，可以发现，第二个副作用函数还未执行完毕，就要再次执行第一个副作用函数了。</li><li>第一个副作用函数再次执行。同样，这会间接设置数组的 length 属性。于是，响应系统又要尝试把所有与 length 属性相关联的副作用函数取出并执行，其中就包含第二个副作用函数。</li><li>如此循环往复，最终导致调用栈溢出。</li></ul><p>PS. 问题的原因是 <strong>push 方法的调用会间接读取 length 属性</strong><br>所以，只要我们“屏蔽”对 length 属性的读取，从而避免在它与副作用函数之间建立响应联系，因为数组的 push 方法在语义上是修改操作，而非读取操作，所以避免建立响应联系并不会产生其他副作用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">let</span> shouldTrack = <span class="hljs-literal">true</span><br><span class="hljs-comment">// 重写数组的 push 方法</span><br>[<span class="hljs-string">&#x27;push&#x27;</span>].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">method</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// 取得原始 push 方法</span><br>  <span class="hljs-keyword">const</span> originMethod = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>[method]<br>  <span class="hljs-comment">// 重写</span><br>  arrayInstrumentations[method] = <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    <span class="hljs-comment">// 在调用原始方法之前，禁止追踪</span><br>    shouldTrack = <span class="hljs-literal">false</span><br>    <span class="hljs-comment">// push 方法的默认行为</span><br>    <span class="hljs-keyword">let</span> res = originMethod.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args)<br>    <span class="hljs-comment">// 在调用原始方法之后，恢复原来的行为，即允许追踪</span><br>    shouldTrack = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">return</span> res<br>  &#125;<br>&#125;)<br><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">track</span>(<span class="hljs-params">target, key</span>) &#123;<br>  <span class="hljs-comment">// 当禁止追踪时，直接返回</span><br>  <span class="hljs-keyword">if</span> (!activeEffect || !shouldTrack) <span class="hljs-keyword">return</span><br>  <span class="hljs-comment">// 省略部分代码</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以看到，当标记变量 shouldTrack 的值为 false 时，即禁止追踪时，track 函数会直接返回。这样，当 push 方法间接读取 length 属性值时，由于此时是禁止追踪的状态，所以 length 属性与副作用函数之间不会建立响应联系。我们再次尝试运行刚才这段测试代码，运行正常，不再栈溢出。<br>除了 push 方法之外，pop、shift、unshift 以及 splice 等方法都需要做类似的处理。完整的代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">let</span> shouldTrack = <span class="hljs-literal">true</span><br><span class="hljs-comment">// 重写数组的 push、pop、shift、unshift 以及 splice 方法</span><br>[<span class="hljs-string">&#x27;push&#x27;</span>, <span class="hljs-string">&#x27;pop&#x27;</span>, <span class="hljs-string">&#x27;shift&#x27;</span>, <span class="hljs-string">&#x27;unshift&#x27;</span>, <span class="hljs-string">&#x27;splice&#x27;</span>].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">method</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> originMethod = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>[method]<br>  arrayInstrumentations[method] = <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) &#123;<br>    shouldTrack = <span class="hljs-literal">false</span><br>    <span class="hljs-keyword">let</span> res = originMethod.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args)<br>    shouldTrack = <span class="hljs-literal">true</span><br>    <span class="hljs-keyword">return</span> res<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p><a href="https://code.juejin.cn/pen/7351348945458888719">△ 运行代码</a></p><h2 id="5-8-代理-Set-和-Map"><a href="#5-8-代理-Set-和-Map" class="headerlink" title="5.8 代理 Set 和 Map"></a>5.8 代理 Set 和 Map</h2><blockquote><p>从本节开始，我们将介绍集合类型数据的响应式方案。集合类型包括 Map&#x2F;Set 以及 WeakMap&#x2F;WeakSet。使用 Proxy 代理集合类型的数据不同于代理普通对象，因为集合类型数据的操作与普通对象存在很大的不同。下面总结了 Set 和 Map 这两个数据类型的原型属性和方法。</p></blockquote><p>Set 类型的原型属性和方法如下：</p><ul><li>size：返回集合中元素的数量。</li><li>add(value)：向集合中添加给定的值</li><li>clear()：清空集合。</li><li>delete(value)：从集合中删除给定的值。</li><li>has(value)：判断集合中是否存在给定的值。</li><li>keys()：返回一个迭代器对象。可用于 for…of 循环，迭代器对象产生的值为集合中的元素值。</li><li>values()：对于 Set 集合类型来说，keys() 与 values() 等价。</li><li>entries()：返回一个迭代器对象。迭代过程中为集合中的每一个元素产生一个数组值 [value, value]。</li><li>forEach(callback[, thisArg])：forEach 函数会遍历集合中的所有元素，并对每一个元素调用 callback 函数。forEach 函数接收可选的第二个参数 thisArg，用于指定 callback 函数执行时的 this 值。</li></ul><p>Map 类型的原型属性和方法如下：</p><ul><li>size：返回 Map 数据中的键值对数量。</li><li>clear()：清空 Map。</li><li>delete(key)：删除指定 key 的键值对。</li><li>has(key)：判断 Map 中是否存在指定 key 的键值对。</li><li>get(key)：读取指定 key 对应的值。</li><li>set(key, value)：为 Map 设置新的键值对。</li><li>keys()：返回一个迭代器对象。迭代过程中会产生键值对的 key 值。</li><li>values()：返回一个迭代器对象。迭代过程中会产生键值对的 value 值。</li><li>entries()：返回一个迭代器对象。迭代过程中会产生由 [key,value] 组成的数组值。</li><li>forEach(callback[, thisArg])：forEach 函数会遍历 Map 数据的所有键值对，并对每一个键值对调用 callback 函<br>数。forEach 函数接收可选的第二个参数 thisArg，用于指定 callback 函数执行时的 this 值。</li></ul><p>观察上述列表可以发现，Map 和 Set 这两个数据类型的操作方法相似。它们之间最大的不同体现在，Set 类型使用 add(value) 方法添加元素，而 Map 类型使用 set(key, value) 方法设置键值对，并且 Map 类型可以使用 get(key) 方法读取相应的值。既然两者如此相似，那么是不是意味着我们可以用相同的处理办法来实现对它们的代理呢？没错，接下来，我们就深入探讨如何实现对 Set 和 Map 类型数据的代理。</p><h3 id="5-8-1-如何代理-Set-和-Map"><a href="#5-8-1-如何代理-Set-和-Map" class="headerlink" title="5.8.1 如何代理 Set 和 Map"></a>5.8.1 如何代理 Set 和 Map</h3><p>Set 和 Map 类型的数据有特定的属性和方法用来操作自身。这一点与普通对象不同，如下面的代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">// 普通对象的读取和设置操作</span><br><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span> &#125;<br>obj.<span class="hljs-property">foo</span> <span class="hljs-comment">// 读取属性</span><br>obj.<span class="hljs-property">foo</span> = <span class="hljs-number">2</span> <span class="hljs-comment">// 设置属性</span><br><br><span class="hljs-comment">// 用 get/set 方法操作 Map 数据</span><br><span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br>map.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// 设置数据</span><br>map.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;key&#x27;</span>) <span class="hljs-comment">// 读取数据</span><br></code></pre></td></tr></table></figure><p>正是因为这些差异的存在，我们不能像代理普通对象那样代理 Set 和 Map 类型的数据。但整体思路不变，即当读取操作发生时，应该调用 track 函数建立响应联系；当设置操作发生时，应该调用 trigger 函数触发响应，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> proxy = <span class="hljs-title function_">reactive</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-number">1</span>]]))<br><span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(proxy.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;key&#x27;</span>)) <span class="hljs-comment">// 读取键为 key 的值</span><br>&#125;)<br><br>proxy.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 修改键为 key 的值，应该触发响应</span><br></code></pre></td></tr></table></figure><p>当然，这段代码展示的效果是我们最终要实现的目标。但在动手实现之前，我们有必要先了解关于使用 Proxy 代理 Set 或 Map 类型数据的注意事项：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(s, &#123;&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">size</span>) <span class="hljs-comment">// 报错 TypeError: Method get Set.prototype.size called on incompatible receiver</span><br></code></pre></td></tr></table></figure><p>在这段代码中，我们首先定义了一个 Set 类型的数据 s，接着为它创建一个代理对象 p。由于代理的目标对象是 Set 类型，因此我们可以通过读取它的 p.size 属性获取元素的数量。但不幸的是，我们得到了一个错误。错误信息的大意是“在不兼容的 receiver 上调用了 get Set.prototype.size 方法”。由此我们大概能猜到，size 属性应该是一个访问器属性，所以它作为方法被调用了。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs lua">Set.prototype.size 属性的定义:<br><br>Set.prototype.size 是一个访问器属性，它的 set 访问器函数是 undefined，它的 get 访问器函数会执行以下步骤。<br><span class="hljs-number">1.</span> 让 S 的值为 this。<br><span class="hljs-number">2.</span> 执行 ? RequireInternalSlot(S, <span class="hljs-string">[[SetData]]</span>)。<br><span class="hljs-number">3.</span> 让 entries 的值为 List，即 S.<span class="hljs-string">[[SetData]]</span>。<br><span class="hljs-number">4.</span> 让 count 的 值为 <span class="hljs-number">0</span>。<br><span class="hljs-number">5.</span> 对于 entries 中 的每个元素 e，执行：<br>  a. 如果 e 不是空的，则将 count 设置为 count + <span class="hljs-number">1</span>。<br><span class="hljs-number">6.</span> 返回 (count)。<br></code></pre></td></tr></table></figure><p>由此可知，Set.prototype.size 是一个访问器属性。这里的关键点在第 1 步和第 2 步。根据第 1 步的描述：让 S 的值为 this。这里的 this 是谁呢？由于我们是通过代理对象 p 来访问 size 属性的，所以 this 就是代理对象 p。接着在第 2 步中，调用抽象方法 RequireInternalSlot(S, [[SetData]]) 来检查 S 是否存在内部槽 [[SetData]]。很显然，代理对象 S 不存在 [[SetData]] 这个内部槽，于是会抛出一个错误，也就是前面例子中得到的错误。<br>为了修复这个问题，我们需要修正访问器属性的 getter 函数执行时的 this 指向，如下面的代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(s, &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) &#123;<br>    <span class="hljs-keyword">if</span> (key === <span class="hljs-string">&#x27;size&#x27;</span>) &#123;<br>      <span class="hljs-comment">// 如果读取的是 size 属性</span><br>      <span class="hljs-comment">// 通过指定第三个参数 receiver 为原始对象 target 从而修复问题</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, target)<br>    &#125;<br>    <span class="hljs-comment">// 读取其他属性的默认行为</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, receiver)<br>  &#125;<br>&#125;)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(s.<span class="hljs-property">size</span>) <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>在上面这段代码中，我们在创建代理对象时增加了 get 拦截函数。然后检查读取的属性名称是不是 size，如果是，则在调用 Reflect.get 函数时指定第三个参数为原始 Set 对象，这样访问器属性 size 的 getter 函数在执行时，其 this 指向的就是原始 Set 对象而非代理对象了。由于原始 Set 对象上存在 [[SetData]] 内部槽，因此程序得以正确运行。</p><p>接着，我们再来尝试从 Set 中删除数据，如下面的代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">// 调用 delete 方法删除值为 1 的元素14 // 会得到错误 TypeError: Method Set.prototype.delete called onincompatible receiver [object Object]15</span><br>p.<span class="hljs-title function_">delete</span>(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>可以看到，调用 p.delete 方法时会得到一个错误，这个错误与前文讲解的访问 p.size 属性时发生的错误非常相似。为了搞清楚问题的原因，我们需要详细分析当调用 p.delete(1) 方法时都发生了什么。<br>实际上，访问 p.size 与访问 p.delete 是不同的。这是因为 size 是属性，是一个访问器属性，而 delete 是一个方法。当访问 p.size 时，访问器属性的 getter 函数会立即执行。，此时我们可以通过修改 receiver 来改变 getter 函数的 this 的指向。而当访问 p.delete 时，delete 方法并没有执行，真正使其执行的语句是 p.delete(1) 这句函数调用。因此，无论怎么修改 receiver，delete 方法执行时的 this 都会指向代理对象 p，而不会指向原始 Set 对象。想要修复这个问题也不难，只需要把 delete 方法与原始数据对象绑定即可，如以下代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(s, &#123;<br><span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) &#123;<br>  <span class="hljs-keyword">if</span> (key === <span class="hljs-string">&#x27;size&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, target)<br>  &#125;<br>  <span class="hljs-comment">// 将方法与原始数据对象 target 绑定后返回</span><br>  <span class="hljs-keyword">return</span> target[key].<span class="hljs-title function_">bind</span>(target)<br>&#125;<br>&#125;<br>)<br><span class="hljs-comment">// 调用 delete 方法删除值为 1 的元素，正确执行</span><br>p.<span class="hljs-title function_">delete</span>(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>在上面这段代码中，我们使用 target[key].bind(target)代替了 Reflect.get(target, key, receiver)。可以看到，我们使用 bind 函数将用于操作数据的方法与原始数据对象 target 做了绑定。这样当 p.delete(1) 语句执行时，delete 函数的 this 总是指向原始数据对象而非代理对象，于是代码能够正确执行。</p><p><a href="https://code.juejin.cn/pen/7353177082286833705">△ 运行代码</a></p><h3 id="5-8-2-建立响应联系"><a href="#5-8-2-建立响应联系" class="headerlink" title="5.8.2 建立响应联系"></a>5.8.2 建立响应联系</h3><blockquote><p>了解了为 Set 和 Map 类型数据创建代理时的注意事项之后，我们就可以着手实现 Set 类型数据的响应式方案了。其实思路并不复杂，以下面的代码为例：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> p = <span class="hljs-title function_">reactive</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]))<br><span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 在副作用函数内访问 size 属性</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">size</span>)<br>&#125;)<br><span class="hljs-comment">// 添加值为 1 的元素，应该触发响应</span><br>p.<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>这段代码展示了响应式 Set 类型数据的工作方式。首先，在副作用函数内访问了 p.size 属性；接着，调用 p.add 函数向集合中添加数据。由于这个行为会间接改变集合的 size 属性值，所以我们期望副作用函数会重新执行。为了实现这个目标，我们需要在访问 size 属性时调用 track 函数进行依赖追踪，然后在 add 方法执行时调用 trigger 函数触发响应。下面的代码展示了如何进行依赖追踪：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createReactive</span>(<span class="hljs-params">obj, isShallow = <span class="hljs-literal">false</span>, isReadonly = <span class="hljs-literal">false</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) &#123;<br>      <span class="hljs-keyword">if</span> (key === <span class="hljs-string">&#x27;size&#x27;</span>) &#123;<br>        <span class="hljs-comment">// 调用 track 函数建立响应联系</span><br>        <span class="hljs-title function_">track</span>(target, <span class="hljs-variable constant_">ITERATE_KEY</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, target)<br>      &#125;<br>      <span class="hljs-keyword">return</span> target[key].<span class="hljs-title function_">bind</span>(target)<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，当读取 size 属性时，只需要调用 track 函数建立响应联系即可。这里需要注意的是，响应联系需要建立在 ITERATE_KEY 与副作用函数之间，这是因为任何新增、删除操作都会影响 size 属性。接着，我们来看如何触发响应。当调用 add 方法向集合中添加新元素时，应该怎么触发响应呢？很显然，这需要我们实现一个自定义的 add 方法才行，如以下代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">// 定义一个对象，将自定义的 add 方法定义到该对象下</span><br><span class="hljs-keyword">const</span> mutableInstrumentations = &#123;<br>  <span class="hljs-title function_">add</span>(<span class="hljs-params">key</span>) &#123;<span class="hljs-comment">/* ... */</span> &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">createReactive</span>(<span class="hljs-params">obj, isShallow = <span class="hljs-literal">false</span>, isReadonly = <span class="hljs-literal">false</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(obj, &#123;<br>    <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key, receiver</span>) &#123;<br>      <span class="hljs-comment">// 如果读取的是 raw 属性，则返回原始数据对象 target</span><br>      <span class="hljs-keyword">if</span> (key === <span class="hljs-string">&#x27;raw&#x27;</span>) <span class="hljs-keyword">return</span> target<br>      <span class="hljs-keyword">if</span> (key === <span class="hljs-string">&#x27;size&#x27;</span>) &#123;<br>        <span class="hljs-title function_">track</span>(target, <span class="hljs-variable constant_">ITERATE_KEY</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Reflect</span>.<span class="hljs-title function_">get</span>(target, key, target)<br>      &#125;<br>      <span class="hljs-comment">// 返回定义在 mutableInstrumentations 对象下的方法</span><br>      <span class="hljs-keyword">return</span> mutableInstrumentations[key]<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，定义一个对象 mutableInstrumentations，我们会将所有自定义实现的方法都定义到该对象下，例如 mutableInstrumentations.add 方法。然后，在 get 拦截函数内返回定义在 mutableInstrumentations 对象中的方法。这样，当通过 p.add 获取方法时，得到的就是我们自定义的 mutableInstrumentations.add 方法了。有了自定义实现的方法后，就可以在其中调用 trigger 函数触发响应了：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">// 定义一个对象，将自定义的 add 方法定义到该对象下</span><br><span class="hljs-keyword">const</span> mutableInstrumentations = &#123;<br>  <span class="hljs-title function_">add</span>(<span class="hljs-params">key</span>) &#123;<br>    <span class="hljs-comment">// this 仍然指向的是代理对象，通过 raw 属性获取原始数据对象</span><br>    <span class="hljs-keyword">const</span> target = <span class="hljs-variable language_">this</span>.<span class="hljs-property">raw</span><br>    <span class="hljs-comment">// 通过原始数据对象执行 add 方法添加具体的值，</span><br>    <span class="hljs-comment">// 注意，这里不再需要 .bind 了，因为是直接通过 target 调用并执行的</span><br>    <span class="hljs-keyword">const</span> res = target.<span class="hljs-title function_">add</span>(key)<br>    <span class="hljs-comment">// 调用 trigger 函数触发响应，并指定操作类型为 ADD</span><br>    <span class="hljs-title function_">trigger</span>(target, key, <span class="hljs-string">&#x27;ADD&#x27;</span>)<br>    <span class="hljs-comment">// 返回操作结果</span><br>    <span class="hljs-keyword">return</span> res<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上面的代码所示，自定义的 add 函数内的 this 仍然指向代理对象，所以需要通过 this.raw 获取原始数据对象。有了原始数据对象后，就可以通过它调用 target.add 方法，这样就不再需要 .bind 绑定了。待添加操作完成后，调用 trigger 函数触发响应。<br>需要注意的是，我们指定了操作类型为 ADD，这一点很重要。还记得 trigger 函数的实现吗？我们来回顾一下，如下面的代码片段所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">trigger</span>(<span class="hljs-params">target, key, type, newVal</span>) &#123;<br>  <span class="hljs-keyword">const</span> depsMap = bucket.<span class="hljs-title function_">get</span>(target)<br>  <span class="hljs-keyword">if</span> (!depsMap) <span class="hljs-keyword">return</span><br>  <span class="hljs-keyword">const</span> effects = depsMap.<span class="hljs-title function_">get</span>(key)<br>  <span class="hljs-comment">// 省略无关内容</span><br>  <span class="hljs-comment">// 当操作类型 type 为 ADD 时，会取出与 ITERATE_KEY 相关联的副作用函数并执行</span><br>  <span class="hljs-keyword">if</span> (type === <span class="hljs-string">&#x27;ADD&#x27;</span> || type === <span class="hljs-string">&#x27;DELETE&#x27;</span>) &#123;<br>    <span class="hljs-keyword">const</span> iterateEffects = depsMap.<span class="hljs-title function_">get</span>(<span class="hljs-variable constant_">ITERATE_KEY</span>)<br>    iterateEffects &amp;&amp; iterateEffects.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">effectFn</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (effectFn !== activeEffect) &#123;<br>        effectsToRun.<span class="hljs-title function_">add</span>(effectFn)<br>      &#125;<br>    &#125;)<br>  &#125;<br>  effectsToRun.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">effectFn</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (effectFn.<span class="hljs-property">options</span>.<span class="hljs-property">scheduler</span>) &#123;<br>      effectFn.<span class="hljs-property">options</span>.<span class="hljs-title function_">scheduler</span>(effectFn)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">effectFn</span>()<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>当操作类型是 ADD 或 DELETE 时，会取出与 ITERATE_KEY 相关联的副作用函数并执行，这样就可以触发通过访问 size 属性所收集的副作用函数来执行了。当然，如果调用 add 方法添加的元素已经存在于 Set 集合中了，就不再需要触发响应了，这样做对性能更加友好，因此，我们可以对代码做如下优化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> mutableInstrumentations = &#123;<br>  <span class="hljs-title function_">add</span>(<span class="hljs-params">key</span>) &#123;<br>    <span class="hljs-keyword">const</span> target = <span class="hljs-variable language_">this</span>.<span class="hljs-property">raw</span><br>    <span class="hljs-comment">// 先判断值是否已经存在</span><br>    <span class="hljs-keyword">const</span> hadKey = target.<span class="hljs-title function_">has</span>(key)<br>    <span class="hljs-comment">// 只有在值不存在的情况下，才需要触发响应</span><br>    <span class="hljs-keyword">const</span> res = target.<span class="hljs-title function_">add</span>(key)<br>    <span class="hljs-keyword">if</span> (!hadKey) &#123;<br>      <span class="hljs-title function_">trigger</span>(target, key, <span class="hljs-string">&#x27;ADD&#x27;</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面这段代码中，我们先调用 target.has 方法判断值是否已经存在，只有在值不存在的情况下才需要触发响应。<br>在此基础上，我们可以按照类似的思路轻松地实现 delete 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JS"><br><span class="hljs-keyword">const</span> mutableInstrumentations = &#123;<br>  <span class="hljs-title function_">delete</span>(<span class="hljs-params">key</span>) &#123;<br>    <span class="hljs-keyword">const</span> target = <span class="hljs-variable language_">this</span>.<span class="hljs-property">raw</span><br>    <span class="hljs-keyword">const</span> hadKey = target.<span class="hljs-title function_">has</span>(key)<br>    <span class="hljs-keyword">const</span> res = target.<span class="hljs-title function_">delete</span>(key)<br>    <span class="hljs-comment">// 当要删除的元素确实存在时，才触发响应</span><br>    <span class="hljs-keyword">if</span> (hadKey) &#123;<br>      <span class="hljs-title function_">trigger</span>(target, key, <span class="hljs-string">&#x27;DELETE&#x27;</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上面的代码所示，与 add 方法的区别在于，delete 方法只有在要删除的元素确实在集合中存在时，才需要触发响应，这一点恰好与 add 方法相反。</p><p><a href="https://code.juejin.cn/pen/7355010227604815881">△ 运行代码</a></p><h3 id="5-8-3-避免污染原始数据"><a href="#5-8-3-避免污染原始数据" class="headerlink" title="5.8.3 避免污染原始数据"></a>5.8.3 避免污染原始数据</h3><blockquote><p>本节中我们借助 Map 类型数据的 set 和 get 这两个方法来讲解什么是“避免污染原始数据”及其原因。</p></blockquote><p>Map 数据类型拥有 get 和 set 这两个方法:</p><ul><li>当调用 get 方法读取数据时，需要调用 track 函数追踪依赖建立响应联系；</li><li>当调用 set 方法设置数据时，需要调用 trigger 方法触发响应。<br>如下面的代码所示：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> p = <span class="hljs-title function_">reactive</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([[<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-number">1</span>]]))<br><span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;key&#x27;</span>))<br>&#125;)<br>p.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 触发响应</span><br></code></pre></td></tr></table></figure><p>其实想要实现上面这段代码所展示的功能并不难，因为我们已经有了实现 add、delete 等方法的经验。下面是 get 方法的具体实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JS"><br><span class="hljs-keyword">const</span> mutableInstrumentations = &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">key</span>) &#123;<br>    <span class="hljs-comment">// 获取原始对象</span><br>    <span class="hljs-keyword">const</span> target = <span class="hljs-variable language_">this</span>.<span class="hljs-property">raw</span><br>    <span class="hljs-comment">// 判断读取的 key 是否存在</span><br>    <span class="hljs-keyword">const</span> had = target.<span class="hljs-title function_">has</span>(key)<br>    <span class="hljs-comment">// 追踪依赖，建立响应联系</span><br>    <span class="hljs-title function_">track</span>(target, key)<br>    <span class="hljs-comment">// 如果存在，则返回结果。这里要注意的是，如果得到的结果 res 仍然是可代理的数据，</span><br>    <span class="hljs-comment">// 则要返回使用 reactive 包装后的响应式数据</span><br>    <span class="hljs-keyword">if</span> (had) &#123;<br>      <span class="hljs-keyword">const</span> res = target.<span class="hljs-title function_">get</span>(key)<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> res === <span class="hljs-string">&#x27;object&#x27;</span> ? <span class="hljs-title function_">reactive</span>(res) : res<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着，我们来讨论 set 方法的实现。简单来说，当 set 方法被调用时，需要调用 trigger 方法触发响应。只不过在触发响应的时候，需要区分操作的类型是 SET 还是 ADD，如下面的代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> mutableInstrumentations = &#123;<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">key, value</span>) &#123;<br>    <span class="hljs-keyword">const</span> target = <span class="hljs-variable language_">this</span>.<span class="hljs-property">raw</span><br>    <span class="hljs-keyword">const</span> had = target.<span class="hljs-title function_">has</span>(key)<br>    <span class="hljs-comment">// 获取旧值</span><br>    <span class="hljs-keyword">const</span> oldValue = target.<span class="hljs-title function_">get</span>(key)<br>    <span class="hljs-comment">// 设置新值</span><br>    target.<span class="hljs-title function_">set</span>(key, value)<br>    <span class="hljs-comment">// 如果不存在，则说明是 ADD 类型的操作，意味着新增</span><br>    <span class="hljs-keyword">if</span> (!had) &#123;<br>      <span class="hljs-title function_">trigger</span>(target, key, <span class="hljs-string">&#x27;ADD&#x27;</span>)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldValue !== value || (oldValue === oldValue &amp;&amp; value === value)) &#123;<br>      <span class="hljs-comment">// 如果不存在，并且值变了，则是 SET 类型的操作，意味着修改</span><br>      <span class="hljs-title function_">trigger</span>(target, key, <span class="hljs-string">&#x27;SET&#x27;</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码的关键点在于，我们需要判断设置的 key 是否存在，以便区分不同的操作类型。我们知道，对于 SET 类型和 ADD 类型的操作来说，它们最终触发的副作用函数是不同的。因为 ADD 类型的操作会对数据的 size 属性产生影响，所以任何依赖 size 属性的副作用函数都需要在 ADD 类型的操作发生时重新执行。</p><p>上面给出的 set 函数的实现能够正常工作，但它仍然存在问题，即 set 方法会污染原始数据。这是什么意思呢？来看下面的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JS"><br><span class="hljs-comment">// 原始 Map 对象 m</span><br><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()<br><span class="hljs-comment">// p1 是 m 的代理对象</span><br><span class="hljs-keyword">const</span> p1 = <span class="hljs-title function_">reactive</span>(m)<br><span class="hljs-comment">// p2 是另外一个代理对象</span><br><span class="hljs-keyword">const</span> p2 = <span class="hljs-title function_">reactive</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>())<br><span class="hljs-comment">// 为 p1 设置一个键值对，值是代理对象 p2</span><br>p1.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;p2&#x27;</span>, p2)<br><span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 注意，这里我们通过原始数据 m 访问 p2</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;p2&#x27;</span>).<span class="hljs-property">size</span>)<br>&#125;)<br><span class="hljs-comment">// 注意，这里我们通过原始数据 m 为 p2 设置一个键值对 foo --&gt; 1</span><br>m.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;p2&#x27;</span>).<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;foo&#x27;</span>, <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>在这段代码中，我们首先创建了一个原始 Map 对象 m，p1 是对象 m 的代理对象，接着创建另外一个代理对象 p2，并将其作为值设置给 p1，即 p1.set(‘p2’, p2)。</p><p>接下来问题出现了，在副作用函数中，我们通过原始数据 m 来读取数据值，然后又通过原始数据 m 设置数据值，此时发现副作用函数重新执行了。<strong>这其实不是我们所期望的行为，因为原始数据不应该具有响应式数据的能力，否则就意味着用户既可以操作原始数据，又能够操作响应式数据，这样一来代码就乱套了。</strong><br>那么，导致问题的原因是什么呢？其实很简单，观察我们前面实现的 set 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> mutableInstrumentations = &#123;<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">key, value</span>) &#123;<br>    <span class="hljs-keyword">const</span> target = <span class="hljs-variable language_">this</span>.<span class="hljs-property">raw</span><br>    <span class="hljs-keyword">const</span> had = target.<span class="hljs-title function_">has</span>(key)<br>    <span class="hljs-keyword">const</span> oldValue = target.<span class="hljs-title function_">get</span>(key)<br>    <span class="hljs-comment">// 我们把 value 原封不动地设置到原始数据上</span><br>    target.<span class="hljs-title function_">set</span>(key, value)<br>    <span class="hljs-keyword">if</span> (!had) &#123;<br>      <span class="hljs-title function_">trigger</span>(target, key, <span class="hljs-string">&#x27;ADD&#x27;</span>)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldValue !== value || (oldValue === oldValue &amp;&amp; value === value)) &#123;<br>      <span class="hljs-title function_">trigger</span>(target, key, <span class="hljs-string">&#x27;SET&#x27;</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 set 方法内，我们把 value 原样设置到了原始数据 target 上。如果 value 是响应式数据，就意味着设置到原始对象上的也是响应式数据，<br>我们把<strong>响应式数据设置到原始数据上的行为称为数据污染。</strong></p><p>要解决数据污染也不难，只需要在调用 target.set 函数设置值之前对值进行检查即可：只要发现即将要设置的值是响应式数据，那么就通过 raw 属性获取原始数据，再把原始数据设置到 target 上，如下面的代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs JS"><br><span class="hljs-keyword">const</span> mutableInstrumentations = &#123;<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">key, value</span>) &#123;<br>    <span class="hljs-keyword">const</span> target = <span class="hljs-variable language_">this</span>.<span class="hljs-property">raw</span><br>    <span class="hljs-keyword">const</span> had = target.<span class="hljs-title function_">has</span>(key)<br>    <span class="hljs-keyword">const</span> oldValue = target.<span class="hljs-title function_">get</span>(key)<br>    <span class="hljs-comment">// 获取原始数据，由于 value 本身可能已经是原始数据，所以此时value.raw 不存在，则直接使用 value</span><br>    <span class="hljs-keyword">const</span> rawValue = value.<span class="hljs-property">raw</span> || value<br>    target.<span class="hljs-title function_">set</span>(key, rawValue)<br>    <span class="hljs-keyword">if</span> (!had) &#123;<br>      <span class="hljs-title function_">trigger</span>(target, key, <span class="hljs-string">&#x27;ADD&#x27;</span>)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldValue !== value || (oldValue === oldValue &amp;&amp; value === value)) &#123;<br>      <span class="hljs-title function_">trigger</span>(target, key, <span class="hljs-string">&#x27;SET&#x27;</span>)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>本节中，我们通过 Map 类型数据的 set 方法讲解了关于避免污染原始数据的问题。其实除了 set 方法需要避免污染原始数据之外，Set 类型的 add 方法、普通对象的写值操作，还有为数组添加元素的方法等，都需要做类似的处理。</p><p><a href="https://code.juejin.cn/pen/7355044438622535680">△ 运行代码</a></p><h3 id="5-8-4-处理-forEach"><a href="#5-8-4-处理-forEach" class="headerlink" title="5.8.4 处理 forEach"></a>5.8.4 处理 forEach</h3><p>集合类型的 forEach 方法类似于数组的 forEach 方法，我们先来看看它是如何工作的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>  [&#123; <span class="hljs-attr">key</span>: <span class="hljs-number">1</span> &#125;, &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">1</span> &#125;]<br>])<br><br><span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  m.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">value, key, m</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value) <span class="hljs-comment">// &#123; value: 1 &#125;</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key) <span class="hljs-comment">// &#123; key: 1 &#125;</span><br>  &#125;)<br>&#125;)<br><br></code></pre></td></tr></table></figure><p>以 Map 为例，forEach 方法接收一个回调函数作为参数，该回调函数会在 Map 的每个键值对上被调用。回调函数接收三个参数，分别是值、键以及原始 Map 对象。如上面的代码所示，我们可以使用 forEach 方法遍历 Map 数据的每一组键值对。</p><p>遍历操作只与键值对的数量有关，因此任何会修改 Map 对象键值对数量的操作都应该触发副作用函数重新执行，例如 delete 和 add 方法等。所以当 forEach 函数被调用时，我们应该让副作用函数与 ITERATE_KEY 建立响应联系，如下面的代码所示:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> mutableInstrumentations = &#123;<br>  <span class="hljs-title function_">forEach</span>(<span class="hljs-params">callback</span>) &#123;<br>    <span class="hljs-comment">// 取得原始数据对象</span><br>    <span class="hljs-keyword">const</span> target = <span class="hljs-variable language_">this</span>.<span class="hljs-property">raw</span><br>    <span class="hljs-comment">// 与 ITERATE_KEY 建立响应联系</span><br>    <span class="hljs-title function_">track</span>(target, <span class="hljs-variable constant_">ITERATE_KEY</span>)<br>    <span class="hljs-comment">// 通过原始数据对象调用 forEach 方法，并把 callback 传递过去</span><br>    target.<span class="hljs-title function_">forEach</span>(callback)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样我们就实现了对 forEach 操作的追踪，可以使用下面的代码进行测试：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> p = <span class="hljs-title function_">reactive</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>  [&#123; <span class="hljs-attr">key</span>: <span class="hljs-number">1</span> &#125;, &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">1</span> &#125;]<br>]))<br><span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  p.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">value, key</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value) <span class="hljs-comment">// &#123; value: 1 &#125;</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key) <span class="hljs-comment">// &#123; key: 1 &#125;</span><br>  &#125;)<br>&#125;)<br><span class="hljs-comment">// 能够触发响应</span><br>p.<span class="hljs-title function_">set</span>(&#123; <span class="hljs-attr">key</span>: <span class="hljs-number">2</span> &#125;, &#123; <span class="hljs-attr">value</span>: <span class="hljs-number">2</span> &#125;)<br></code></pre></td></tr></table></figure><p>可以发现，这段代码能够按照预期工作。然而，上面给出的 forEach 函数仍然存在缺陷，我们在自定义实现的 forEach 方法<br>内，通过原始数据对象调用了原生的 forEach 方法，即：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">// 通过原始数据对象调用 forEach 方法，并把 callback 传递过去</span><br>target.<span class="hljs-title function_">forEach</span>(callback)<br></code></pre></td></tr></table></figure><p>这意味着，传递给 callback 回调函数的参数将是非响应式数据。这导致下面的代码不能按预期工作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> key = &#123; <span class="hljs-attr">key</span>: <span class="hljs-number">1</span> &#125;<br><span class="hljs-keyword">const</span> value = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><span class="hljs-keyword">const</span> p = <span class="hljs-title function_">reactive</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>  [key, value]<br>]))<br><span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  p.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">value, key</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value.<span class="hljs-property">size</span>) <span class="hljs-comment">// 3</span><br>  &#125;)<br>&#125;)<br><br>p.<span class="hljs-title function_">get</span>(key).<span class="hljs-title function_">delete</span>(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><p>在上面这段代码中，响应式数据 p 有一个键值对，其中键是普通对象 { key: 1 }，值是 Set 类型的原始数据 new Set([1, 2, 3])。接着，我们在副作用函数中使用 forEach 方法遍历 p，并在回调函数中访问 value.size。最后，我们尝试删除 Set 类型数据中值为 1 的元素，却发现没能触发副作用函数重新执行。<br>导致问题的原因就是上面曾提到的，当通过 value.size 访问 size 属性时，这里的 value 是原始数据对象，即 new Set([1, 2, 3])，而非响应式数据对象，因此无法建立响应联系。但这其实不符合直觉，因为 reactive 本身是深响应，forEach 方法的回调函数所接收到的参数也应该是响应式数据才对。为了解决这个问题，我们需要对现有实现做一些修改，如下面的代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> mutableInstrumentations = &#123;<br><span class="hljs-title function_">forEach</span>(<span class="hljs-params">callback</span>) &#123;<br>  <span class="hljs-comment">// wrap 函数用来把可代理的值转换为响应式数据</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">wrap</span> = (<span class="hljs-params">val</span>) =&gt; <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&#x27;object&#x27;</span> ? <span class="hljs-title function_">reactive</span>(val) : val<br>  <span class="hljs-keyword">const</span> target = <span class="hljs-variable language_">this</span>.<span class="hljs-property">raw</span><br>  <span class="hljs-title function_">track</span>(target, <span class="hljs-variable constant_">ITERATE_KEY</span>)<br>  <span class="hljs-comment">// 通过 target 调用原始 forEach 方法进行遍历</span><br>  target.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">v, k</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 手动调用 callback，用 wrap 函数包裹 value 和 key 后再传给callback，这样就实现了深响应</span><br>    <span class="hljs-title function_">callback</span>(<span class="hljs-title function_">wrap</span>(v), <span class="hljs-title function_">wrap</span>(k), <span class="hljs-variable language_">this</span>)<br>  &#125;)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实思路很简单，既然 callback 函数的参数不是响应式的，那就将它转换成响应式的。所以在上面的代码中，我们又对 callback 函数的参数做了一层包装，即把传递给 callback 函数的参数包装成响应式的。此时，如果再次尝试运行前文给出的例子，会发现它能够按预期工作了。</p><p>最后，出于严谨性，我们还需要做一些补充。因为 forEach 函数除了接收 callback 作为参数之外，它还接收第二个参数，该参数可以用来指定 callback 函数执行时的 this 值。更加完善的实现如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> mutableInstrumentations = &#123;<br>  <span class="hljs-comment">// 接收第二个参数</span><br>  <span class="hljs-title function_">forEach</span>(<span class="hljs-params">callback, thisArg</span>) &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">wrap</span> = (<span class="hljs-params">val</span>) =&gt; <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&#x27;object&#x27;</span> ? <span class="hljs-title function_">reactive</span>(val) : val<br>    <span class="hljs-keyword">const</span> target = <span class="hljs-variable language_">this</span>.<span class="hljs-property">raw</span><br>    <span class="hljs-title function_">track</span>(target, <span class="hljs-variable constant_">ITERATE_KEY</span>)<br>    <span class="hljs-comment">// 通过 target 调用原始 forEach 方法进行遍历</span><br>    <span class="hljs-comment">// target.forEach(callback)</span><br>    target.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">v, k</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">// 通过 .call 调用 callback，并传递 thisArg</span><br>      <span class="hljs-comment">// 手动调用 callback，用 wrap 函数包裹 value 和 key 后再传给callback，这样就实现了深响应</span><br>      callback.<span class="hljs-title function_">call</span>(thisArg, <span class="hljs-title function_">wrap</span>(v), <span class="hljs-title function_">wrap</span>(k), <span class="hljs-variable language_">this</span>)<br>    &#125;)<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，我们的工作仍然没有完成。现在我们知道，无论是使用 for…in 循环遍历一个对象，还是使用 forEach 循环遍历一个集<br>合，它们的响应联系都是建立在 ITERATE_KEY 与副作用函数之间的。<br>然而，使用 for…in 来遍历对象与使用 forEach 遍历集合之间存在本质的不同。具体体现在，当使用 for…in 循环遍历对象时，它只关心对象的键，而不关心对象的值，如以下代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> obj) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key)<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>只有当新增、删除对象的 key 时，才需要重新执行副作用函数。所以我们在 trigger 函数内判断操作类型是否是 ADD 或 DELETE，进而知道是否需要触发那些与 ITERATE_KEY 相关联的副作用函数重新执行。对于 SET 类型的操作来说，因为它不会改变一个对象的键的数量，所以当 SET 类型的操作发生时，不需要触发副作用函数重新执行。<br><strong>但这个规则不适用于 Map 类型的 forEach 遍历，</strong>如以下代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> p = <span class="hljs-title function_">reactive</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>  [<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-number">1</span>]<br>]))<br><span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  p.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">value, key</span>) &#123;<br>    <span class="hljs-comment">// forEach 循环不仅关心集合的键，还关心集合的值</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value) <span class="hljs-comment">// 1</span><br>  &#125;)<br>&#125;)<br>p.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 即使操作类型是 SET，也应该触发响应</span><br></code></pre></td></tr></table></figure><p>当使用 forEach 遍历 Map 类型的数据时，它既关心键，又关心值。这意味着，当调用 p.set(‘key’, 2) 修改值的时候，也应该触发副作用函数重新执行，即使它的操作类型是 SET。因此，我们应该修改 trigger 函数的代码来弥补这个缺陷：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs JS"><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">trigger</span>(<span class="hljs-params">target, key, type, newVal</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;trigger&#x27;</span>, key)<br>  <span class="hljs-keyword">const</span> depsMap = bucket.<span class="hljs-title function_">get</span>(target)<br>  <span class="hljs-keyword">if</span> (!depsMap) <span class="hljs-keyword">return</span><br>  <span class="hljs-keyword">const</span> effects = depsMap.<span class="hljs-title function_">get</span>(key)<br>  <span class="hljs-keyword">const</span> effectsToRun = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()<br>  effects &amp;&amp; effects.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">effectFn</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (effectFn !== activeEffect) &#123;<br>      effectsToRun.<span class="hljs-title function_">add</span>(effectFn)<br>    &#125;<br>  &#125;)<br>  <span class="hljs-keyword">if</span> (<br>    type === <span class="hljs-string">&#x27;ADD&#x27;</span> ||<br>    type === <span class="hljs-string">&#x27;DELETE&#x27;</span> ||<br>    <span class="hljs-comment">// 如果操作类型是 SET，并且目标对象是 Map 类型的数据，</span><br>    <span class="hljs-comment">// 也应该触发那些与 ITERATE_KEY 相关联的副作用函数重新执行</span><br>    (<br>      type === <span class="hljs-string">&#x27;SET&#x27;</span> &amp;&amp;<br>      <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(target) === <span class="hljs-string">&#x27;[object Map]&#x27;</span><br>    )<br>  ) &#123;<br>    <span class="hljs-keyword">const</span> iterateEffects = depsMap.<span class="hljs-title function_">get</span>(<span class="hljs-variable constant_">ITERATE_KEY</span>)<br>    iterateEffects &amp;&amp; iterateEffects.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">effectFn</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (effectFn !== activeEffect) &#123;<br>        effectsToRun.<span class="hljs-title function_">add</span>(effectFn)<br>      &#125;<br>    &#125;)<br>  &#125;<br>  <span class="hljs-comment">// 省略部分内容</span><br>  effectsToRun.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">effectFn</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (effectFn.<span class="hljs-property">options</span>.<span class="hljs-property">scheduler</span>) &#123;<br>      effectFn.<span class="hljs-property">options</span>.<span class="hljs-title function_">scheduler</span>(effectFn)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-title function_">effectFn</span>()<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>如上面的代码所示，我们增加了一个判断条件：如果操作的目标对象是 Map 类型的，则 SET 类型的操作也应该触发那些与 ITERATE_KEY 相关联的副作用函数重新执行。</p><p><a href="https://code.juejin.cn/pen/7355053360237838362">△ 运行代码</a></p><h3 id="5-8-5-迭代器方法"><a href="#5-8-5-迭代器方法" class="headerlink" title="5.8.5 迭代器方法"></a>5.8.5 迭代器方法</h3><blockquote><p>接下来，我们讨论关于集合类型的迭代器方法，实际上前面讲解如何拦截 for…of 循环遍历数组的时候介绍过迭代器的相关知识。集合类型有三个迭代器方法：</p></blockquote><ul><li>entries</li><li>keys</li><li>values<br>调用这些方法会得到相应的迭代器，并且可以使用 for…of 进行循环迭代，例如：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> m = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>  [<span class="hljs-string">&#x27;key1&#x27;</span>, <span class="hljs-string">&#x27;value1&#x27;</span>],<br>  [<span class="hljs-string">&#x27;key2&#x27;</span>, <span class="hljs-string">&#x27;value2&#x27;</span>]<br>])<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> m.<span class="hljs-title function_">entries</span>()) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key, value)<br>&#125;<br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// key1 value1</span><br><span class="hljs-comment">// key2 value2</span><br></code></pre></td></tr></table></figure><p>另外，由于 Map 或 Set 类型本身部署了 Symbol.iterator 方法，因此它们可以使用 for…of 进行迭代：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> m &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key, value)<br>&#125;<br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// key1 value1</span><br><span class="hljs-comment">// key2 value2</span><br></code></pre></td></tr></table></figure><p>当然，我们也可以调用迭代器函数取得迭代器对象后，手动调用迭代器对象的 next 方法获取对应的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> itr = m[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(itr.<span class="hljs-title function_">next</span>()) <span class="hljs-comment">// &#123; value: [&#x27;key1&#x27;, &#x27;value1&#x27;], done: false &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(itr.<span class="hljs-title function_">next</span>()) <span class="hljs-comment">// &#123; value: [&#x27;key2&#x27;, &#x27;value2&#x27;], done: false &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(itr.<span class="hljs-title function_">next</span>()) <span class="hljs-comment">// &#123; value: undefined, done: true &#125;</span><br></code></pre></td></tr></table></figure><p>实际上，m[Symbol.iterator] 与 m.entries 是等价的:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(m[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>] === m.<span class="hljs-property">entries</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>这就是为什么上例中使用 for…of 循环迭代 m.entries 和 m 会得到同样的结果。<br>理解了这些内容后，我们就可以尝试实现对迭代器方法的代理了。不过在这之前，不妨做一些尝试，看看会发生什么，如以下代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> p = <span class="hljs-title function_">reactive</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>  [<span class="hljs-string">&#x27;key1&#x27;</span>, <span class="hljs-string">&#x27;value1&#x27;</span>],<br>  [<span class="hljs-string">&#x27;key2&#x27;</span>, <span class="hljs-string">&#x27;value2&#x27;</span>]<br>]))<br><br><span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// TypeError: p is not iterable</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> p) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key, value)<br>  &#125;<br>&#125;)<br>p.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;key3&#x27;</span>, <span class="hljs-string">&#x27;value3&#x27;</span>)<br></code></pre></td></tr></table></figure><p>在这段代码中，我们首先创建一个代理对象 p，接着尝试使用 for…of 循环遍历它，却得到了一个错误：“p 是不可迭代的”。<br>我们知道一个对象能否迭代，取决于该对象是否实现了迭代协议，如果一个对象正确地实现了 Symbol.iterator 方法，那么它就是可迭代的。<br>很显然，代理对象 p 没有实现 Symbol.iterator 方法，因此我们得到了上面的错误。<br>但实际上，当我们使用 for…of 循环迭代一个代理对象时，内部会试图从代理对象 p 上读取 p[Symbol.iterator] 属性，这个操作会触发 get 拦截函数，所以我们仍然可以把 Symbol.iterator 方法的实现放到 mutableInstrumentations 中，如以下代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> mutableInstrumentations = &#123;<br>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;<br>    <span class="hljs-comment">// 获取原始数据对象 target</span><br>    <span class="hljs-keyword">const</span> target = <span class="hljs-variable language_">this</span>.<span class="hljs-property">raw</span><br>    <span class="hljs-comment">// 获取原始迭代器方法</span><br>    <span class="hljs-keyword">const</span> itr = target[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]()<br>    <span class="hljs-comment">// 将其返回</span><br>    <span class="hljs-keyword">return</span> itr<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现很简单，不过是把原始的迭代器对象返回而已，这样就能够使用 for…of 循环迭代代理对象 p 了，然而事情不可能这么简单。在 5.8.4 节中讲解 forEach 方法时我们提到过，传递给 callback 的参数是包装后的响应式数据，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JS">p.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">value, key</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// value 和 key 如果可以被代理，那么它们就是代理对象，即响应式数据</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>同理，使用 for…of 循环迭代集合时，如果迭代产生的值也是可以被代理的，那么也应该将其包装成响应式数据，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> p) &#123;<br>  <span class="hljs-comment">// 期望 key 和 value 是响应式数据</span><br>&#125;<br></code></pre></td></tr></table></figure><p>因此，我们需要修改代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> mutableInstrumentations = &#123;<br>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;<br>    <span class="hljs-comment">// 获取原始数据对象 target</span><br>    <span class="hljs-keyword">const</span> target = <span class="hljs-variable language_">this</span>.<span class="hljs-property">raw</span><br>    <span class="hljs-comment">// 获取原始迭代器方法</span><br>    <span class="hljs-keyword">const</span> itr = target[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]()<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">wrap</span> = (<span class="hljs-params">val</span>) =&gt; <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; val !== <span class="hljs-literal">null</span> ? <span class="hljs-title function_">reactive</span>(val) : val<br>    <span class="hljs-comment">// 返回自定义的迭代器</span><br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 调用原始迭代器的 next 方法获取 value 和 done</span><br>        <span class="hljs-keyword">const</span> &#123; value, done &#125; = itr.<span class="hljs-title function_">next</span>()<br>        <span class="hljs-keyword">return</span> &#123;<br>          <span class="hljs-comment">// 如果 value 不是 undefined，则对其进行包裹</span><br>          <span class="hljs-attr">value</span>: value ? [<span class="hljs-title function_">wrap</span>(value[<span class="hljs-number">0</span>]), <span class="hljs-title function_">wrap</span>(value[<span class="hljs-number">1</span>])] : value,<br>          done<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如以上代码所示，为了实现对 key 和 value 的包装，我们需要自定义实现的迭代器，在其中调用原始迭代器获取值 value 以及代表是否结束的 done。如果值 value 不为 undefined，则对其进行包装，最后返回包装后的代理对象，这样当使用 for…of 循环进行迭代时，得到的值就会是响应式数据了。<br>最后，为了追踪 for…of 对数据的迭代操作，我们还需要调用 track 函数，让副作用函数与 ITERATE_KEY 建立联系：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs JS"><br><span class="hljs-keyword">const</span> mutableInstrumentations = &#123;<br>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;<br>    <span class="hljs-keyword">const</span> target = <span class="hljs-variable language_">this</span>.<span class="hljs-property">raw</span><br>    <span class="hljs-keyword">const</span> itr = target[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]()<br>    <span class="hljs-keyword">const</span> <span class="hljs-title function_">wrap</span> = (<span class="hljs-params">val</span>) =&gt; <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; val !== <span class="hljs-literal">null</span> ? <span class="hljs-title function_">reactive</span>(val) : val<br>    <span class="hljs-comment">// 调用 track 函数建立响应联系</span><br>    <span class="hljs-title function_">track</span>(target, <span class="hljs-variable constant_">ITERATE_KEY</span>)<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">const</span> &#123; value, done &#125; = itr.<span class="hljs-title function_">next</span>()<br>        <span class="hljs-keyword">return</span> &#123;<br>          <span class="hljs-attr">value</span>: value ? [<span class="hljs-title function_">wrap</span>(value[<span class="hljs-number">0</span>]), <span class="hljs-title function_">wrap</span>(value[<span class="hljs-number">1</span>])] : value,<br>          done<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于迭代操作与集合中元素的数量有关，所以只要集合的 size 发生变化，就应该触发迭代操作重新执行。因此，我们在调用 track 函数时让 ITERATE_KEY 与副作用函数建立联系。完成这一步后，集合的响应式数据功能就相对完整了，我们可以通过如下代码测试一下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> p = <span class="hljs-title function_">reactive</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>  [<span class="hljs-string">&#x27;key1&#x27;</span>, <span class="hljs-string">&#x27;value1&#x27;</span>],<br>  [<span class="hljs-string">&#x27;key2&#x27;</span>, <span class="hljs-string">&#x27;value2&#x27;</span>]<br>]))<br><span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> p) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key, value)<br>  &#125;<br>&#125;)<br>p.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;key3&#x27;</span>, <span class="hljs-string">&#x27;value3&#x27;</span>) <span class="hljs-comment">// 能够触发响应</span><br></code></pre></td></tr></table></figure><p>前面我们说过，由于 p.entries 与 p[Symbol.iterator] 等价，所以我们可以使用同样的代码来实现对 p.entries 函数的拦截，如以下代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> mutableInstrumentations = &#123;<br>  <span class="hljs-comment">// 共用 iterationMethod 方法</span><br>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]: iterationMethod,<br>  <span class="hljs-attr">entries</span>: iterationMethod<br>&#125;<br><span class="hljs-comment">// 抽离为独立的函数，便于复用</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">iterationMethod</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> target = <span class="hljs-variable language_">this</span>.<span class="hljs-property">raw</span><br>  <span class="hljs-keyword">const</span> itr = target[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]()<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">wrap</span> = (<span class="hljs-params">val</span>) =&gt; <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&#x27;object&#x27;</span> ? <span class="hljs-title function_">reactive</span>(val) : val<br>  <span class="hljs-title function_">track</span>(target, <span class="hljs-variable constant_">ITERATE_KEY</span>)<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">const</span> &#123; value, done &#125; = itr.<span class="hljs-title function_">next</span>()<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">value</span>: value ? [<span class="hljs-title function_">wrap</span>(value[<span class="hljs-number">0</span>]), <span class="hljs-title function_">wrap</span>(value[<span class="hljs-number">1</span>])] : value,<br>        done<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但当你尝试运行代码使用 for…of 进行迭代时，会得到一个错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">// TypeError: p.entries is not a function or its return value is not iterable</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> [key, value] <span class="hljs-keyword">of</span> p.<span class="hljs-title function_">entries</span>()) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(key, value)<br>&#125;<br></code></pre></td></tr></table></figure><p>错误的大意是 p.entries 的返回值不是一个可迭代对象。很显然，p.entries 函数的返回值是一个对象，该对象带有 next 方法，但不具有 Symbol.iterator 方法，因此它确实不是一个可迭代对象。这里是经常出错的地方，大家切勿把可迭代协议与迭代器协议搞混。<strong>可迭代协议指的是一个对象实现了 Symbol.iterator 方法，而迭代器协议指的是一个对象实现了 next 方法。</strong>,但一个对象可以同时实现可迭代协议和迭代器协议，例如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-comment">// 迭代器协议</span><br>  <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// ...</span><br>  &#125;,<br>  <span class="hljs-comment">// 可迭代协议</span><br>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以解决问题的方法也自然而然地出现了:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-comment">// 抽离为独立的函数，便于复用</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">iterationMethod</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> target = <span class="hljs-variable language_">this</span>.<span class="hljs-property">raw</span><br>  <span class="hljs-keyword">const</span> itr = target[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]()<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">wrap</span> = (<span class="hljs-params">val</span>) =&gt; <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&#x27;object&#x27;</span> ? <span class="hljs-title function_">reactive</span>(val) : val<br>  <span class="hljs-title function_">track</span>(target, <span class="hljs-variable constant_">ITERATE_KEY</span>)<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">const</span> &#123; value, done &#125; = itr.<span class="hljs-title function_">next</span>()<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">value</span>: value ? [<span class="hljs-title function_">wrap</span>(value[<span class="hljs-number">0</span>]), <span class="hljs-title function_">wrap</span>(value[<span class="hljs-number">1</span>])] : value,<br>        done<br>      &#125;<br>    &#125;,<br>    <span class="hljs-comment">// 实现可迭代协议</span><br>    [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>现在一切都能正常工作了。</p><p><a href="https://code.juejin.cn/pen/7359486030753316891">△ 运行代码</a></p><h3 id="5-8-6-values-与-keys-方法"><a href="#5-8-6-values-与-keys-方法" class="headerlink" title="5.8.6 values 与 keys 方法"></a>5.8.6 values 与 keys 方法</h3><blockquote><p>values 方法的实现与 entries 方法类似，不同的是，当使用for…of 迭代 values 时，得到的仅仅是 Map 数据的值，而非键值对：</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> p.<span class="hljs-title function_">values</span>()) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)<br>&#125;<br></code></pre></td></tr></table></figure><p>values 方法的实现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> mutableInstrumentations = &#123;<br>  <span class="hljs-comment">// 共用 iterationMethod 方法</span><br>  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]: iterationMethod,<br>  <span class="hljs-attr">entries</span>: iterationMethod,<br>  <span class="hljs-attr">values</span>: valuesIterationMethod<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">valuesIterationMethod</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 获取原始数据对象 target</span><br>  <span class="hljs-keyword">const</span> target = <span class="hljs-variable language_">this</span>.<span class="hljs-property">raw</span><br>  <span class="hljs-comment">// 通过 target.values 获取原始迭代器方法</span><br>  <span class="hljs-keyword">const</span> itr = target.<span class="hljs-title function_">values</span>()<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">wrap</span> = (<span class="hljs-params">val</span>) =&gt; <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&#x27;object&#x27;</span> ? <span class="hljs-title function_">reactive</span>(val) : val<br><br>  <span class="hljs-title function_">track</span>(target, <span class="hljs-variable constant_">ITERATE_KEY</span>)<br><br>  <span class="hljs-comment">// 将其返回</span><br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">const</span> &#123; value, done &#125; = itr.<span class="hljs-title function_">next</span>()<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-comment">// value 是值，而非键值对，所以只需要包裹 value 即可</span><br>        <span class="hljs-attr">value</span>: <span class="hljs-title function_">wrap</span>(value),<br>        done<br>      &#125;<br>    &#125;,<br>    [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中，valuesIterationMethod 与 iterationMethod 这两个方法有两点区别：</p><ul><li>iterationMethod 通过 target[Symbol.iterator] 获取迭代器对象，而 valuesIterationMethod 通过target.values 获取迭代器对象；</li><li>iterationMethod 处理的是键值对，即 [wrap(value[0]),wrap(value[1])]，而 valuesIterationMethod 只处理值，即 wrap(value)。</li></ul><p>由于它们的大部分逻辑相同，所以我们可以将它们封装到一个可复用的函数中。但为了便于理解，这里仍然将它们设计为两个独立的函数来实现。<br>keys 方法与 values 方法非常类似，不同点在于，前者处理的是键而非值。因此，我们只需要修改 valuesIterationMethod 方法中的一行代码，即可实现对 keys 方法的代理。代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> itr = target.<span class="hljs-title function_">values</span>()<br><span class="hljs-comment">// 替换成</span><br> <span class="hljs-keyword">const</span> itr = target.<span class="hljs-title function_">keys</span>()<br></code></pre></td></tr></table></figure><p>这么做的确能够达到目的，但如果我们尝试运行如下测试用例，就会发现存在缺陷：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> p = <span class="hljs-title function_">reactive</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>  [<span class="hljs-string">&#x27;key1&#x27;</span>, <span class="hljs-string">&#x27;value1&#x27;</span>],<br>  [<span class="hljs-string">&#x27;key2&#x27;</span>, <span class="hljs-string">&#x27;value2&#x27;</span>]<br>]))<br><br><span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> p.<span class="hljs-title function_">keys</span>()) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value) <span class="hljs-comment">// key1 key2</span><br>  &#125;<br>&#125;)<br>p.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;key2&#x27;</span>, <span class="hljs-string">&#x27;value3&#x27;</span>) <span class="hljs-comment">// 这是一个 SET 类型的操作，它修改了 key2 的值</span><br></code></pre></td></tr></table></figure><p>在上面这段代码中，我们使用 for…of 循环来遍历 p.keys，然后调用 p.set(‘key2’, ‘value3’) 修改键为 key2 的值。在这个过程中，Map 类型数据的所有键都没有发生变化，仍然是 key1 和key2，所以在理想情况下，副作用函数不应该执行。但如果你尝试运行上例，会发现副作用函数仍然重新执行了。<br>这是因为，我们对 Map 类型的数据进行了特殊处理。前文提到，即使操作类型为 SET，也会触发那些与 ITERATE_KEY 相关联的副作用函数重新执行，trigger 函数的代码可以证明这一点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">trigger</span>(<span class="hljs-params">target, key, type, newVal</span>) &#123;<br>  <span class="hljs-comment">// 省略其他代码</span><br>  <span class="hljs-keyword">if</span> (<br>    type === <span class="hljs-string">&#x27;ADD&#x27;</span> ||<br>    type === <span class="hljs-string">&#x27;DELETE&#x27;</span> ||<br>    <span class="hljs-comment">// 即使是 SET 类型的操作，也会触发那些与 ITERATE_KEY 相关联的副作用函数重新执行</span><br>    (<br>      type === <span class="hljs-string">&#x27;SET&#x27;</span> &amp;&amp;<br>      <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(target) === <span class="hljs-string">&#x27;[object Map]&#x27;</span><br>    )<br>  ) &#123;<br>    <span class="hljs-keyword">const</span> iterateEffects = depsMap.<span class="hljs-title function_">get</span>(<span class="hljs-variable constant_">ITERATE_KEY</span>)<br>    iterateEffects &amp;&amp; iterateEffects.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">effectFn</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (effectFn !== activeEffect) &#123;<br>        effectsToRun.<span class="hljs-title function_">add</span>(effectFn)<br>      &#125;<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-comment">// 省略其他代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这对于 values 或 entries 等方法来说是必需的，但对于 keys方法来说则没有必要，因为 keys 方法只关心 Map 类型数据的键的变化，而不关心值的变化。<br>解决办法很简单，如以下代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">MAP_KEY_ITERATE_KEY</span> = <span class="hljs-title class_">Symbol</span>()<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">keysIterationMethod</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 获取原始数据对象 target</span><br>  <span class="hljs-keyword">const</span> target = <span class="hljs-variable language_">this</span>.<span class="hljs-property">raw</span><br>  <span class="hljs-comment">// 获取原始迭代器方法</span><br>  <span class="hljs-keyword">const</span> itr = target.<span class="hljs-title function_">keys</span>()<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">wrap</span> = (<span class="hljs-params">val</span>) =&gt; <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&#x27;object&#x27;</span> ? <span class="hljs-title function_">reactive</span>(val) : val<br><br>  <span class="hljs-comment">// 调用 track 函数追踪依赖，在副作用函数与 MAP_KEY_ITERATE_KEY 之间建立响应联系</span><br>  <span class="hljs-title function_">track</span>(target, <span class="hljs-variable constant_">MAP_KEY_ITERATE_KEY</span>)<br><br>  <span class="hljs-comment">// 将其返回</span><br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">const</span> &#123; value, done &#125; = itr.<span class="hljs-title function_">next</span>()<br>      <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">value</span>: <span class="hljs-title function_">wrap</span>(value),<br>        done<br>      &#125;<br>    &#125;,<br>    [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面这段代码中，当调用 track 函数追踪依赖时，我们使用MAP_KEY_ITERATE_KEY 代替了 ITERATE_KEY。其中MAP_KEY_ITERATE_KEY 与 ITERATE_KEY 类似，是一个新的Symbol 类型，用来作为抽象的键。这样就实现了<strong>依赖收集的分离，即values 和 entries 等方法仍然依赖 ITERATE_KEY，而 keys 方法则依赖 MAP_KEY_ITERATE_KEY。</strong> 当 SET 类型的操作只会触发与ITERATE_KEY 相关联的副作用函数重新执行时，自然就会忽略那些与MAP_KEY_ITERATE_KEY 相关联的副作用函数。但当 ADD 和 DELETE类型的操作发生时，除了触发与 ITERATE_KEY 相关联的副作用函数重新执行之外，还需要触发与MAP_KEY_ITERATE_KEY 相关联的副作用函数重新执行，因此我们需要修改 trigger 函数的代码，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">function</span> <span class="hljs-title function_">trigger</span>(<span class="hljs-params">target, key, type, newVal</span>) &#123;<br>  <span class="hljs-comment">// 省略其他代码</span><br>  <span class="hljs-keyword">if</span> (<br>    <span class="hljs-comment">// 操作类型为 ADD 或 DELETE</span><br>    (type === <span class="hljs-string">&#x27;ADD&#x27;</span> || type === <span class="hljs-string">&#x27;DELETE&#x27;</span>) &amp;&amp;<br>    <span class="hljs-comment">// 并且是 Map 类型的数据</span><br>    <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(target) === <span class="hljs-string">&#x27;[object Map]&#x27;</span><br>  ) &#123;<br>    <span class="hljs-comment">// 则取出那些与 MAP_KEY_ITERATE_KEY 相关联的副作用函数并执行</span><br>    <span class="hljs-keyword">const</span> iterateEffects = depsMap.<span class="hljs-title function_">get</span>(<span class="hljs-variable constant_">MAP_KEY_ITERATE_KEY</span>)<br>    iterateEffects &amp;&amp; iterateEffects.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">effectFn</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (effectFn !== activeEffect) &#123;<br>        effectsToRun.<span class="hljs-title function_">add</span>(effectFn)<br>      &#125;<br>    &#125;)<br>  &#125;<br>  <span class="hljs-comment">// 省略其他代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这样，就能够避免不必要的更新了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">const</span> p = <span class="hljs-title function_">reactive</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([<br>  [<span class="hljs-string">&#x27;key1&#x27;</span>, <span class="hljs-string">&#x27;value1&#x27;</span>],<br>  [<span class="hljs-string">&#x27;key2&#x27;</span>, <span class="hljs-string">&#x27;value2&#x27;</span>]<br>]))<br><span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> value <span class="hljs-keyword">of</span> p.<span class="hljs-title function_">keys</span>()) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value)<br>  &#125;<br>&#125;)<br>p.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;key2&#x27;</span>, <span class="hljs-string">&#x27;value3&#x27;</span>) <span class="hljs-comment">// 不会触发响应</span><br>p.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;key3&#x27;</span>, <span class="hljs-string">&#x27;value3&#x27;</span>) <span class="hljs-comment">// 能够触发响应</span><br></code></pre></td></tr></table></figure><p><a href="https://code.juejin.cn/pen/7359512537764724788">△ 运行代码</a></p>]]></content>
    
    
    <categories>
      
      <category>Vue.js 设计与实现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书分享</tag>
      
      <tag>vue原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Vue.js 设计与实现》第四章 响应系统的作用与实现</title>
    <link href="/2024/03/13/vue/vue4/"/>
    <url>/2024/03/13/vue/vue4/</url>
    
    <content type="html"><![CDATA[<h1 id="第四章-响应系统的作用与实现"><a href="#第四章-响应系统的作用与实现" class="headerlink" title="第四章 响应系统的作用与实现"></a>第四章 响应系统的作用与实现</h1><p><img src="/../../img/vue/vue4/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F.png"></p><h2 id="本章内容"><a href="#本章内容" class="headerlink" title="本章内容"></a>本章内容</h2><ul><li>响应式数据与副作用函数</li><li>响应式数据的基本实现</li><li>设计一个完善的响应系统</li><li>分支切换与 cleanup</li><li>嵌套的 effect 与 effect 栈</li><li>避免无限递归循环</li><li>调度执行</li><li>计算属性 computed 与 lazy</li><li>watch 的实现原理</li><li>立即执行的 watch 与回调执行时机</li><li>过期的副作用</li></ul><h2 id="4-1-响应式数据与副作用函数"><a href="#4-1-响应式数据与副作用函数" class="headerlink" title="4.1 响应式数据与副作用函数"></a>4.1 响应式数据与副作用函数</h2><h3 id="4-1-1-回顾下副作用函数"><a href="#4-1-1-回顾下副作用函数" class="headerlink" title="4.1.1 回顾下副作用函数"></a>4.1.1 回顾下副作用函数</h3><p>副作用函数指的是会产生副作用的函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">effect</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">innerText</span> = <span class="hljs-string">&quot;hello vue3&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当 effect 函数执行时，它会设置 body 的文本内容，但除了 effect 函数之外的任何函数都可以读取或设置 body 的文本内容。也就是说，effect 函数的执行会直接或间接影响其他函数的执行，这时我们说 effect 函数产生了副作用。</p><p>副作用很容易产生，例如一个函数修改了全局变量，这其实也是一个副作用，如下面的代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 全局变量</span><br><span class="hljs-keyword">let</span> val = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">effect</span>(<span class="hljs-params"></span>) &#123;<br>  val = <span class="hljs-number">2</span>; <span class="hljs-comment">// 修改全局变量，产生副作用</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-1-2-什么是响应式数据"><a href="#4-1-2-什么是响应式数据" class="headerlink" title="4.1.2 什么是响应式数据?"></a>4.1.2 什么是响应式数据?</h3><p>假设在一个副作用函数中读取了某个对象的属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;hello world&quot;</span> &#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">effect</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// effect 函数的执行会读取 obj.text</span><br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">innerText</span> = obj.<span class="hljs-property">text</span>;<br>&#125;<br><br>obj.<span class="hljs-property">text</span> = <span class="hljs-string">&quot;hello vue3&quot;</span>; <span class="hljs-comment">// 修改 obj.text 的值，同时希望副作用函数会重新执行</span><br></code></pre></td></tr></table></figure><p>如上面的代码所示，副作用函数 effect 会设置 body 元素的 innerText 属性，其值为 obj.text，当 obj.text 的值发生变化时，我们希望副作用函数 effect 会重新执行,如果能实现这个目标，那么对象 obj 就是响应式数据</p><h2 id="4-2-响应式数据的基本实现"><a href="#4-2-响应式数据的基本实现" class="headerlink" title="4.2 响应式数据的基本实现"></a>4.2 响应式数据的基本实现</h2><p>如何才能让 obj 变成响应式数据呢？通过观察我们能发现两点线索:</p><ul><li>当副作用函数 effect 执行时，会触发字段 obj.text 的读取操作；</li><li>当修改 obj.text 的值时，会触发字段 obj.text 的设置操作</li></ul><p>如果我们能拦截一个对象的读取和设置操作</p><p>当读取字段 obj.text 时，我们可以把副作用函数 effect 存储到一个“桶”里，如图：<br><img src="/../../img/vue/vue4/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B01.jpg" alt="响应数据基本实现1"></p><p>当设置 obj.text 时，再把副作用函数 effect 从“桶”里取出并执行即可，如图：</p><p><img src="/../../img/vue/vue4/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B02.jpg" alt="响应数据基本实现2"></p><p>现在问题的关键变成了我们如何才能拦截一个对象属性的读取和设置操作。在 ES2015 之前，只能通过 Object.defineProperty 函数实现，这也是 Vue.js 2 所采用的方式。在 ES2015+ 中，我们可以使用代理对象 Proxy 来实现，这也是 Vue.js 3 所采用的方式</p><p>顺着这个思路，我们简单实现下 <a href="https://code.juejin.cn/pen/7346110581688303667">△ 运行代码</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 存储副作用函数的桶</span><br><span class="hljs-keyword">const</span> bucket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><span class="hljs-comment">// 原始数据</span><br><span class="hljs-keyword">const</span> data = &#123; <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;hello world&quot;</span> &#125;;<br><span class="hljs-comment">// 对原始数据的代理</span><br><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(data, &#123;<br>  <span class="hljs-comment">// 拦截读取操作</span><br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key</span>) &#123;<br>    <span class="hljs-comment">// 将副作用函数 effect 添加到存储副作用函数的桶中</span><br>    bucket.<span class="hljs-title function_">add</span>(effect);<br>    <span class="hljs-comment">// 返回属性值</span><br>    <span class="hljs-keyword">return</span> target[key];<br>  &#125;,<br>  <span class="hljs-comment">// 拦截设置操作</span><br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, newVal</span>) &#123;<br>    <span class="hljs-comment">// 设置属性值</span><br>    target[key] = newVal;<br>    <span class="hljs-comment">// 把副作用函数从桶里取出并执行</span><br>    bucket.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>());<br>    <span class="hljs-comment">// 返回 true 代表设置操作成功</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;,<br>&#125;);<br><br><span class="hljs-comment">// 副作用函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">effect</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">innerText</span> = obj.<span class="hljs-property">text</span>;<br>&#125;<br><span class="hljs-comment">// 执行副作用函数，触发读取</span><br><span class="hljs-title function_">effect</span>();<br><br><span class="hljs-comment">// 1 秒后修改响应式数据</span><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  obj.<span class="hljs-property">text</span> = <span class="hljs-string">&quot;hello vue3&quot;</span>;<br>&#125;, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><p>至此，我们已经实现了一个微型响应系统</p><h2 id="4-3-设计一个完善的响应系统"><a href="#4-3-设计一个完善的响应系统" class="headerlink" title="4.3 设计一个完善的响应系统"></a>4.3 设计一个完善的响应系统</h2><p>从上一节的例子中不难看出，一个响应系统的工作流程如下：</p><ul><li>当读取操作发生时，将副作用函数收集到“桶”中；</li><li>当设置操作发生时，从“桶”中取出副作用函数并执行</li></ul><h3 id="4-3-1-解决硬编码，实现匿名的副作用函数"><a href="#4-3-1-解决硬编码，实现匿名的副作用函数" class="headerlink" title="4.3.1 解决硬编码，实现匿名的副作用函数"></a>4.3.1 解决硬编码，实现匿名的副作用函数</h3><p>我们硬编码了副作用函数的名字（effect），导致一旦副作用函数的名字不叫 effect，那么这段代码就不能正确地工作了。</p><p>实现匿名的副作用函数</p><p><a href="https://code.juejin.cn/pen/7346119797316419636">△ 运行代码</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 用一个全局变量存储被注册的副作用函数</span><br><span class="hljs-keyword">let</span> activeEffect;<br><span class="hljs-comment">// effect 函数用于注册副作用函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">effect</span>(<span class="hljs-params">fn</span>) &#123;<br>  <span class="hljs-comment">// 当调用 effect 注册副作用函数时，将副作用函数 fn 赋值给activeEffect</span><br>  activeEffect = fn;<br>  <span class="hljs-comment">// 执行副作用函数</span><br>  <span class="hljs-title function_">fn</span>();<br>&#125;<br><br><span class="hljs-title function_">effect</span>(<br>  <span class="hljs-comment">// 一个匿名的副作用函数</span><br>  <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">innerText</span> = obj.<span class="hljs-property">text</span>;<br>  &#125;<br>);<br><br><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(data, &#123;<br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key</span>) &#123;<br>    <span class="hljs-comment">// 将 activeEffect 中存储的副作用函数收集到“桶”中</span><br>    <span class="hljs-keyword">if</span> (activeEffect) &#123;<br>      <span class="hljs-comment">// 新增</span><br>      bucket.<span class="hljs-title function_">add</span>(activeEffect); <span class="hljs-comment">// 新增</span><br>    &#125;<br>    <span class="hljs-comment">// 新增</span><br>    <span class="hljs-keyword">return</span> target[key];<br>  &#125;,<br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, newVal</span>) &#123;<br>    target[key] = newVal;<br>    bucket.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>());<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="4-3-2-重新设计“桶”的数据结构"><a href="#4-3-2-重新设计“桶”的数据结构" class="headerlink" title="4.3.2 重新设计“桶”的数据结构"></a>4.3.2 重新设计“桶”的数据结构</h3><p>添加一个不存在的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  obj.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;响应系统&quot;</span>;<br>&#125;, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><p>运行结果：副作用函数也被执行了</p><p>字段 obj.notExist 并没有与副作用建立响应联系，定时器内语句的执行不应该触发匿名副作用函数重新执行。导致该问题的根本原因是，<strong>我们没有在副作用函数与被操作的目标字段之间建立明确的联系</strong>。我们需要重新设计“桶”的数据结构</p><h4 id="1、-副作用函数与被操作的目标字段的关系"><a href="#1、-副作用函数与被操作的目标字段的关系" class="headerlink" title="1、 副作用函数与被操作的目标字段的关系"></a>1、 副作用函数与被操作的目标字段的关系</h4><p>观察以上的副作用函数中有几个重要的要素：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">effect</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">effectFn</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">innerText</span> = obj.<span class="hljs-property">text</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li>被操作（读取）的代理对象 obj；</li><li>被操作（读取）的字段名 text；</li><li>使用 effect 函数注册的副作用函数 effectFn。</li></ul><p>如果用 target 来表示一个代理对象所代理的原始对象，用 key 来表示被操作的字段名，用 effectFn 来表示被注册的副作用函数，那么可以为这三个角色建立如下关系：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">target</span><br>  └──key<br>      └──effectFn<br></code></pre></td></tr></table></figure><p><img src="/../../img/vue/vue4/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B03.png" alt="对象、字段与副作用函数的关系"></p><p>总之，这其实就是一个树型数据结构。这个联系建立起来之后，就可以解决前文提到的问题了。</p><h4 id="2、-“桶”的数据结构"><a href="#2、-“桶”的数据结构" class="headerlink" title="2、 “桶”的数据结构"></a>2、 “桶”的数据结构</h4><p>接下来我们尝试用代码来实现这个新的“桶”。首先，需要使用 WeakMap 代替 Set 作为桶的数据结构</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 存储副作用函数的桶</span><br><span class="hljs-keyword">const</span> bucket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakMap</span>();<br><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(data, &#123;<br>  <span class="hljs-comment">// 拦截读取操作</span><br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key</span>) &#123;<br>    <span class="hljs-comment">// 没有 activeEffect，直接 return</span><br>    <span class="hljs-keyword">if</span> (!activeEffect) <span class="hljs-keyword">return</span> target[key];<br>    <span class="hljs-comment">// 根据 target 从“桶”中取得 depsMap，它也是一个 Map 类型：key --&gt;effects</span><br>    <span class="hljs-keyword">let</span> depsMap = bucket.<span class="hljs-title function_">get</span>(target);<br>    <span class="hljs-comment">// 如果不存在 depsMap，那么新建一个 Map 并与 target 关联</span><br>    <span class="hljs-keyword">if</span> (!depsMap) &#123;<br>      bucket.<span class="hljs-title function_">set</span>(target, (depsMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()));<br>    &#125;<br>    <span class="hljs-comment">// 再根据 key 从 depsMap 中取得 deps，它是一个 Set 类型，</span><br>    <span class="hljs-comment">// 里面存储着所有与当前 key 相关联的副作用函数：effects</span><br>    <span class="hljs-keyword">let</span> deps = depsMap.<span class="hljs-title function_">get</span>(key);<br>    <span class="hljs-comment">// 如果 deps 不存在，同样新建一个 Set 并与 key 关联</span><br>    <span class="hljs-keyword">if</span> (!deps) &#123;<br>      depsMap.<span class="hljs-title function_">set</span>(key, (deps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()));<br>    &#125;<br>    <span class="hljs-comment">// 最后将当前激活的副作用函数添加到“桶”里</span><br>    deps.<span class="hljs-title function_">add</span>(activeEffect);<br>    <span class="hljs-comment">// 返回属性值</span><br>    <span class="hljs-keyword">return</span> target[key];<br>  &#125;,<br>  <span class="hljs-comment">// 拦截设置操作</span><br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, newVal</span>) &#123;<br>    <span class="hljs-comment">// 设置属性值</span><br>    target[key] = newVal;<br>    <span class="hljs-comment">// 根据 target 从桶中取得 depsMap，它是 key --&gt; effects</span><br>    <span class="hljs-keyword">const</span> depsMap = bucket.<span class="hljs-title function_">get</span>(target);<br>    <span class="hljs-keyword">if</span> (!depsMap) <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 根据 key 取得所有副作用函数 effects</span><br>    <span class="hljs-keyword">const</span> effects = depsMap.<span class="hljs-title function_">get</span>(key);<br>    <span class="hljs-comment">// 执行副作用函数</span><br>    effects &amp;&amp; effects.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>());<br>  &#125;,<br>&#125;);<br></code></pre></td></tr></table></figure><p>从这段代码可以看出构建数据结构的方式，我们分别使用了 WeakMap、Map 和 Set：</p><ul><li>WeakMap 由 target –&gt; Map 构成；</li><li>Map 由 key –&gt; Set 构成。</li></ul><p><img src="/../../img/vue/vue4/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B04.jpg" alt="桶结构图"></p><p>为了方便描述，我们把图中的 Set 数据结构所存储的副作用函数集合称为 key 的依赖集合</p><p><strong>思考</strong>：这里为什么要使用 WeakMap？</p><p>我们对上文中的代码做一些封装处理。在目前的实现中，当读取属性值时，我们直接在 get 拦截函数里编写把副作用函数收集到“桶”里的这部分逻辑，但更好的做法是将这部分逻辑单独封装到一个 track 函数中，函数的名字叫 track 是为了表达追踪的含义。同样，我们也可以把触发副作用函数重新执行的逻辑封装到 trigger 函数中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(data, &#123;<br>  <span class="hljs-comment">// 拦截读取操作</span><br>  <span class="hljs-title function_">get</span>(<span class="hljs-params">target, key</span>) &#123;<br>    <span class="hljs-comment">// 将副作用函数 activeEffect 添加到存储副作用函数的桶中</span><br>    <span class="hljs-title function_">track</span>(target, key);<br>    <span class="hljs-comment">// 返回属性值</span><br>    <span class="hljs-keyword">return</span> target[key];<br>  &#125;,<br>  <span class="hljs-comment">// 拦截设置操作</span><br>  <span class="hljs-title function_">set</span>(<span class="hljs-params">target, key, newVal</span>) &#123;<br>    <span class="hljs-comment">// 设置属性值</span><br>    target[key] = newVal;<br>    <span class="hljs-comment">// 把副作用函数从桶里取出并执行</span><br>    <span class="hljs-title function_">trigger</span>(target, key);<br>  &#125;,<br>&#125;);<br><span class="hljs-comment">// 在 get 拦截函数内调用 track 函数追踪变化</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">track</span>(<span class="hljs-params">target, key</span>) &#123;<br>  <span class="hljs-comment">// 没有 activeEffect，直接 return</span><br>  <span class="hljs-keyword">if</span> (!activeEffect) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">let</span> depsMap = bucket.<span class="hljs-title function_">get</span>(target);<br>  <span class="hljs-keyword">if</span> (!depsMap) &#123;<br>    bucket.<span class="hljs-title function_">set</span>(target, (depsMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()));<br>  &#125;<br>  <span class="hljs-keyword">let</span> deps = depsMap.<span class="hljs-title function_">get</span>(key);<br>  <span class="hljs-keyword">if</span> (!deps) &#123;<br>    depsMap.<span class="hljs-title function_">set</span>(key, (deps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()));<br>  &#125;<br>  deps.<span class="hljs-title function_">add</span>(activeEffect);<br>&#125;<br><span class="hljs-comment">// 在 set 拦截函数内调用 trigger 函数触发变化</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">trigger</span>(<span class="hljs-params">target, key</span>) &#123;<br>  <span class="hljs-keyword">const</span> depsMap = bucket.<span class="hljs-title function_">get</span>(target);<br>  <span class="hljs-keyword">if</span> (!depsMap) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">const</span> effects = depsMap.<span class="hljs-title function_">get</span>(key);<br>  effects &amp;&amp; effects.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>());<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://code.juejin.cn/pen/7346419420283011081">△ 运行代码</a><br>如以上代码所示，分别把逻辑封装到 track 和 trigger 函数内，这能为我们带来极大的灵活性。</p><h2 id="4-4-分支切换与-cleanup"><a href="#4-4-分支切换与-cleanup" class="headerlink" title="4.4 分支切换与 cleanup"></a>4.4 分支切换与 cleanup</h2><h3 id="4-4-1-什么是分支切换"><a href="#4-4-1-什么是分支切换" class="headerlink" title="4.4.1 什么是分支切换"></a>4.4.1 什么是分支切换</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> data = &#123; <span class="hljs-attr">ok</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;hello world&quot;</span> &#125;;<br><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(data, &#123;<br>  <span class="hljs-comment">/* ... */</span><br>&#125;);<br><span class="hljs-title function_">effect</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">effectFn</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">innerText</span> = obj.<span class="hljs-property">ok</span> ? obj.<span class="hljs-property">text</span> : <span class="hljs-string">&quot;not&quot;</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><p>在 effectFn 函数内部存在一个三元表达式，根据字段 obj.ok 值的不同会执行不同的代码分支。当字段 obj.ok 的值发生变化时，代码执行的分支会跟着变化，这就是所谓的分支切换。</p><p>分支切换可能会产生遗留的副作用函数。拿上面这段代码来说，字段 obj.ok 的初始值为 true，这时会读取字段 obj.text 的值，所以当 effectFn 函数执行时会触发字段 obj.ok 和字段 obj.text 这两个属性的读取操作，此时副作用函数 effectFn 与响应式数据之间建立的联系如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">data<br>  └── ok<br>      └── effectFn<br>  └── text<br>      └── effectFn<br></code></pre></td></tr></table></figure><p>如果 obj.ok 切换为 false 时，重新执行副作用函数，由于此时字段 obj.text 不会被读取，只会触发字段 obj.ok 的读取操作，所以理想情况下副作用函数 effectFn 不应该被字段 obj.text 所对应的依赖集合收集。这时就产生了遗留的副作用函数，遗留的副作用函数会导致不必要的更新 <a href="https://code.juejin.cn/pen/7346423325209886771">△ 运行代码</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">data<br>  └── ok<br>      └── effectFn<br></code></pre></td></tr></table></figure><p>解决这个问题的思路很简单，每次副作用函数执行时，我们可以先把它从所有与之关联的依赖集合中删除</p><p><img src="/../../img/vue/vue4/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B05.jpg" alt="断开副作用函数与响应式数据之间的联系"></p><h3 id="4-4-2-实现-cleanup"><a href="#4-4-2-实现-cleanup" class="headerlink" title="4.4.2 实现 cleanup"></a>4.4.2 实现 cleanup</h3><p>这部分我们来实现如何断开副作用函数与响应式数据之间的联系，要将一个副作用函数从所有与之关联的依赖集合中移除，就需要明确知道哪些依赖集合中包含它，我们需要<strong>重新设计副作用函数</strong>，</p><p>如下面的代码所示。在 effect 内部我们定义了新的 effectFn 函数，并为其添加了 effectFn.deps 属性，该属性是一个数组，用来存储所有包含当前副作用函数的依赖集合</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 用一个全局变量存储被注册的副作用函数</span><br><span class="hljs-keyword">let</span> activeEffect;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">effect</span>(<span class="hljs-params">fn</span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">effectFn</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-comment">// 当 effectFn 执行时，将其设置为当前激活的副作用函数</span><br>    activeEffect = effectFn;<br>    <span class="hljs-title function_">fn</span>();<br>  &#125;;<br>  <span class="hljs-comment">// activeEffect.deps 用来存储所有与该副作用函数相关联的依赖集合</span><br>  effectFn.<span class="hljs-property">deps</span> = [];<br>  <span class="hljs-comment">// 执行副作用函数</span><br>  <span class="hljs-title function_">effectFn</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>那么 effectFn.deps 数组中的依赖集合是如何收集的呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">track</span>(<span class="hljs-params">target, key</span>) &#123;<br>  <span class="hljs-comment">// 没有 activeEffect，直接 return</span><br>  <span class="hljs-keyword">if</span> (!activeEffect) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">let</span> depsMap = bucket.<span class="hljs-title function_">get</span>(target);<br>  <span class="hljs-keyword">if</span> (!depsMap) &#123;<br>    bucket.<span class="hljs-title function_">set</span>(target, (depsMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>()));<br>  &#125;<br>  <span class="hljs-keyword">let</span> deps = depsMap.<span class="hljs-title function_">get</span>(key);<br>  <span class="hljs-keyword">if</span> (!deps) &#123;<br>    depsMap.<span class="hljs-title function_">set</span>(key, (deps = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>()));<br>  &#125;<br>  <span class="hljs-comment">// 把当前激活的副作用函数添加到依赖集合 deps 中</span><br>  deps.<span class="hljs-title function_">add</span>(activeEffect);<br>  <span class="hljs-comment">// deps 就是一个与当前副作用函数存在联系的依赖集合</span><br>  <span class="hljs-comment">// 将其添加到 activeEffect.deps 数组中</span><br>  activeEffect.<span class="hljs-property">deps</span>.<span class="hljs-title function_">push</span>(deps); <span class="hljs-comment">// 新增</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在 track 函数中我们将当前执行的副作用函数 activeEffect 添加到依赖集合 deps 中，这说明 deps 就是一个与当前副作用函数存在联系的依赖集合，于是我们也把它添加到 activeEffect.deps 数组中，这样就完成了对依赖集合的收集。</p><p>有了这个联系后，我们就可以在每次副作用函数执行时，根据 effectFn.deps 获取所有相关联的依赖集合，进而将副作用函数从依赖集合中移除</p><p>副作用中移除：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 用一个全局变量存储被注册的副作用函数</span><br><span class="hljs-keyword">let</span> activeEffect;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">effect</span>(<span class="hljs-params">fn</span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">effectFn</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-comment">// 调用 cleanup 函数完成清除工作</span><br>    <span class="hljs-title function_">cleanup</span>(effectFn); <span class="hljs-comment">// 新增</span><br>    activeEffect = effectFn;<br>    <span class="hljs-title function_">fn</span>();<br>  &#125;;<br>  effectFn.<span class="hljs-property">deps</span> = [];<br>  <span class="hljs-title function_">effectFn</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>cleanup 的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">cleanup</span>(<span class="hljs-params">effectFn</span>) &#123;<br>  <span class="hljs-comment">// 遍历 effectFn.deps 数组</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; effectFn.<span class="hljs-property">deps</span>.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-comment">// deps 是依赖集合</span><br>    <span class="hljs-keyword">const</span> deps = effectFn.<span class="hljs-property">deps</span>[i];<br>    <span class="hljs-comment">// 将 effectFn 从依赖集合中移除</span><br>    deps.<span class="hljs-title function_">delete</span>(effectFn);<br>  &#125;<br>  <span class="hljs-comment">// 最后需要重置 effectFn.deps 数组</span><br>  effectFn.<span class="hljs-property">deps</span>.<span class="hljs-property">length</span> = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>cleanup 函数接收副作用函数作为参数，遍历副作用函数的 effectFn.deps 数组，该数组的每一项都是一个依赖集合，然后将该副作用函数从依赖集合中移除，最后重置 effectFn.deps 数组。</p><p>至此，我们的响应系统已经可以避免副作用函数产生遗留了。但如果你尝试运行代码，会发现目前的实现会导致无限循环执行，问题出在 trigger 函数中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 在 set 拦截函数内调用 trigger 函数触发变化</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">trigger</span>(<span class="hljs-params">target, key</span>) &#123;<br>  <span class="hljs-keyword">const</span> depsMap = bucket.<span class="hljs-title function_">get</span>(target);<br>  <span class="hljs-keyword">if</span> (!depsMap) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">const</span> effects = depsMap.<span class="hljs-title function_">get</span>(key);<br>  effects &amp;&amp; effects.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">effectFn</span>) =&gt;</span> <span class="hljs-title function_">effectFn</span>()); <span class="hljs-comment">// 问题代码 删除</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在 trigger 函数内部，我们遍历 effects 集合，它是一个 Set 集合，里面存储着副作用函数。当副作用函数执行时，会调用 cleanup 进行清除，实际上就是从 effects 集合中将当前执行的副作用函数剔除，但是副作用函数的执行会导致其重新被收集到集合中，而此时对于 effects 集合的遍历仍在进行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 在 set 拦截函数内调用 trigger 函数触发变化</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">trigger</span>(<span class="hljs-params">target, key</span>) &#123;<br>  <span class="hljs-keyword">const</span> depsMap = bucket.<span class="hljs-title function_">get</span>(target);<br>  <span class="hljs-keyword">if</span> (!depsMap) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">const</span> effects = depsMap.<span class="hljs-title function_">get</span>(key);<br>  <span class="hljs-comment">//effects &amp;&amp; effects.forEach(effectFn =&gt; effectFn()) // 问题代码 删除</span><br>  <span class="hljs-keyword">const</span> effectsToRun = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>(effects); <span class="hljs-comment">// 新增</span><br>  effectsToRun.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">effectFn</span>) =&gt;</span> <span class="hljs-title function_">effectFn</span>()); <span class="hljs-comment">// 新增</span><br>&#125;<br></code></pre></td></tr></table></figure><p>我们现在已经实现了 cleanup，解决了 分支切换 的问题。<a href="https://code.juejin.cn/pen/7346468034992668672">△ 运行代码</a></p><h2 id="4-5-嵌套的-effect-与-effect-栈"><a href="#4-5-嵌套的-effect-与-effect-栈" class="headerlink" title="4.5 嵌套的 effect 与 effect 栈"></a>4.5 嵌套的 effect 与 effect 栈</h2><p>effect 是可以发生嵌套的，例如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">effect</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">effectFn1</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-title function_">effect</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">effectFn2</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">/* ... */</span><br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><p>在上面这段代码中，effectFn1 内部嵌套了 effectFn2，effectFn1 的执行会导致 effectFn2 的执行。那么，什么场景下会出现嵌套的 effect 呢？拿 Vue.js 来说，实际上 Vue.js 的渲染函数就是在一个 effect 中执行的：</p><p><img src="/../../img/vue/vue4/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B06.png"></p><p>出现嵌套的场景：<br><img src="/../../img/vue/vue4/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B07.png"></p><p>这个例子说明了为什么 effect 要设计成可嵌套的。接下来，我们需要搞清楚，如果 effect 不支持嵌套会发生什么？实际上，按照前文的介绍与实现来看，我们所实现的响应系统并不支持 effect 嵌套</p><p>例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 原始数据</span><br><span class="hljs-keyword">const</span> data = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">bar</span>: <span class="hljs-literal">true</span> &#125;;<br><span class="hljs-comment">// 代理对象</span><br><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(data, &#123;<br>  <span class="hljs-comment">/* ... */</span><br>&#125;);<br><span class="hljs-comment">// 全局变量</span><br><span class="hljs-keyword">let</span> temp1, temp2; <span class="hljs-comment">// effectFn1 嵌套了 effectFn2</span><br><span class="hljs-title function_">effect</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">effectFn1</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;effectFn1 执行&quot;</span>);<br>  <span class="hljs-title function_">effect</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">effectFn2</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;effectFn2 执行&quot;</span>);<br>    <span class="hljs-comment">// 在 effectFn2 中读取 obj.bar 属性</span><br>    temp2 = obj.<span class="hljs-property">bar</span>;<br>  &#125;);<br>  <span class="hljs-comment">// 在 effectFn1 中读取 obj.foo 属性</span><br>  temp1 = obj.<span class="hljs-property">foo</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><p>理想的结构</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gcode">data<br>  └── foo<br>       └── effectF<span class="hljs-symbol">n1</span><br>  └── bar<br>       └── effectF<span class="hljs-symbol">n2</span><br></code></pre></td></tr></table></figure><p>问题：初始的时候，effectFn1 和 effectFn2 都会执行一次，当我们修改了 data.foo，应该执行 effectFn1，但是实际上执行了 effectFn2</p><p>问题出在哪里呢？其实就出在我们实现的 effect 函数与 activeEffect 上。</p><p>我们用全局变量 activeEffect 来存储通过 effect 函数注册的副作用函数，这意味着同一时刻 activeEffect 所存储的副作用函数只能有一个。当副作用函数发生嵌套时，内层副作用函数的执行会覆盖 activeEffect 的值，并且永远不会恢复到原来的值。这时如果再有响应式数据进行依赖收集，即使这个响应式数据是在外层副作用函数中读取的，它们收集到的副作用函数也都会是内层副作用函数，这就是问题所在。</p><p>为了解决这个问题，我们需要一个副作用函数栈 effectStack，在副作用函数执行时，将当前副作用函数压入栈中，待副作用函数执行完毕后将其从栈中弹出，并始终让 activeEffect 指向栈顶的副作用函数。这样就能做到一个响应式数据只会收集直接读取其值的副作用函数，而不会出现互相影响的情况，如以下代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 用一个全局变量存储当前激活的 effect 函数</span><br><span class="hljs-keyword">let</span> activeEffect;<br><span class="hljs-comment">// effect 栈</span><br><span class="hljs-keyword">const</span> effectStack = []; <span class="hljs-comment">// 新增</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">effect</span>(<span class="hljs-params">fn</span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">effectFn</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">cleanup</span>(effectFn);<br>    <span class="hljs-comment">// 当调用 effect 注册副作用函数时，将副作用函数赋值给 activeEffect</span><br>    activeEffect = effectFn;<br>    <span class="hljs-comment">// 在调用副作用函数之前将当前副作用函数压入栈中</span><br>    effectStack.<span class="hljs-title function_">push</span>(effectFn); <span class="hljs-comment">// 新增</span><br>    <span class="hljs-title function_">fn</span>();<br>    <span class="hljs-comment">// 在当前副作用函数执行完毕后，将当前副作用函数弹出栈，并把activeEffect 还原为之前的值</span><br>    effectStack.<span class="hljs-title function_">pop</span>(); <span class="hljs-comment">// 新增</span><br>    activeEffect = effectStack[effectStack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>]; <span class="hljs-comment">// 新增</span><br>  &#125;;<br>  <span class="hljs-comment">// activeEffect.deps 用来存储所有与该副作用函数相关的依赖集合</span><br>  effectFn.<span class="hljs-property">deps</span> = [];<br>  <span class="hljs-comment">// 执行副作用函数</span><br>  <span class="hljs-title function_">effectFn</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>我们定义了 effectStack 数组，用它来模拟栈，activeEffect 没有变化，它仍然指向当前正在执行的副作用函数。不同的是，当前执行的副作用函数会被压入栈顶，这样当副作用函数发生嵌套时，栈底存储的就是外层副作用函数，而栈顶存储的则是内层副作用函数，如图:<br><img src="/../../img/vue/vue4/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B08.jpg"></p><p>当内层副作用函数 effectFn2 执行完毕后，它会被弹出栈，并将副作用函数 effectFn1 设置为 activeEffect，如图:<br><img src="/../../img/vue/vue4/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B09.jpg"></p><h2 id="4-6-避免无限递归循环"><a href="#4-6-避免无限递归循环" class="headerlink" title="4.6 避免无限递归循环"></a>4.6 避免无限递归循环</h2><p>如前文所说，实现一个完善的响应系统要考虑诸多细节。而本节要介绍的无限递归循环就是其中之一，还是举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> data = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span> &#125;;<br><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(data, &#123;<br>  <span class="hljs-comment">/*...*/</span><br>&#125;);<br><span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> obj.<span class="hljs-property">foo</span>++);<br></code></pre></td></tr></table></figure><p>可以看到，在 effect 注册的副作用函数内有一个自增操作 obj.foo++，导致无限递归地调用自己，会引起栈溢出</p><p>我们可以在 trigger 动作发生时增加守卫条件：<strong>如果 trigger 触发执行的副作用函数与当前正在执行的副作用函数相同，则不触发执行</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">trigger</span>(<span class="hljs-params">target, key</span>) &#123;<br>  <span class="hljs-keyword">const</span> depsMap = bucket.<span class="hljs-title function_">get</span>(target);<br>  <span class="hljs-keyword">if</span> (!depsMap) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">const</span> effects = depsMap.<span class="hljs-title function_">get</span>(key);<br>  <span class="hljs-keyword">const</span> effectsToRun = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>  effects &amp;&amp;<br>    effects.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">effectFn</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">// 如果 trigger 触发执行的副作用函数与当前正在执行的副作用函数相同，则不触发执行</span><br>      <span class="hljs-keyword">if</span> (effectFn !== activeEffect) &#123;<br>        <span class="hljs-comment">// 新增</span><br>        effectsToRun.<span class="hljs-title function_">add</span>(effectFn);<br>      &#125;<br>    &#125;);<br>  effectsToRun.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">effectFn</span>) =&gt;</span> <span class="hljs-title function_">effectFn</span>());<br>  <span class="hljs-comment">// effects &amp;&amp; effects.forEach(effectFn =&gt; effectFn())</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-7-可调度性"><a href="#4-7-可调度性" class="headerlink" title="4.7 可调度性"></a>4.7 可调度性</h2><p>可调度性是响应系统非常重要的特性。首先我们需要明确什么是可调度性。所谓可调度，指的是当 trigger 动作触发副作用函数重新执行时，有能力决定副作用函数执行的时机、次数以及方式</p><p><img src="/../../img/vue/vue4/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B010.png"></p><p>有同学说了：把语句 obj.foo++和语句 console.log(‘结束了’)位置互换即可。</p><p>那么有没有什么办法能够在不调整代码的情况下实现需求呢？这时就需要响应系统支持<strong>调度</strong></p><h3 id="4-7-1-实现调度功能"><a href="#4-7-1-实现调度功能" class="headerlink" title="4.7.1 实现调度功能"></a>4.7.1 实现调度功能</h3><p>我们可以为 effect 函数设计一个选项参数 options，允许用户指定调度器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">effect</span>(<br>  <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">foo</span>);<br>  &#125;,<br>  <span class="hljs-comment">// options</span><br>  &#123;<br>    <span class="hljs-comment">// 调度器 scheduler 是一个函数</span><br>    <span class="hljs-title function_">scheduler</span>(<span class="hljs-params">fn</span>) &#123;<br>      <span class="hljs-comment">// ...</span><br>    &#125;,<br>  &#125;<br>);<br></code></pre></td></tr></table></figure><p>用户在调用 effect 函数注册副作用函数时，可以传递第二个参数 options。它是一个对象，其中允许指定 scheduler 调度函数，同时在 effect 函数内部我们需要把 options 选项挂载到对应的副作用函数上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">effect</span>(<span class="hljs-params">fn, options = &#123;&#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">effectFn</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">cleanup</span>(effectFn);<br>    <span class="hljs-comment">// 当调用 effect 注册副作用函数时，将副作用函数赋值给 activeEffect</span><br>    activeEffect = effectFn;<br>    <span class="hljs-comment">// 在调用副作用函数之前将当前副作用函数压栈</span><br>    effectStack.<span class="hljs-title function_">push</span>(effectFn);<br>    <span class="hljs-title function_">fn</span>();<br>    <span class="hljs-comment">// 在当前副作用函数执行完毕后，将当前副作用函数弹出栈，并把activeEffect 还原为之前的值</span><br>    effectStack.<span class="hljs-title function_">pop</span>();<br>    activeEffect = effectStack[effectStack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>  &#125;;<br>  <span class="hljs-comment">// 将 options 挂载到 effectFn 上</span><br>  effectFn.<span class="hljs-property">options</span> = options; <span class="hljs-comment">// 新增</span><br>  <span class="hljs-comment">// activeEffect.deps 用来存储所有与该副作用函数相关的依赖集合</span><br>  effectFn.<span class="hljs-property">deps</span> = [];<br>  <span class="hljs-comment">// 执行副作用函数</span><br>  <span class="hljs-title function_">effectFn</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>有了调度函数，我们在 trigger 函数中触发副作用函数重新执行时，就可以直接调用用户传递的调度器函数，从而把控制权交给用户：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">trigger</span>(<span class="hljs-params">target, key</span>) &#123;<br>  <span class="hljs-keyword">const</span> depsMap = bucket.<span class="hljs-title function_">get</span>(target);<br>  <span class="hljs-keyword">if</span> (!depsMap) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-keyword">const</span> effects = depsMap.<span class="hljs-title function_">get</span>(key);<br>  <span class="hljs-keyword">const</span> effectsToRun = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br>  effects &amp;&amp;<br>    effects.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">effectFn</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (effectFn !== activeEffect) &#123;<br>        effectsToRun.<span class="hljs-title function_">add</span>(effectFn);<br>      &#125;<br>    &#125;);<br>  effectsToRun.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">effectFn</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 如果一个副作用函数存在调度器，则调用该调度器，并将副作用函数作为参数传递</span><br>    <span class="hljs-keyword">if</span> (effectFn.<span class="hljs-property">options</span>.<span class="hljs-property">scheduler</span>) &#123;<br>      <span class="hljs-comment">// 新增</span><br>      effectFn.<span class="hljs-property">options</span>.<span class="hljs-title function_">scheduler</span>(effectFn); <span class="hljs-comment">// 新增</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 否则直接执行副作用函数（之前的默认行为）</span><br>      <span class="hljs-title function_">effectFn</span>(); <span class="hljs-comment">// 新增</span><br>    &#125;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>问题来了，如图：</p><p><img src="/../../img/vue/vue4/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B011.png"></p><p>由输出可知，字段 obj.foo 的值一定会从 1 自增到 3，2 只是它的过渡状态。如果我们只关心最终结果而不关心过程，那么执行三次打印操作是多余的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 定义一个任务队列</span><br><span class="hljs-keyword">const</span> jobQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Set</span>();<br><span class="hljs-comment">// 使用 Promise.resolve() 创建一个 promise 实例，我们用它将一个任务添加到微任务队列</span><br><span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>();<br><span class="hljs-comment">// 一个标志代表是否正在刷新队列</span><br><span class="hljs-keyword">let</span> isFlushing = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flushJob</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// 如果队列正在刷新，则什么都不做</span><br>  <span class="hljs-keyword">if</span> (isFlushing) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-comment">// 设置为 true，代表正在刷新</span><br>  isFlushing = <span class="hljs-literal">true</span>;<br>  <span class="hljs-comment">// 在微任务队列中刷新 jobQueue 队列</span><br><br>  p.<span class="hljs-title function_">then</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    jobQueue.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">job</span>) =&gt;</span> <span class="hljs-title function_">job</span>());<br>  &#125;).<span class="hljs-title function_">finally</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 结束后重置 isFlushing</span><br>    isFlushing = <span class="hljs-literal">false</span>;<br>  &#125;);<br>&#125;<br><span class="hljs-title function_">effect</span>(<br>  <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">foo</span>);<br>  &#125;,<br>  &#123;<br>    <span class="hljs-title function_">scheduler</span>(<span class="hljs-params">fn</span>) &#123;<br>      <span class="hljs-comment">// 每次调度时，将副作用函数添加到 jobQueue 队列中</span><br>      jobQueue.<span class="hljs-title function_">add</span>(fn);<br>      <span class="hljs-comment">// 调用 flushJob 刷新队列</span><br>      <span class="hljs-title function_">flushJob</span>();<br>    &#125;,<br>  &#125;<br>);<br>obj.<span class="hljs-property">foo</span>++;<br>obj.<span class="hljs-property">foo</span>++;<br></code></pre></td></tr></table></figure><p><img src="/../../img/vue/vue4/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B012.png"></p><h2 id="4-8-计算属性-computed-与-lazy"><a href="#4-8-计算属性-computed-与-lazy" class="headerlink" title="4.8 计算属性 computed 与 lazy"></a>4.8 计算属性 computed 与 lazy</h2><h3 id="4-8-1-lazy"><a href="#4-8-1-lazy" class="headerlink" title="4.8.1 lazy"></a>4.8.1 lazy</h3><p>在深入讲解计算属性之前，我们需要先来聊聊关于懒执行的 effect，即 lazy 的 effect。这是什么意思呢？举个例子，现在我们所实现的 effect 函数会立即执行传递给它的副作用函数</p><p>但在有些场景下，我们并不希望它立即执行，而是希望它在需要的时候才执行，例如计算属性。</p><p>我们给 effct 的 options 增加一个 lazy 选项，当 lazy 为 true 时不会立即执行副作用函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">effect</span>(<span class="hljs-params">fn, options = &#123;&#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">effectFn</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">cleanup</span>(effectFn);<br>    activeEffect = effectFn;<br>    effectStack.<span class="hljs-title function_">push</span>(effectFn);<br>    <span class="hljs-title function_">fn</span>();<br>    effectStack.<span class="hljs-title function_">pop</span>();<br>    activeEffect = effectStack[effectStack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>  &#125;;<br>  effectFn.<span class="hljs-property">options</span> = options;<br>  effectFn.<span class="hljs-property">deps</span> = [];<br>  <span class="hljs-comment">// 只有非 lazy 的时候，才执行</span><br>  <span class="hljs-keyword">if</span> (!options.<span class="hljs-property">lazy</span>) &#123;<br>    <span class="hljs-comment">// 新增</span><br>    <span class="hljs-comment">// 执行副作用函数</span><br>    <span class="hljs-title function_">effectFn</span>();<br>  &#125;<br>  <span class="hljs-comment">// 将副作用函数作为返回值返回</span><br>  <span class="hljs-keyword">return</span> effectFn; <span class="hljs-comment">// 新增</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过这个判断，我们就实现了让副作用函数不立即执行的功能。但问题是，副作用函数应该什么时候执行呢？通过上面的代码可以看到，我们将副作用函数 effectFn 作为 effect 函数的返回值，这就意味着当调用 effect 函数时，通过其返回值能够拿到对应的副作用函数，这样我们就能手动执行该副作用函数了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> effectFn = <span class="hljs-title function_">effect</span>(<br>  <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">foo</span>);<br>  &#125;,<br>  &#123; <span class="hljs-attr">lazy</span>: <span class="hljs-literal">true</span> &#125;<br>);<br><br><span class="hljs-comment">// 手动执行副作用函数</span><br><span class="hljs-title function_">effectFn</span>();<br></code></pre></td></tr></table></figure><p>如果仅仅能够手动执行副作用函数，其意义并不大。但如果我们把传递给 effect 的函数看作一个 getter，那么这个 getter 函数可以返回任何值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">effect</span>(<span class="hljs-params">fn, options = &#123;&#125;</span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">effectFn</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    <span class="hljs-title function_">cleanup</span>(effectFn);<br>    activeEffect = effectFn;<br>    effectStack.<span class="hljs-title function_">push</span>(effectFn);<br>    <span class="hljs-comment">// 将 fn 的执行结果存储到 res 中</span><br>    <span class="hljs-keyword">const</span> res = <span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// 新增</span><br>    effectStack.<span class="hljs-title function_">pop</span>();<br>    activeEffect = effectStack[effectStack.<span class="hljs-property">length</span> - <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// 将 res 作为 effectFn 的返回值</span><br>    <span class="hljs-keyword">return</span> res; <span class="hljs-comment">// 新增</span><br>  &#125;;<br>  effectFn.<span class="hljs-property">options</span> = options;<br>  effectFn.<span class="hljs-property">deps</span> = [];<br>  <span class="hljs-keyword">if</span> (!options.<span class="hljs-property">lazy</span>) &#123;<br>    <span class="hljs-title function_">effectFn</span>();<br>  &#125;<br>  <span class="hljs-keyword">return</span> effectFn;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过新增的代码可以看到，传递给 effect 函数的参数 fn 才是真正的副作用函数，而 effectFn 是我们包装后的副作用函数。为了通过 effectFn 得到真正的副作用函数 fn 的执行结果，我们需要将其保存到 res 变量中，然后将其作为 effectFn 函数的返回值。</p><p>现在我们已经能够实现懒执行的副作用函数，并且能够拿到副作用函数的执行结果了，接下来就可以实现计算属性了</p><h3 id="4-8-2-实现计算属性"><a href="#4-8-2-实现计算属性" class="headerlink" title="4.8.2 实现计算属性"></a>4.8.2 实现计算属性</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">computed</span>(<span class="hljs-params">getter</span>) &#123;<br>  <span class="hljs-comment">// 把 getter 作为副作用函数，创建一个 lazy 的 effect</span><br>  <span class="hljs-keyword">const</span> effectFn = <span class="hljs-title function_">effect</span>(getter, &#123;<br>    <span class="hljs-attr">lazy</span>: <span class="hljs-literal">true</span>,<br>  &#125;);<br>  <span class="hljs-keyword">const</span> obj = &#123;<br>    <span class="hljs-comment">// 当读取 value 时才执行 effectFn</span><br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">value</span>() &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">effectFn</span>();<br>    &#125;,<br>  &#125;;<br>  <span class="hljs-keyword">return</span> obj;<br>&#125;<br><br><span class="hljs-keyword">const</span> data = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">bar</span>: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-keyword">const</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Proxy</span>(data, &#123;<br>  <span class="hljs-comment">/* ... */</span><br>&#125;);<br><span class="hljs-keyword">const</span> sumRes = <span class="hljs-title function_">computed</span>(<span class="hljs-function">() =&gt;</span> obj.<span class="hljs-property">foo</span> + obj.<span class="hljs-property">bar</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sumRes.<span class="hljs-property">value</span>); <span class="hljs-comment">//</span><br></code></pre></td></tr></table></figure><p>可以看到它能够正确地工作。不过现在我们实现的计算属性只做到了懒计算，也就是说，只有当你真正读取 sumRes.value 的值时，它才会进行计算并得到值。但是还做不到对值进行缓存，即假如我们多次访问 sumRes.value 的值，会导致 effectFn 进行多次计算，即使 obj.foo 和 obj.bar 的值本身并没有变化</p><p>为了解决这个问题，就需要我们在实现 computed 函数时，添加对值进行缓存的功能，如以下代码所示：</p><p>计算属性懒计算<br>计算属性缓存<br>计算属性值的响应性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">computed</span>(<span class="hljs-params">getter</span>) &#123;<br>  <span class="hljs-comment">// value 用来缓存上一次计算的值</span><br>  <span class="hljs-keyword">let</span> value;<br>  <span class="hljs-comment">// dirty 标志，用来标识是否需要重新计算值，为 true 则意味着“脏”，需要计算</span><br>  <span class="hljs-keyword">let</span> dirty = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">const</span> effectFn = <span class="hljs-title function_">effect</span>(getter, &#123;<br>    <span class="hljs-attr">lazy</span>: <span class="hljs-literal">true</span>,<br>  &#125;);<br>  <span class="hljs-keyword">const</span> obj = &#123;<br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">value</span>() &#123;<br>      <span class="hljs-comment">// 只有“脏”时才计算值，并将得到的值缓存到 value 中</span><br>      <span class="hljs-keyword">if</span> (dirty) &#123;<br>        value = <span class="hljs-title function_">effectFn</span>();<br>        <span class="hljs-comment">// 将 dirty 设置为 false，下一次访问直接使用缓存到 value 中的值</span><br>        dirty = <span class="hljs-literal">false</span>;<br>      &#125;<br>      <span class="hljs-keyword">return</span> value;<br>    &#125;,<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure><p>effect 的副作用函数中读取了 computed 的值，如果修改了其依赖，计算属性发生变化就会触发重新<br>渲染，但是如果尝试运行上面这段代码，并不会触发副作用函数的渲染</p><p>当读取计算属性的值时，我们可以手动调用 track 函数进行追踪；当计算属性依赖的响应式数据发生变化时，我们可以手动调用 trigger 函数触发响应：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">computed</span>(<span class="hljs-params">getter</span>) &#123;<br>  <span class="hljs-keyword">let</span> value;<br>  <span class="hljs-keyword">let</span> dirty = <span class="hljs-literal">true</span>;<br>  <span class="hljs-keyword">const</span> effectFn = <span class="hljs-title function_">effect</span>(getter, &#123;<br>    <span class="hljs-attr">lazy</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-title function_">scheduler</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">if</span> (!dirty) &#123;<br>        dirty = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 当计算属性依赖的响应式数据变化时，手动调用 trigger 函数触发响应</span><br>        <span class="hljs-title function_">trigger</span>(obj, <span class="hljs-string">&quot;value&quot;</span>);<br>      &#125;<br>    &#125;,<br>  &#125;);<br>  <span class="hljs-keyword">const</span> obj = &#123;<br>    <span class="hljs-keyword">get</span> <span class="hljs-title function_">value</span>() &#123;<br>      <span class="hljs-keyword">if</span> (dirty) &#123;<br>        value = <span class="hljs-title function_">effectFn</span>();<br>        dirty = <span class="hljs-literal">false</span>;<br>      &#125;<br>      <span class="hljs-comment">// 当读取 value 时，手动调用 track 函数进行追踪</span><br>      <span class="hljs-title function_">track</span>(obj, <span class="hljs-string">&quot;value&quot;</span>);<br>      <span class="hljs-keyword">return</span> value;<br>    &#125;,<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-9-watch-的实现原理"><a href="#4-9-watch-的实现原理" class="headerlink" title="4.9 watch 的实现原理"></a>4.9 watch 的实现原理</h2><p>所谓 watch，其本质就是观测一个响应式数据，当数据发生变化时通知并执行相应的回调函数<br>实际上，watch 的实现本质上就是利用了 effect 以及 options.scheduler 选项，如以下代码所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">effect</span>(<br>  <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">foo</span>);<br>  &#125;,<br>  &#123;<br>    <span class="hljs-title function_">scheduler</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">// 当 obj.foo 的值变化时，会执行 scheduler 调度函数</span><br>    &#125;,<br>  &#125;<br>);<br></code></pre></td></tr></table></figure><p>在一个副作用函数中访问响应式数据 obj.foo，通过前面的介绍，我们知道这会在副作用函数与响应式数据之间建立联系，当响应式数据变化时，会触发副作用函数重新执行。但有一个例外，即如果副作用函数存在 scheduler 选项，当响应式数据发生变化时，会触发 scheduler 调度函数执行，而非直接触发副作用函数执行。从这个角度来看，其实 scheduler 调度函数就相当于一个回调函数，而 watch 的实现就是利用了这个特点。下面是最简单的 watch 函数的实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// watch 函数接收两个参数，source 是响应式数据，cb 是回调函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">watch</span>(<span class="hljs-params">source, cb</span>) &#123;<br>  <span class="hljs-title function_">effect</span>(<br>    <span class="hljs-comment">// 触发读取操作，从而建立联系</span><br>    <span class="hljs-function">() =&gt;</span> source.<span class="hljs-property">foo</span>,<br>    &#123;<br>      <span class="hljs-title function_">scheduler</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 当数据变化时，调用回调函数 cb</span><br>        <span class="hljs-title function_">cb</span>();<br>      &#125;,<br>    &#125;<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这段代码能正常工作，但是我们注意到在 watch 函数的实现中，硬编码了对 source.foo 的读取操作。换句话说，现在只能观测 obj.foo 的改变。为了让 watch 函数具有通用性，我们需要一个封装一个通用的读取操作</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">watch</span>(<span class="hljs-params">source, cb</span>) &#123;<br>  <span class="hljs-title function_">effect</span>(<br>    <span class="hljs-comment">// 调用 traverse 递归地读取</span><br>    <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">traverse</span>(source),<br>    &#123;<br>      <span class="hljs-title function_">scheduler</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 当数据变化时，调用回调函数 cb</span><br>        <span class="hljs-title function_">cb</span>();<br>      &#125;,<br>    &#125;<br>  );<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">traverse</span>(<span class="hljs-params">value, seen = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()</span>) &#123;<br>  <span class="hljs-comment">// 如果要读取的数据是原始值，或者已经被读取过了，那么什么都不做</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">&quot;object&quot;</span> || value === <span class="hljs-literal">null</span> || seen.<span class="hljs-title function_">has</span>(value)) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-comment">// 将数据添加到 seen 中，代表遍历地读取过了，避免循环引用引起的死循环</span><br>  seen.<span class="hljs-title function_">add</span>(value);<br>  <span class="hljs-comment">// 暂时不考虑数组等其他结构</span><br><br>  <span class="hljs-comment">// 假设 value 就是一个对象，使用 for...in 读取对象的每一个值，并递归地调用 traverse 进行处理</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> k <span class="hljs-keyword">in</span> value) &#123;<br>    <span class="hljs-title function_">traverse</span>(value[k], seen);<br>  &#125;<br>  <span class="hljs-keyword">return</span> value;<br>&#125;<br></code></pre></td></tr></table></figure><p>watch 函数除了可以观测响应式数据，还可以接收一个 getter 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">watch</span>(<span class="hljs-params">source, cb</span>) &#123;<br>  <span class="hljs-comment">// 定义 getter</span><br>  <span class="hljs-keyword">let</span> getter;<br>  <span class="hljs-comment">// 如果 source 是函数，说明用户传递的是 getter，所以直接把 source 赋值给 getter</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> source === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    getter = source;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 否则按照原来的实现调用 traverse 递归地读取</span><br>    getter = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">traverse</span>(source);<br>  &#125;<br><br>  <span class="hljs-title function_">effect</span>(<br>    <span class="hljs-comment">// 执行 getter</span><br>    <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">getter</span>(),<br>    &#123;<br>      <span class="hljs-title function_">scheduler</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title function_">cb</span>();<br>      &#125;,<br>    &#125;<br>  );<br>&#125;<br><br><span class="hljs-comment">//调用watch函数</span><br><span class="hljs-title function_">watch</span>(<br>  <span class="hljs-comment">// getter 函数</span><br>  <span class="hljs-function">() =&gt;</span> obj.<span class="hljs-property">foo</span>,<br>  <span class="hljs-comment">// 回调函数</span><br>  <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;obj.foo 的值变了&quot;</span>);<br>  &#125;<br>);<br></code></pre></td></tr></table></figure><p>那么如何获得新值与旧值呢？这需要充分利用 effect 函数的 lazy 选项，如以下代码所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">watch</span>(<span class="hljs-params">source, cb</span>) &#123;<br>  <span class="hljs-keyword">let</span> getter;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> source === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    getter = source;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    getter = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">traverse</span>(source);<br>  &#125;<br>  <span class="hljs-comment">// 定义旧值与新值</span><br>  <span class="hljs-keyword">let</span> oldValue, newValue;<br>  <span class="hljs-comment">// 使用 effect 注册副作用函数时，开启 lazy 选项，并把返回值存储到effectFn 中以便后续手动调用</span><br>  <span class="hljs-keyword">const</span> effectFn = <span class="hljs-title function_">effect</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">getter</span>(), &#123;<br>    <span class="hljs-attr">lazy</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-title function_">scheduler</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-comment">// 在 scheduler 中重新执行副作用函数，得到的是新值</span><br>      newValue = <span class="hljs-title function_">effectFn</span>();<br>      <span class="hljs-comment">// 将旧值和新值作为回调函数的参数</span><br>      <span class="hljs-title function_">cb</span>(newValue, oldValue);<br>      <span class="hljs-comment">// 更新旧值，不然下一次会得到错误的旧值</span><br>      oldValue = newValue;<br>    &#125;,<br>  &#125;);<br>  <span class="hljs-comment">// 手动调用副作用函数，拿到的值就是旧值</span><br>  oldValue = <span class="hljs-title function_">effectFn</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-10-立即执行的-watch-与回调执行时机"><a href="#4-10-立即执行的-watch-与回调执行时机" class="headerlink" title="4.10 立即执行的 watch 与回调执行时机"></a>4.10 立即执行的 watch 与回调执行时机</h2><p>上一节中我们介绍了 watch 的基本实现。在这个过程中我们认识到，watch 的本质其实是对 effect 的二次封装。本节我们继续讨论关于 watch 的两个特性：一个是立即执行的回调函数，另一个是回调函数的执行时机</p><p>默认情况下，一个 watch 的回调只会在响应式数据发生变化时才执行,在 Vue.js 中可以通过选项参数 immediate 来指定回调是否需要立即执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">watch</span>(<br>  obj,<br>  <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;变化了&quot;</span>);<br>  &#125;,<br>  &#123;<br>    <span class="hljs-comment">// 回调函数会在 watch 创建时立即执行一次</span><br>    <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span>,<br>  &#125;<br>);<br></code></pre></td></tr></table></figure><p>当 immediate 选项存在并且为 true 时，回调函数会在该 watch 创建时立刻执行一次。仔细思考就会发现，回调函数的立即执行与后续执行本质上没有任何差别，所以我们可以把 scheduler 调度函数封装为一个通用函数，分别在初始化和变更时执行它，如以下代码所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">watch</span>(<span class="hljs-params">source, cb, options = &#123;&#125;</span>) &#123;<br>  <span class="hljs-keyword">let</span> getter;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> source === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    getter = source05;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    getter = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">traverse</span>(source);<br>  &#125;<br>  <span class="hljs-keyword">let</span> oldValue, newValue;<br>  <span class="hljs-comment">// 提取 scheduler 调度函数为一个独立的 job 函数</span><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">job</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    newValue = <span class="hljs-title function_">effectFn</span>();<br>    <span class="hljs-title function_">cb</span>(newValue, oldValue);<br>    oldValue = newValue;<br>  &#125;;<br>  <span class="hljs-keyword">const</span> effectFn = <span class="hljs-title function_">effect</span>(<br>    <span class="hljs-comment">// 执行 getter</span><br>    <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">getter</span>(),<br>    &#123;<br>      <span class="hljs-attr">lazy</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-comment">// 使用 job 函数作为调度器函数</span><br>      <span class="hljs-attr">scheduler</span>: job,<br>    &#125;<br>  );<br>  <span class="hljs-keyword">if</span> (options.<span class="hljs-property">immediate</span>) &#123;<br>    <span class="hljs-comment">// 当 immediate 为 true 时立即执行 job，从而触发回调执行</span><br>    <span class="hljs-title function_">job</span>();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    oldValue = <span class="hljs-title function_">effectFn</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>flush 本质上是在指定调度函数的执行时机。前文讲解过如何在微任务队列中执行调度函数 scheduler，这与 flush 的功能相同。当 flush 的值为’post’时，代表调度函数需要将副作用函数放到一个微任务队列中，并等待 DOM 更新结束后再执行，我们可以用如下代码进行模拟</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">watch</span>(<span class="hljs-params">source, cb, options = &#123;&#125;</span>) &#123;<br>  <span class="hljs-keyword">let</span> getter;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> source === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    getter = source;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    getter = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">traverse</span>(source);<br>  &#125;<br>  <span class="hljs-keyword">let</span> oldValue, newValue;<br><br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">job</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    newValue = <span class="hljs-title function_">effectFn</span>();<br>    <span class="hljs-title function_">cb</span>(newValue, oldValue);<br>    oldValue = newValue;<br>  &#125;;<br>  <span class="hljs-keyword">const</span> effectFn = <span class="hljs-title function_">effect</span>(<br>    <span class="hljs-comment">// 执行 getter</span><br>    <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">getter</span>(),<br>    &#123;<br>      <span class="hljs-attr">lazy</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">scheduler</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-comment">// 在调度函数中判断 flush 是否为 &#x27;post&#x27;，如果是，将其放到微任务队列中执行</span><br>        <span class="hljs-keyword">if</span> (options.<span class="hljs-property">flush</span> === <span class="hljs-string">&quot;post&quot;</span>) &#123;<br>          <span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>();<br>          p.<span class="hljs-title function_">then</span>(job);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-title function_">job</span>();<br>        &#125;<br>      &#125;,<br>    &#125;<br>  );<br>  <span class="hljs-keyword">if</span> (options.<span class="hljs-property">immediate</span>) &#123;<br>    <span class="hljs-title function_">job</span>();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    oldValue = <span class="hljs-title function_">effectFn</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们修改了调度器函数 scheduler 的实现方式，在调度器函数内检测 options.flush 的值是否为 post，如果是，则将 job 函数放到微任务队列中，从而实现异步延迟执行；否则直接执行 job 函数，这本质上相当于’sync’的实现机制，即同步执行。对于 options.flush 的值为’pre’的情况，我们暂时还没有办法模拟，因为这涉及组件的更新时机，其中’pre’和’post’原本的语义指的就是组件更新前和更新后，不过这并不影响我们理解如何控制回调函数的更新时机</p><h2 id="4-11-过期的副作用"><a href="#4-11-过期的副作用" class="headerlink" title="4.11 过期的副作用"></a>4.11 过期的副作用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> finalData;<br><span class="hljs-title function_">watch</span>(obj, <span class="hljs-keyword">async</span> () =&gt; &#123;<br>  <span class="hljs-comment">// 发送并等待网络请求</span><br>  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/path/to/request&quot;</span>);<br>  <span class="hljs-comment">// 将请求结果赋值给 data</span><br>  finalData = res;<br>&#125;);<br></code></pre></td></tr></table></figure><p>观察上面的代码，乍一看似乎没什么问题。但仔细思考会发现这段代码会发生竞态问题。</p><p><img src="/../../img/vue/vue4/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B013.jpg" alt="竞态问题"></p><p>在 Vue.js 中，watch 函数的回调函数接收第三个参数 onInvalidate，它是一个函数，类似于事件监听器，我们可以使用 onInvalidate 函数注册一个回调，这个回调函数会在当前副作用函数过期时执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">watch</span>(obj, <span class="hljs-keyword">async</span> (newValue, oldValue, onInvalidate) =&gt; &#123;<br>  <span class="hljs-comment">// 定义一个标志，代表当前副作用函数是否过期，默认为 false，代表没有过期</span><br>  <span class="hljs-keyword">let</span> expired = <span class="hljs-literal">false</span>;<br>  <span class="hljs-comment">// 调用 onInvalidate() 函数注册一个过期回调</span><br>  <span class="hljs-title function_">onInvalidate</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 当过期时，将 expired 设置为 true</span><br>    expired = <span class="hljs-literal">true</span>;<br>  &#125;);<br>  <span class="hljs-comment">// 发送网络请求</span><br>  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/path/to/request&quot;</span>);<br>  <span class="hljs-comment">// 只有当该副作用函数的执行没有过期时，才会执行后续操作。</span><br>  <span class="hljs-keyword">if</span> (!expired) &#123;<br>    finalData = res;<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>如上面的代码所示，在发送请求之前，我们定义了 expired 标志变量，用来标识当前副作用函数的执行是否过期；接着调用 onInvalidate 函数注册了一个过期回调，当该副作用函数的执行过期时将 expired 标志变量设置为 true；最后只有当没有过期时才采用请求结果，这样就可以有效地避免上述问题了。那么 Vue.js 是怎么做到的呢？换句话说，onInvalidate 的原理是什么呢？其实很简单，在 watch 内部每次检测到变更后，在副作用函数重新执行之前，会先调用我们通过 onInvalidate 函数注册的过期回调，仅此而已，如以下代码所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">watch</span>(<span class="hljs-params">source, cb, options = &#123;&#125;</span>) &#123;<br>  <span class="hljs-keyword">let</span> getter;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> source === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    getter = source;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    getter = <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">traverse</span>(source);<br>  &#125;<br>  <span class="hljs-keyword">let</span> oldValue, newValue;<br>  <span class="hljs-comment">// cleanup 用来存储用户注册的过期回调</span><br>  <span class="hljs-keyword">let</span> cleanup;<br>  <span class="hljs-comment">// 定义 onInvalidate 函数</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">onInvalidate</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-comment">// 将过期回调存储到 cleanup 中</span><br>    cleanup = fn;<br>  &#125;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">job</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    newValue = <span class="hljs-title function_">effectFn</span>();<br>    <span class="hljs-comment">// 在调用回调函数 cb 之前，先调用过期回调</span><br>    <span class="hljs-keyword">if</span> (cleanup) &#123;<br>      <span class="hljs-title function_">cleanup</span>();<br>    &#125;<br>    <span class="hljs-comment">// 将 onInvalidate 作为回调函数的第三个参数，以便用户使用</span><br>    <span class="hljs-title function_">cb</span>(newValue, oldValue, onInvalidate);<br>    oldValue = newValue;<br>  &#125;;<br>  <span class="hljs-keyword">const</span> effectFn = <span class="hljs-title function_">effect</span>(<br>    <span class="hljs-comment">// 执行 getter</span><br>    <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">getter</span>(),<br>    &#123;<br>      <span class="hljs-attr">lazy</span>: <span class="hljs-literal">true</span>,<br><br>      <span class="hljs-attr">scheduler</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (options.<span class="hljs-property">flush</span> === <span class="hljs-string">&quot;post&quot;</span>) &#123;<br>          <span class="hljs-keyword">const</span> p = <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>();<br>          p.<span class="hljs-title function_">then</span>(job);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-title function_">job</span>();<br>        &#125;<br>      &#125;,<br>    &#125;<br>  );<br>  <span class="hljs-keyword">if</span> (options.<span class="hljs-property">immediate</span>) &#123;<br>    <span class="hljs-title function_">job</span>();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    oldValue = <span class="hljs-title function_">effectFn</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这段代码中，我们首先定义了 cleanup 变量，这个变量用来存储用户通过 onInvalidate 函数注册的过期回调。可以看到 onInvalidate 函数的实现非常简单，只是把过期回调赋值给了 cleanup 变量。这里的关键点在 job 函数内，每次执行回调函数 cb 之前，先检查是否存在过期回调，如果存在，则执行过期回调函数 cleanup。最后我们把 onInvalidate 函数作为回调函数的第三个参数传递给 cb，以便用户使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">watch</span>(obj, <span class="hljs-keyword">async</span> (newValue, oldValue, onInvalidate) =&gt; &#123;<br>  <span class="hljs-keyword">let</span> expired = <span class="hljs-literal">false</span>;<br>  <span class="hljs-title function_">onInvalidate</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    expired = <span class="hljs-literal">true</span>;<br>  &#125;);<br>  <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&quot;/path/to/request&quot;</span>);<br>  <span class="hljs-keyword">if</span> (!expired) &#123;<br>    finalData = res;<br>  &#125;<br>&#125;);<br><span class="hljs-comment">// 第一次修改</span><br>obj.<span class="hljs-property">foo</span>++;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-comment">// 200ms 后做第二次修改</span><br>  obj.<span class="hljs-property">foo</span>++;<br>&#125;, <span class="hljs-number">200</span>);<br></code></pre></td></tr></table></figure><p><img src="/../../img/vue/vue4/%E5%93%8D%E5%BA%94%E6%95%B0%E6%8D%AE%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B014.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>Vue.js 设计与实现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书分享</tag>
      
      <tag>vue原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Vue.js 设计与实现》第三章 Vue.js 3 的设计思路</title>
    <link href="/2024/03/12/vue/vue3/"/>
    <url>/2024/03/12/vue/vue3/</url>
    
    <content type="html"><![CDATA[<h1 id="第三章-Vue-js-3-的设计思路"><a href="#第三章-Vue-js-3-的设计思路" class="headerlink" title="第三章 Vue.js 3 的设计思路"></a>第三章 Vue.js 3 的设计思路</h1><h2 id="本章内容"><a href="#本章内容" class="headerlink" title="本章内容"></a>本章内容</h2><ul><li>声明式地描述 UI</li><li>初识渲染器</li><li>组件的本质</li><li>模板的工作原理</li></ul><h3 id="知识点回顾"><a href="#知识点回顾" class="headerlink" title="知识点回顾"></a>知识点回顾</h3><p><strong>权衡的艺术：</strong>声明式和命令式、性能和可维护性、运行时和编译时<br><strong>框架设计核心要素：</strong>开发体验、代码体积、错误处理、ts 支持等</p><h2 id="3-1-声明式地描述-UI"><a href="#3-1-声明式地描述-UI" class="headerlink" title="3.1 声明式地描述 UI"></a>3.1 声明式地描述 UI</h2><p>Vue.js 3 是一个声明式的 UI 框架，意思是说用户在使用 Vue.js 3 <strong>开发页面时</strong>是声明式地描述 UI 的</p><h3 id="3-1-1-前端页面涉及到的内容"><a href="#3-1-1-前端页面涉及到的内容" class="headerlink" title="3.1.1 前端页面涉及到的内容"></a>3.1.1 前端页面涉及到的内容</h3><ul><li><code>DOM</code> 元素：例如是 <code>div</code> 标签还是 <code>a</code> 标签。</li><li>属性：如 <code>a</code> 标签的 <code>href</code> 属性，再如 <code>id</code>、<code>class</code> 等通用属性。</li><li>事件：如 <code>click</code>、<code>keydown</code> 等。</li><li>元素的层级结构：<code>DOM</code> 树的层级结构，既有子节点，又有父节点</li></ul><h3 id="3-1-2-怎么用声明式来描述页面呢？"><a href="#3-1-2-怎么用声明式来描述页面呢？" class="headerlink" title="3.1.2 怎么用声明式来描述页面呢？"></a>3.1.2 怎么用声明式来描述页面呢？</h3><ul><li>使用与 <code>HTML</code> 标签一致的方式来描述 DOM 元素，例如描述一个 <code>div</code> 标签时可以使用<code>&lt;div&gt;&lt;/div&gt;</code>；</li><li>使用与 <code>HTML</code> 标签一致的方式来描述属性，例如<code>&lt;divid=&quot;app&quot;&gt;&lt;/div&gt;</code>；</li><li>使用<code>:</code>或 <code>v-bind</code> 来描述动态绑定的属性，例如<code>&lt;div:id=&quot;dynamicId&quot;&gt;&lt;/div&gt;</code>；</li><li>使用<code>@</code>或 <code>v-on</code> 来描述事件，例如点击事件<code>&lt;div@click=&quot;handler&quot;&gt;&lt;/div&gt;</code>；</li><li>使用与 <code>HTML</code> 标签一致的方式来描述层级结构，例如一个具有 <code>span</code> 子节点的 <code>div</code> 标签<code>&lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;</code></li></ul><p>以上其实就是我们 <code>vue</code> 中模板<code>template</code>的写法,除了以上实现，还可以使用 <code>js</code> 对象来描述</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> title = &#123;<br>  <span class="hljs-attr">tag</span>: <span class="hljs-string">&quot;h1&quot;</span>,<br>  <span class="hljs-attr">props</span>: &#123;<br>    <span class="hljs-attr">onClick</span>: handleClick,<br>  &#125;,<br>  <span class="hljs-attr">children</span>: [<br>    &#123;<br>      <span class="hljs-attr">tag</span>: <span class="hljs-string">&quot;span&quot;</span>,<br>      <span class="hljs-attr">children</span>: <span class="hljs-string">&quot;title text&quot;</span>,<br>    &#125;,<br>  ],<br>&#125;;<br></code></pre></td></tr></table></figure><p>对应的 Vue 模板就是：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handleClick&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>title text<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></td></tr></table></figure><p>使用 <code>js</code> 对象来描述的页面其实就是我们所说的虚拟 DOM，所以 Vue.js3 除了支持使用模板描述 UI 外，还支持使用虚拟 DOM 描述 UI</p><p>我们来看下 vue 是怎么支持虚拟 DOM 来描述 UI 的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; h &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;vue&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(<span class="hljs-string">&quot;h1&quot;</span>, &#123; <span class="hljs-attr">onClick</span>: <span class="hljs-function">() =&gt;</span> &#123;&#125; &#125;, [<span class="hljs-title function_">h</span>(<span class="hljs-string">&quot;span&quot;</span>, <span class="hljs-string">&quot;title text&quot;</span>)]);<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>h</code> 函数返回结果就是虚拟 DOM</p><h2 id="3-2-初识渲染器"><a href="#3-2-初识渲染器" class="headerlink" title="3.2 初识渲染器"></a>3.2 初识渲染器</h2><p>渲染器的作用就是把虚拟 DOM 渲染为真实 DOM，如图所示<br><img src="/../../img/vue/vue3/vdom-to-dom.jpg" alt="渲染器的作用"></p><p><strong>h 函数</strong>返回的就是虚拟 DOM</p><p>简单的渲染器实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//渲染器</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">renderer</span>(<span class="hljs-params">vnode, container</span>) &#123;<br>  <span class="hljs-comment">// 使用 vnode.tag 作为标签名称创建 DOM 元素03</span><br>  <span class="hljs-keyword">const</span> el = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(vnode.<span class="hljs-property">tag</span>);<br>  <span class="hljs-comment">// 遍历 vnode.props，将属性、事件添加到 DOM 元素</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> vnode.<span class="hljs-property">props</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^on/</span>.<span class="hljs-title function_">test</span>(key)) &#123;<br>      <span class="hljs-comment">// 如果 key 以 on 开头，说明它是事件</span><br>      el.<span class="hljs-title function_">addEventListener</span>(<br>        key.<span class="hljs-title function_">substr</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">toLowerCase</span>(),<br>        <span class="hljs-comment">// 事件名称 onClick ---&gt;click</span><br>        vnode.<span class="hljs-property">props</span>[key]<br>        <span class="hljs-comment">// 事件处理函数</span><br>      );<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 处理 children</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> vnode.<span class="hljs-property">children</span> === <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>    <span class="hljs-comment">// 如果 children 是字符串，说明它是元素的文本子节点</span><br>    el.<span class="hljs-title function_">appendChild</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(vnode.<span class="hljs-property">children</span>));<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(vnode.<span class="hljs-property">children</span>)) &#123;<br>    <span class="hljs-comment">// 递归地调用 renderer 函数渲染子节点，使用当前元素 el 作为挂载点</span><br>    vnode.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">child</span>) =&gt;</span> <span class="hljs-title function_">renderer</span>(child, el));<br>  &#125;<br>  <span class="hljs-comment">// 将元素添加到挂载点下</span><br>  container.<span class="hljs-title function_">appendChild</span>(el);<br>&#125;<br><span class="hljs-comment">// 虚拟 DOM</span><br><span class="hljs-keyword">const</span> vnode = &#123;<br>  <span class="hljs-attr">tag</span>: <span class="hljs-string">&quot;div&quot;</span>,<br>  <span class="hljs-attr">props</span>: &#123;<br>    <span class="hljs-attr">onClick</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;hello&quot;</span>),<br>  &#125;,<br>  <span class="hljs-attr">children</span>: <span class="hljs-string">&quot;click me&quot;</span>,<br>&#125;;<br><br><span class="hljs-comment">//执行渲染器</span><br><span class="hljs-title function_">renderer</span>(vnode, <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>); <span class="hljs-comment">// body 作为挂载点</span><br></code></pre></td></tr></table></figure><h2 id="3-3-组件的本质"><a href="#3-3-组件的本质" class="headerlink" title="3.3 组件的本质"></a>3.3 组件的本质</h2><p>上面我们初步了解了<code>虚拟DOM</code>和<code>渲染器</code>，我们思考下下面几个问题</p><ul><li>组件是什么？</li><li>组件和虚拟 DOM 有什么关系？</li><li>渲染器如何渲染组件的？</li></ul><p>其实虚拟 DOM 除了能够描述真实 DOM 之外，还能够描述组件，怎么描述组件？想要弄明白这个问题，就需要先搞清楚组件的本质是什么。一句话总结：<strong>组件就是一组 DOM 元素的封装</strong>，这组 DOM 元素就是组件要渲染的内容。</p><p>下面我们使用函数定义一个组件，函数的返回值就是要渲染的内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyComponent</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">tag</span>: <span class="hljs-string">&quot;div&quot;</span>,<br>    <span class="hljs-attr">props</span>: &#123;<br>      <span class="hljs-attr">onClick</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;hello&quot;</span>),<br>    &#125;,<br>    <span class="hljs-attr">children</span>: <span class="hljs-string">&quot;click me&quot;</span>,<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>使用虚拟 DOM 描述组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vnode = &#123;<br>  <span class="hljs-attr">tag</span>: <span class="hljs-title class_">MyComponent</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>有了虚拟 DOM 我们还得借助渲染器：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//渲染器</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">renderer</span>(<span class="hljs-params">vnode, container</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> vnode.<span class="hljs-property">tag</span> === <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>    <span class="hljs-comment">//  vnode 描述的是标签元素</span><br>    <span class="hljs-title function_">mountElement</span>(vnode, container);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> vnode.<span class="hljs-property">tag</span> === <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-comment">//  vnode 描述的是组件</span><br>    <span class="hljs-title function_">mountComponent</span>(vnode, container);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mountElement</span>(<span class="hljs-params">vnode, container</span>) &#123;<br>  <span class="hljs-comment">// 使用 vnode.tag 作为标签名称创建 DOM 元素</span><br>  <span class="hljs-keyword">const</span> el = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(vnode.<span class="hljs-property">tag</span>);<br>  <span class="hljs-comment">// 遍历 vnode.props，将属性、事件添加到 DOM 元素</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> vnode.<span class="hljs-property">props</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/^on/</span>.<span class="hljs-title function_">test</span>(key)) &#123;<br>      <span class="hljs-comment">// 如果 key 以字符串 on 开头，说明它是事件</span><br>      el.<span class="hljs-title function_">addEventListener</span>(<br>        key.<span class="hljs-title function_">substr</span>(<span class="hljs-number">2</span>).<span class="hljs-title function_">toLowerCase</span>(), <span class="hljs-comment">// 事件名称 onClick ---&gt;click</span><br>        vnode.<span class="hljs-property">props</span>[key] <span class="hljs-comment">// 事件处理函数</span><br>      );<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 处理 children</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> vnode.<span class="hljs-property">children</span> === <span class="hljs-string">&quot;string&quot;</span>) &#123;<br>    <span class="hljs-comment">// 如果 children 是字符串，说明它是元素的文本子节点</span><br>    el.<span class="hljs-title function_">appendChild</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(vnode.<span class="hljs-property">children</span>));<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(vnode.<span class="hljs-property">children</span>)) &#123;<br>    <span class="hljs-comment">// 递归地调用 renderer 函数渲染子节点，使用当前元素 el 作为挂载点</span><br>    vnode.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">child</span>) =&gt;</span> <span class="hljs-title function_">renderer</span>(child, el));<br>  &#125;<br>  <span class="hljs-comment">// 将元素添加到挂载点下</span><br>  container.<span class="hljs-title function_">appendChild</span>(el);<br>&#125;<br><br><span class="hljs-comment">//挂在组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mountComponent</span>(<span class="hljs-params">vnode, container</span>) &#123;<br>  <span class="hljs-comment">// 调用组件函数，获取组件要渲染的内容（虚拟 DOM）</span><br>  <span class="hljs-keyword">const</span> subtree = vnode.<span class="hljs-title function_">tag</span>();<br>  <span class="hljs-comment">// 递归地调用 renderer 渲染 subtree</span><br>  <span class="hljs-title function_">renderer</span>(subtree, container);<br>&#125;<br></code></pre></td></tr></table></figure><p>以上我们渲染了一个组件，组件除了是函数之外还可以是一个 JS 对象<br>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">MyComponent</span> = &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> vnode;<br>  &#125;,<br>&#125;;<br><br><span class="hljs-comment">//挂载组件</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mountComponent</span>(<span class="hljs-params">vnode, container</span>) &#123;<br>  <span class="hljs-comment">// 调用组件函数，变更位置</span><br>  <span class="hljs-keyword">const</span> subtree = vnode.<span class="hljs-property">tag</span>.<span class="hljs-title function_">render</span>();<br>  <span class="hljs-comment">// 递归地调用 renderer 渲染 subtree</span><br>  <span class="hljs-title function_">renderer</span>(subtree, container);<br>&#125;<br></code></pre></td></tr></table></figure><p>其实 Vue.js 中的有状态组件就是使用对象结构来表达的</p><p><img src="/../../img/vue/vue3/render.png" alt="组件渲染流程"></p><h2 id="3-4-模板的工作原理"><a href="#3-4-模板的工作原理" class="headerlink" title="3.4 模板的工作原理"></a>3.4 模板的工作原理</h2><p>关于模板的工作， 这就要提到 Vue.js 框架中的另外一个重要组成部分：<strong>编译器</strong></p><p>编译器的作用其实就是将<code>模板</code>编译为<code>渲染函数</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;handler&quot;</span>&gt;</span>click me<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">      <span class="hljs-comment">/* ... */</span></span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">handler</span>: <span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">/* ... */</span></span><br><span class="language-javascript">      &#125;,</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">  &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>通过编译器编译后:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">/* ... */</span><br>  &#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-attr">handler</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">/* ... */</span><br>    &#125;,<br>  &#125;,<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">h</span>(<span class="hljs-string">&quot;div&quot;</span>, &#123; <span class="hljs-attr">onClick</span>: handler &#125;, <span class="hljs-string">&quot;click me&quot;</span>);<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="3-5-Vue-js-是各个模块组成的有机整体"><a href="#3-5-Vue-js-是各个模块组成的有机整体" class="headerlink" title="3.5 Vue.js 是各个模块组成的有机整体"></a>3.5 Vue.js 是各个模块组成的有机整体</h2><p>组件的实现依赖于渲染器，模板的编译依赖于编译器，并且编译后生成的代码是根据渲染器和虚拟 DOM 的设计决定的，<br>因此 Vue.js 的各个模块之间是互相关联、互相制约的，共同构成一个有机整体。因此，我们在学习 Vue.js 原理的时候，应该把各个模块结合到一起去看，才能明白到底是怎么回事。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs gradle">├── packages             <span class="hljs-comment">// vue 源码核心包，使用 pnpm workspace 工作区管理</span><br>│   ├── compiler-core    <span class="hljs-comment">// 编译器（平台无关），例如基础的 baseCompile 编译模版文件, baseParse生成AST</span><br>│   ├── compiler-dom     <span class="hljs-comment">// 基于compiler-core，专为浏览器的编译模块，可以看到它基于baseCompile，baseParse，重写了complie、parse</span><br>│   ├── compiler-sfc     <span class="hljs-comment">// 编译vue单文件组件</span><br>│   ├── compiler-ssr     <span class="hljs-comment">// 服务端渲染编译</span><br>│   ├── reactivity       <span class="hljs-comment">// vue独立的响应式模块，可以与任何框架配合,使用proxy</span><br>│   ├── reactivity-transform  <span class="hljs-comment">// 响应式实验功能，目前仅用于测试</span><br>│   ├── <span class="hljs-keyword">runtime</span>-core     <span class="hljs-comment">// 与平台无关的运行时。有虚拟DOM渲染器，vue组件和各种API。可针对某个具体平台实现高阶runtime，比如自定义渲染器</span><br>│   ├── <span class="hljs-keyword">runtime</span>-dom      <span class="hljs-comment">// 针对浏览器的runtime。包含处理原生DOM API</span><br>│   ├── <span class="hljs-keyword">runtime</span>-test     <span class="hljs-comment">// 一个专门为了测试而写的轻量级 runtime。由于这个 rumtime 「渲染」出的 DOM 树其实是一个 JS 对象，所以这个 runtime 可以用在所有 JS 环境里。你可以用它来测试渲染是否正确。</span><br>│   ├── server-renderer     <span class="hljs-comment">// 服务端渲染</span><br>│   ├── sfc-playground<br>│   ├── shared             <span class="hljs-comment">// 内部工具库,不暴露API</span><br>│   ├── <span class="hljs-keyword">size</span>-check          <span class="hljs-comment">// 简单应用，用来测试代码体积</span><br>│   ├── template-explorer  <span class="hljs-comment">// 用于调试编译器输出的开发工具</span><br>│   └── vue                 <span class="hljs-comment">// 面向公众的完整版本, 包含运行时和编译器</span><br>│   └── vue-compat          <span class="hljs-comment">// 用于兼容 vue2</span><br><br></code></pre></td></tr></table></figure><h2 id="3-6-总结"><a href="#3-6-总结" class="headerlink" title="3.6 总结"></a>3.6 总结</h2><ol><li><p><strong>我们首先介绍了声明式地描述 UI 的概念。</strong><br>我们知道，Vue.js 是一个声明式的框架。声明式的好处在于，它直接描述结果，用户不需要关注过程。Vue.js 采用模板的方式来描述 UI，但它同样支持使用虚拟 DOM 来描述 UI。虚拟 DOM 要比模板更加灵活，但模板要比虚拟 DOM 更加直观</p></li><li><p><strong>然后我们讲解了最基本的渲染器的实现。</strong><br>渲染器的作用是，把虚拟 DOM 对象渲染为真实 DOM 元素。它的工作原理是，递归地遍历虚拟 DOM 对象，并调用原生 DOM API 来完成真实 DOM 的创建。渲染器的精髓在于后续的更新，它会通过 Diff 算法找出变更点，并且只会更新需要更新的内容。后面我们会专门讲解渲染器的相关知识</p></li><li><p><strong>接着，我们讨论了组件的本质。</strong><br>组件其实就是一组虚拟 DOM 元素的封装，它可以是一个返回虚拟 DOM 的函数，也可以是一个对象，但这个对象下必须要有一个函数用来产出组件要渲染的虚拟 DOM。渲染<br>器在渲染组件时，会先获取组件要渲染的内容，即执行组件的渲染函数并得到其返回值，我们称之为 subtree，最后再递归地调用渲染器将 subtree 渲染出来即可</p></li><li><p><strong>Vue.js 的模板会被一个叫作编译器的程序编译为渲染函数</strong></p></li></ol><p><code>编译器</code>、<code>渲染器</code>都是 Vue.js 的核心组成部分，它们共同构成一个有机的整体，不同模块之间互相配合，进一步提升框架性能。</p>]]></content>
    
    
    <categories>
      
      <category>Vue.js 设计与实现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书分享</tag>
      
      <tag>vue原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Vue.js 设计与实现》第一章 权衡的艺术</title>
    <link href="/2024/03/10/vue/vue1/"/>
    <url>/2024/03/10/vue/vue1/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-权衡的艺术"><a href="#第一章-权衡的艺术" class="headerlink" title="第一章 权衡的艺术"></a>第一章 权衡的艺术</h1><blockquote><p>框架设计里到处都体现了权衡的艺术<br>设计一个框架的时候，框架本身的各个模块之间并不是相互独立的，而是相互关联、相互制约的。因此作为框架设计者，一定要对框架的定位和方向拥有全局的把控，这样才能做好后续的模块设计和拆分。</p></blockquote><h2 id="命令式和声明式"><a href="#命令式和声明式" class="headerlink" title="命令式和声明式"></a>命令式和声明式</h2><h3 id="命令式"><a href="#命令式" class="headerlink" title="命令式"></a>命令式</h3><p>关注过程<br>自然语言描述能够与代码产生一一对应的关系，代码本身描述的是“做事的过程”</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// jQuery</span><br>$(<span class="hljs-string">&#x27;#app&#x27;</span>) <span class="hljs-comment">// 获取 div</span><br>.<span class="hljs-title function_">text</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>) <span class="hljs-comment">// 设置文本内容</span><br>.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;ok&#x27;</span>) &#125;) <span class="hljs-comment">// 绑定点击事件</span><br><br><span class="hljs-comment">// js</span><br><span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#app&#x27;</span>) <span class="hljs-comment">// 获取 div</span><br>div.<span class="hljs-property">innerText</span> = <span class="hljs-string">&#x27;hello world&#x27;</span> <span class="hljs-comment">// 设置文本内容</span><br>div.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123; <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;ok&#x27;</span>) &#125;) <span class="hljs-comment">// 绑定点击事 件</span><br></code></pre></td></tr></table></figure><h3 id="声明式"><a href="#声明式" class="headerlink" title="声明式"></a>声明式</h3><p>关注结果<br>不关注过程，只关心结果，vue的内部实现一定是命令式的，暴漏给用户的是声明式的用法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// vue</span><br>&lt;div @click=<span class="hljs-string">&quot;() =&gt; alert(&#x27;ok&#x27;)&quot;</span>&gt;hello world&lt;/div&gt;<br></code></pre></td></tr></table></figure><h2 id="性能与可维护性的权衡"><a href="#性能与可维护性的权衡" class="headerlink" title="性能与可维护性的权衡"></a>性能与可维护性的权衡</h2><p>声明式代码的性能不优于命令式代码的性能</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// A</span><br>div.<span class="hljs-property">textContent</span> = <span class="hljs-string">&#x27;hello vue3&#x27;</span> <span class="hljs-comment">// 直接修改</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// B</span><br><span class="hljs-comment">// 之前:</span><br>&lt;div @click=<span class="hljs-string">&quot;() =&gt; alert(&#x27;ok&#x27;)&quot;</span>&gt;hello world&lt;/div&gt; <br><span class="hljs-comment">// 之后</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;() =&gt; alert(&#x27;ok&#x27;)&quot;</span>&gt;</span>hello vue3<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>命令式代码的更新性能消耗 &#x3D; A<br>声明式代码的更新性能消耗 &#x3D; B + A</p><p>声明式代码可维护性更强，我们只关心最终的结果，具体的实现交给框架来封装</p><p>可维护性和性能的权衡<br>在保持可维护性的同时让性能损失更小化</p><h2 id="虚拟dom的性能到底如何"><a href="#虚拟dom的性能到底如何" class="headerlink" title="虚拟dom的性能到底如何"></a>虚拟dom的性能到底如何</h2><p>虚拟dom的更新技术性能理论上不可能比原生js操作dom更高<br>虚拟dom解决的问题是在保证可维护性的情况下，尽可能的保证应用程序性能的下限，并想办法逐渐逼近命令式代码的性能</p><p><img src="/../img/vue/vue1/inner1.png" alt="创建"></p><p><img src="/../img/vue/vue1/inner2.png" alt="更新"></p><p><img src="/../img/vue/vue1/inner3.png" alt="更新性能"></p><p><img src="/../img/vue/vue1/inner4.png" alt="更新性能比较"></p><h2 id="运行时和编译时"><a href="#运行时和编译时" class="headerlink" title="运行时和编译时"></a>运行时和编译时</h2><p>纯运行时、运行时+编译时、纯编译时</p><h3 id="纯运行时的框架"><a href="#纯运行时的框架" class="headerlink" title="纯运行时的框架"></a>纯运行时的框架</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>  <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;div&#x27;</span>,<br>  <span class="hljs-attr">children</span>: [<br>    &#123; <span class="hljs-attr">tag</span>: <span class="hljs-string">&#x27;span&#x27;</span>, <span class="hljs-attr">children</span>: <span class="hljs-string">&#x27;hello world&#x27;</span> &#125;<br>  ]<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Render</span>(<span class="hljs-params">obj, root</span>) &#123;<br>  <span class="hljs-keyword">const</span> el = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(obj.<span class="hljs-property">tag</span>)<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> obj.<span class="hljs-property">children</span> === <span class="hljs-string">&#x27;string&#x27;</span>) &#123;<br>    <span class="hljs-keyword">const</span> text = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createTextNode</span>(obj.<span class="hljs-property">children</span>)<br>    el.<span class="hljs-title function_">appendChild</span>(text)<br>  &#125; <br><br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (obj.<span class="hljs-property">children</span>) &#123;<br>    <span class="hljs-comment">// 数组，递归调用 Render，使用 el 作为 root 参数</span><br>    obj.<span class="hljs-property">children</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">child</span>) =&gt;</span> <span class="hljs-title class_">Render</span>(child, el))<br>  &#125;<br>  <span class="hljs-comment">// 将元素添加到 root</span><br>  root.<span class="hljs-title function_">appendChild</span>(el)<br>&#125;<br><br><span class="hljs-comment">// 渲染到 body 下</span><br><span class="hljs-title class_">Render</span>(obj, <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>)<br></code></pre></td></tr></table></figure><h3 id="运行时-编译"><a href="#运行时-编译" class="headerlink" title="运行时+编译"></a>运行时+编译</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> html = <span class="hljs-string">`</span><br><span class="hljs-string">&lt;div&gt;</span><br><span class="hljs-string"> &lt;span&gt;hello world&lt;/span&gt;</span><br><span class="hljs-string">&lt;/div&gt;</span><br><span class="hljs-string"> `</span><br><span class="hljs-comment">// 调用 Compiler 编译得到树型结构的数据对象 07 const obj = Compiler(html)</span><br><span class="hljs-comment">// 再调用 Render 进行渲染</span><br><span class="hljs-title class_">Render</span>(obj, <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>)<br></code></pre></td></tr></table></figure><h3 id="孰优孰略"><a href="#孰优孰略" class="headerlink" title="孰优孰略"></a>孰优孰略</h3><p>首先是纯运行时的框架。由于它没有编译的过程，因此我们没办法分析用户提供的内容，但是如果加入编译步骤，可能就大不一样了，我们可以分析用户提供的内容，看看哪些内容未来可能会改变，哪些内容永远不会改变，这样我们就可以在编译的时候提取这些信息，然后将其传递给 Render 函数，Render 函数得到这些信息之后，就可以做进一步的优化了。然而，假如我们设计的框架是纯编译时的，那么它也可以分析用户提供的内容。由于不需要任何运行时，而是直接编译成可执行的 JavaScript 代码，因此性能可能会更好，但是这种做法有损灵活性，即用户提供的内容必须编译后才能用。</p><ul><li>编译时框架   <a href="https://www.svelte.cn/">svelte</a></li><li>运行时+编译时  Vue.js 3</li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue.js 设计与实现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书分享</tag>
      
      <tag>vue原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Vue.js 设计与实现》第二章 框架设计的核心要素</title>
    <link href="/2024/03/10/vue/vue2/"/>
    <url>/2024/03/10/vue/vue2/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-框架设计的核心要素"><a href="#第一章-框架设计的核心要素" class="headerlink" title="第一章 框架设计的核心要素"></a>第一章 框架设计的核心要素</h1><blockquote><p>框架设计里到处都体现了权衡的艺术</p></blockquote><ul><li>框架应该给用户提供哪些构建产物?</li><li>产物的模块格式如何?当用户没有以预期的方式使用框架时，是否应该打印合适的警告信息从而提供更好的开发体验，让用户快速定位问题?</li><li>开发版本的构建和生产版本的构建有何区我们是否也应该考虑?</li><li>框架提供了多个功能，而用户只需要其中几个功能? </li><li>热更新(hot module replacement，HMR)？</li></ul><h2 id="提升用户的开发体验"><a href="#提升用户的开发体验" class="headerlink" title="提升用户的开发体验"></a>提升用户的开发体验</h2><h3 id="警告信息"><a href="#警告信息" class="headerlink" title="警告信息"></a>警告信息</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">createApp</span>(<span class="hljs-title class_">App</span>).<span class="hljs-title function_">mount</span>(<span class="hljs-string">&#x27;#not-exist&#x27;</span>)<br></code></pre></td></tr></table></figure><p><img src="/../../img/vue/vue2/error.jpg" alt="警告"></p><p>快速定位问题</p><h2 id="控制框架代码的体积"><a href="#控制框架代码的体积" class="headerlink" title="控制框架代码的体积"></a>控制框架代码的体积</h2><p>框架的大小也是衡量框架的标准之一。在实现同样功能的情况下，当然是用的代码越少越好，这样体积就会越小，最后浏览器加载资源的时间也就越少。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (__DEV__ &amp;&amp; !res) &#123;<br>   <span class="hljs-title function_">warn</span>(<span class="hljs-string">`Failed to mount app: mount target selector &quot;<span class="hljs-subst">$&#123;container&#125;</span>&quot;eturned null.`</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>vue 使用 rollup进行打包，输出vue.global.js和vue.global.prod.js两个版本，dead code在prod版本中不会存在</p><h2 id="框架要做到良好的Tree-Sharking"><a href="#框架要做到良好的Tree-Sharking" class="headerlink" title="框架要做到良好的Tree-Sharking"></a>框架要做到良好的Tree-Sharking</h2><p>Tree-Shaking 指的就是消除那些永远不会被执行的代码，也就是排除 dead code</p><h3 id="模块必须是ESM-ES-Module"><a href="#模块必须是ESM-ES-Module" class="headerlink" title="模块必须是ESM(ES Module)"></a>模块必须是ESM(ES Module)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// input.js</span><br><span class="hljs-keyword">import</span> &#123; foo &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./utils.js&#x27;</span><br><span class="hljs-title function_">foo</span>()<br><br><span class="hljs-comment">// utils.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">obj</span>) &#123;<br>  obj &amp;&amp; obj.<span class="hljs-property">foo</span><br> &#125;<br> <span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">obj</span>) &#123;<br>   obj &amp;&amp; obj.<span class="hljs-property">bar</span><br>&#125;<br><br><span class="hljs-comment">// npx rollup input.js -f esm -o bundle.js</span><br><br><span class="hljs-comment">// bundle.js</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">obj</span>) &#123;<br>  obj &amp;&amp; obj.<span class="hljs-property">foo</span><br>&#125;<br><span class="hljs-title function_">foo</span>();<br></code></pre></td></tr></table></figure><p>bar 函数作为 dead code 被删除了</p><h3 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h3><p>如果一个函数调用会产生副作用，那么就不能将其移除,<br>副作用就是当调用函数的时候会对外部产生影响</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;foo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./utils&#x27;</span><br><span class="hljs-comment">/*#__PURE__*/</span> <span class="hljs-title function_">foo</span>()<br></code></pre></td></tr></table></figure><p>注释代码 &#x2F;<em>#<strong>PURE</strong></em>&#x2F;，其作用就是告诉 rollup.js，对于 foo 函数的调用不会产生副作用，你可以放心地对其进行 Tree-Shaking，</p><h2 id="框架应该输出怎样的构建产物"><a href="#框架应该输出怎样的构建产物" class="headerlink" title="框架应该输出怎样的构建产物"></a>框架应该输出怎样的构建产物</h2><ul><li>IIFE 格式的资源</li><li>module 格式</li><li>commond js 格式</li></ul><blockquote><p>IIFE 的全称是 Immediately Invoked Function Expression，即“立即调用的 函数表达式”</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;)()<br><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Vue</span> = (<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-built_in">exports</span></span>)&#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-built_in">exports</span>.<span class="hljs-property">createApp</span> = createApp;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">exports</span><br>&#125;(&#123;&#125;))<br></code></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="特性开关"><a href="#特性开关" class="headerlink" title="特性开关"></a>特性开关</h2><p>特性开关的好处</p><ul><li>Tree-sharking 不打包用户关闭的特性</li><li>升级框架时使得打包体积最小化</li></ul><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>框架错误处理机制的好坏直接决定了用户应用程序的健壮性，还决定了用户开发时处理错误的心智负担。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-comment">// utils.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">foo</span>(<span class="hljs-params">fn</span>) &#123;&#125; <br>&#125;<br><br><span class="hljs-comment">// 不处理</span><br><span class="hljs-keyword">import</span> utils <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;utils.js&#x27;</span><br>utils.<span class="hljs-title function_">foo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br> <span class="hljs-comment">// ...</span><br>&#125;)<br><br><span class="hljs-comment">// 初级处理</span><br><span class="hljs-keyword">import</span> utils <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;utils.js&#x27;</span><br>utils.<span class="hljs-title function_">foo</span>(<span class="hljs-function">() =&gt;</span> &#123;<br> <span class="hljs-keyword">try</span> &#123;<br>  <span class="hljs-comment">// ...</span><br> &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br><br> &#125;<br>&#125;)<br><br><span class="hljs-comment">// 统一处理</span><br><span class="hljs-comment">// utils.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">foo</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      fn &amp;&amp; <span class="hljs-title function_">fn</span>()<br>    &#125; <span class="hljs-keyword">catch</span>(e) &#123;<span class="hljs-comment">/* ... */</span>&#125;<br>  &#125;,<br>  <span class="hljs-title function_">bar</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>      fn &amp;&amp; <span class="hljs-title function_">fn</span>()<br>    &#125; <span class="hljs-keyword">catch</span>(e) &#123;<span class="hljs-comment">/* ... */</span>&#125;<br>  &#125;,<br>&#125;<br><br><span class="hljs-comment">// 统一抽离处理错误</span><br><span class="hljs-keyword">let</span> handleError = <span class="hljs-literal">null</span> <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-title function_">foo</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-title function_">callWithErrorHandling</span>(fn)<br>  &#125;,<br>  <span class="hljs-comment">//  用户可以调用该函数注册统一的错误处理函数</span><br>  <span class="hljs-title function_">registerErrorHandler</span>(<span class="hljs-params">fn</span>) &#123;<br>    handleError = fn<br>  &#125;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">callWithErrorHandling</span>(<span class="hljs-params">fn</span>) &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    fn &amp;&amp; <span class="hljs-title function_">fn</span>()<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e)<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">import</span> utils <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;utils.js&#x27;</span> <span class="hljs-number">02</span> <span class="hljs-comment">// 注册错误处理程序</span><br>utils.<span class="hljs-title function_">registerErrorHandler</span>(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// 用户既可以选择忽略错误，也可以调用上报程序将错误上报给监控系统。</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e)<br>&#125;)<br>utils.<span class="hljs-title function_">foo</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-comment">/*...*/</span>&#125;)<br>utils.<span class="hljs-title function_">bar</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-comment">/*...*/</span>&#125;)<br></code></pre></td></tr></table></figure><h2 id="良好的TypeScript类型支持"><a href="#良好的TypeScript类型支持" class="headerlink" title="良好的TypeScript类型支持"></a>良好的TypeScript类型支持</h2>]]></content>
    
    
    <categories>
      
      <category>Vue.js 设计与实现</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书分享</tag>
      
      <tag>vue原理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《JavaScript函数式编程指南》第八章 走管理异步事件以及数据</title>
    <link href="/2024/01/14/functionalProgramming/book8/"/>
    <url>/2024/01/14/functionalProgramming/book8/</url>
    
    <content type="html"><![CDATA[<h1 id="第八章-管理异步事件以及数据"><a href="#第八章-管理异步事件以及数据" class="headerlink" title="第八章 管理异步事件以及数据"></a>第八章 管理异步事件以及数据</h1><h2 id="异步代码的挑战"><a href="#异步代码的挑战" class="headerlink" title="异步代码的挑战"></a>异步代码的挑战</h2><h3 id="函数之间创建时间依赖关系"><a href="#函数之间创建时间依赖关系" class="headerlink" title="函数之间创建时间依赖关系"></a>函数之间创建时间依赖关系</h3><p>当某些函数的执行在逻辑上分组在一起时，会发生时间耦合或时间内聚。这意味着函数需要等待数据可用或需要等待其他函数运行结束才能完成操作。无论是依赖于数据还是时间，这样做都会产生副作用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> student = <span class="hljs-literal">null</span> <br><span class="hljs-title function_">getJSON</span>(<span class="hljs-string">&#x27;/students&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">studentObjs</span>) &#123;<br>  student = studentObjs<br>&#125;,<br><span class="hljs-keyword">function</span> (<span class="hljs-params">errorObj</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(errorObj.<span class="hljs-property">msg</span>)<br>&#125;)<br><span class="hljs-title function_">showStudents</span>(student)<br></code></pre></td></tr></table></figure><h3 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h3><p>回调地狱，其实简单来说就是异步回调函数的嵌套。</p><p>回调的主要用途是避免阻塞UI，防止用户长时间等待IO进程完成。接受回调而不是返回值的函数实现了一种控制反转的形式：“不要打电话给我，我会打给你的”。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">getJSON</span>(<span class="hljs-string">&#x27;/students&#x27;</span>,<br>     <span class="hljs-keyword">function</span> (<span class="hljs-params">students</span>) &#123;  &lt;---第一层嵌套用于包含成功和失败回调的 AJAX 请求<br>       students.sort(function(a, b)&#123;<br>             if(a.ssn &lt; b.ssn) return -1;<br>             if(a.ssn &gt; b.ssn) return 1;<br>             return 0;<br>       &#125;);<br>       for (let i = 0; i &lt; students.length; i++) &#123;<br>         let student = students[i];<br>         if (student.address.country === &#x27;US&#x27;) &#123;<br>            getJSON(`/students/$&#123;student.ssn&#125;/grades`,<br>               function (grades) &#123;  &lt;---收到每个学生的成绩后，需要改写该函数来支持在表格中一个一个地增加学生及其成绩信息<br>                 showStudents(student, average(grades));  &lt;---第二层嵌套用于包含其成功和失败回调的学生成绩获取请求<br>               &#125;,<br>               function (error) &#123;  &lt;---收到每个学生的成绩后，需要改写该函数来支持在表格中一个一个地增<br>加学生及其成绩信息<br>                  console.log(error.message);<br>               &#125;);<br>         &#125;<br>       &#125;<br>     &#125;,<br>     function (error) &#123;<br>        console.log(error.message);  &lt;---第一层嵌套用于包含成功和失败回调的 AJAX 请求<br>   &#125;<br> );<br></code></pre></td></tr></table></figure><p><img src="/../img/callback-hell.png" alt="回调地狱"></p><h3 id="使用持续传递式样"><a href="#使用持续传递式样" class="headerlink" title="使用持续传递式样"></a>使用持续传递式样</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> _selector = <span class="hljs-variable language_">document</span>.<span class="hljs-property">querySelector</span>;<br><br><span class="hljs-title function_">_selector</span>(<span class="hljs-string">&#x27;#search-button&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, handleMouseMovement);<br><br><span class="hljs-keyword">var</span> processGrades = <span class="hljs-keyword">function</span> (<span class="hljs-params">grades</span>) &#123;<br>    <span class="hljs-comment">// ... process list of grades for this student...</span><br>&#125;;<br><br><span class="hljs-keyword">var</span> <span class="hljs-title function_">handleMouseMovement</span> = (<span class="hljs-params"></span>) =&gt;<br>    <span class="hljs-title function_">getJSON</span>(<span class="hljs-string">`/students/<span class="hljs-subst">$&#123;info.ssn&#125;</span>/grades`</span>, processGrades);<br><br><span class="hljs-keyword">var</span> showStudent = <span class="hljs-keyword">function</span> (<span class="hljs-params">info</span>) &#123;<br>   <span class="hljs-title function_">_selector</span>(<span class="hljs-string">&#x27;#student-info&#x27;</span>).<span class="hljs-property">innerHTML</span> = info;<br>   <span class="hljs-title function_">_selector</span>(<span class="hljs-string">&#x27;#student-info&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<br>      <span class="hljs-string">&#x27;mouseover&#x27;</span>, handleMouseMovement);<br>&#125;;<br><br><span class="hljs-keyword">var</span> <span class="hljs-title function_">handleError</span> = error =&gt;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Error occurred&#x27;</span> + error.<span class="hljs-property">message</span>);<br><br><span class="hljs-keyword">var</span> handleClickEvent = <span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) &#123;<br>    event.<span class="hljs-title function_">preventDefault</span>();<br><br>    <span class="hljs-keyword">let</span> ssn = <span class="hljs-title function_">_selector</span>(<span class="hljs-string">&#x27;#student-ssn&#x27;</span>).<span class="hljs-property">value</span>;<br>    <span class="hljs-keyword">if</span>(!ssn) &#123;<br>       <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Valid SSN needed!&#x27;</span>);<br>       <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>       <span class="hljs-title function_">getJSON</span>(<span class="hljs-string">`/students/<span class="hljs-subst">$&#123;ssn&#125;</span>`</span>, showStudent).<span class="hljs-title function_">fail</span>(handleError);<br>    &#125;<br></code></pre></td></tr></table></figure><p>CPS是一种用于非阻塞程序的编程风格，它鼓励开发者将程序分成单个组件，因此它是函数式编程的中间形式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; students.<span class="hljs-property">length</span>; i++) &#123;<br>   <span class="hljs-keyword">let</span> student = students[i];<br>   <span class="hljs-keyword">if</span> (student.<span class="hljs-property">address</span>.<span class="hljs-property">country</span> === <span class="hljs-string">&#x27;US&#x27;</span>) &#123;<br>      <span class="hljs-title function_">getJSON</span>(<span class="hljs-string">`/students/<span class="hljs-subst">$&#123;student.ssn&#125;</span>/grades`</span>,<br>         <span class="hljs-keyword">function</span> (<span class="hljs-params">grades</span>) &#123;<br>            <span class="hljs-title function_">showStudents</span>(student, <span class="hljs-title function_">average</span>(grades));<br>         &#125;,<br>         <span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) &#123;<br>           <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error.<span class="hljs-property">message</span>);<br>         &#125;<br>      );<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../img/csp-res.png" alt="异步函数与同步循环混合的错误命令式代码的运行结果。在获取远程数据时，函数调用将始终引用最后迭代的（闭包中的）学生记录，无论并打印多少次"> </p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><ul><li>使用组合和point-free编程。</li><li>将嵌套结构扁平化为更线性的流程。</li><li>抽象时间耦合的概念，这样就不需要关心它。</li><li>将错误处理整合到单个函数，而不是多个错误回调遍布在业务代码中。</li></ul><h3 id="手写简单的Promise"><a href="#手写简单的Promise" class="headerlink" title="手写简单的Promise"></a>手写简单的Promise</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PENDING</span> = <span class="hljs-string">&#x27;pending&#x27;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">FULFILLED</span> = <span class="hljs-string">&#x27;fulfilled&#x27;</span><br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">REJECT</span> = <span class="hljs-string">&#x27;reject&#x27;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Promise</span> &#123;<br>  <span class="hljs-title function_">constructor</span> () &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">staus</span> = <span class="hljs-variable constant_">PENDING</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallBack</span> = []<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallBack</span> = []<br>    <span class="hljs-keyword">let</span> <span class="hljs-title function_">resolve</span> = (<span class="hljs-params">value</span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">FULFILLED</span> <br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = value<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallBack</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> <span class="hljs-title function_">fn</span>())<br>      &#125;<br>    &#125; <br><br>    <span class="hljs-keyword">let</span> <span class="hljs-title function_">reject</span> = (<span class="hljs-params">reason</span>) =&gt; &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> = <span class="hljs-variable constant_">REJECT</span> <br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span> = reason<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallBack</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> <span class="hljs-title function_">fn</span>())<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-title function_">exector</span>(resolve, reject)<br>    &#125; <span class="hljs-keyword">catch</span>(err) &#123;<br>      <span class="hljs-title function_">reject</span>(err)<br>    &#125;<br>  &#125;<br>  <span class="hljs-title function_">then</span>(<span class="hljs-params">onFulfilled, onRejected</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-title class_">FULFIllED</span>) &#123;<br>      <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">REJECT</span>) &#123;<br>      <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>)<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">onResolvedCallBack</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">onFulfilled</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>))<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">onRejectedCallBack</span>.<span class="hljs-title function_">push</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">reason</span>))<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/../img/promise-1.png" alt="promise1"> </p><h3 id="链接将来的方法"><a href="#链接将来的方法" class="headerlink" title="链接将来的方法"></a>链接将来的方法</h3><p><img src="/../img/promise-2.png" alt="promise2">  </p><h3 id="组合同步和异步行为"><a href="#组合同步和异步行为" class="headerlink" title="组合同步和异步行为"></a>组合同步和异步行为</h3><p><img src="/../img/promise-3.png" alt="promise3"> </p><h2 id="生成惰性数据"><a href="#生成惰性数据" class="headerlink" title="生成惰性数据"></a>生成惰性数据</h2><p>生成器函数通过语言级别的function* 符号定义（是的，带有星号的函数）。这种新型函数可以使用新的关键字yield退出，随后还可以重新进入该上下文（所有本地变量绑定）。</p><ul><li>Generator 函数是一个状态机，封装了多个内部状态。</li><li>Generator 函数返回一个生成器对象，该对象也实现了 Iterator 接口（也可供 for…of 等消费使用），所以具有了 next() 方法。因此，使得生成器对象拥有了开始、暂停和恢复代码执行的能力。</li><li>生成器对象可以用于自定义迭代器和实现协程（coroutine）。</li><li>Generator 函数从字面理解，形式与普通函数很相似。在函数名称前面加一个星号（*），表示它是一个生成器函数。尽管语法上与普通函数相似，但语法行为却完全不同。</li><li>Generator 函数强大之处，感觉很多人没 GET 到。它可以在不同阶段从外部直接向内部注入不同的值来调整函数的行为。<br>生成器对象，是由 Generator 函数返回的，并且它返回可迭代协议和迭代器协议，因此生成器对象是一个可迭代对象。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// async/await 自动执行器</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">runGenerator</span>(<span class="hljs-params">gen</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> g = <span class="hljs-title function_">gen</span>()<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">_next</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">let</span> res<br>      <span class="hljs-keyword">try</span> &#123;<br>        res = g.<span class="hljs-title function_">next</span>(val)<br>      &#125; <span class="hljs-keyword">catch</span>(err) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(err)<br>      &#125;<br>      <span class="hljs-keyword">if</span> (res.<span class="hljs-property">done</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">resolve</span>(res.<span class="hljs-property">value</span>)<br>      &#125;<br>      <span class="hljs-comment">//res.value包装为promise，以兼容yield后面跟基本类型的情况</span><br>      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(res.<span class="hljs-property">value</span>).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;<br>        <span class="hljs-title function_">_next</span>(val)<br>      &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>        g.<span class="hljs-keyword">throw</span>(err)<br>      &#125;)<br>    &#125;<br>    <span class="hljs-title function_">_next</span>()<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="生成器与递归"><a href="#生成器与递归" class="headerlink" title="生成器与递归"></a>生成器与递归</h3><p><img src="/../img/tree.png" alt="tree"> </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span>* <span class="hljs-title class_">TreeTraversal</span>(node) &#123;<br>    <span class="hljs-keyword">yield</span> node.<span class="hljs-property">value</span>;<br>    <span class="hljs-keyword">if</span> (node.<span class="hljs-title function_">hasChildren</span>()) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> child <span class="hljs-keyword">of</span> node.<span class="hljs-property">children</span>) &#123;<br>            <span class="hljs-keyword">yield</span>* <span class="hljs-title class_">TreeTraversal</span>(child);  &lt;---使用 yield*将调用请求代理给生成器自身<br>        &#125;<br>    &#125;<br>&#125;<br><br>var root = node(new Person(&#x27;Alonzo&#x27;, &#x27;Church&#x27;, &#x27;111-11-1231&#x27;));  &lt;---第 3 章中提到， 树的根对象由 Church节点开始<br><br>for(let person of TreeTraversal(root)) &#123;<br>   console.log(person.lastname);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="迭代器协议"><a href="#迭代器协议" class="headerlink" title="迭代器协议"></a>迭代器协议</h3><p>生成器与另一个称为迭代器的ES6特性紧密相连，这也是可以像遍历其他数据结构（如数组）一样遍历生成器的原因。事实上，生成函数返回符合迭代器协议的Generator对象。这意味着它实现一个名为next()的方法，该方法返回使用yield关键字return的值。此对象具有以下属性。</p><p>done ——如果迭代器到达序列结尾，则值为true；否则，值为false，表示迭代器还可以生成下一个值。<br>value  ——迭代器返回的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">range</span>(<span class="hljs-params">start, end</span>) &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>]() &#123;  &lt;---表明返回的对象是一个（实现了迭代器协议的） iterable 对象<br>      return this;<br>    &#125;,<br>    next() &#123;<br>      if(start &lt; end) &#123;<br>        return &#123; value: start++, done:false &#125;;  &lt;---生成器的主要逻辑实现。如果还有可生成的数据，返回一个包含了生成值和 done标志为 false 的对象；否则，done 会被置为 true<br>      &#125;<br>      return &#123; done: true, value:end &#125;;  &lt;---生成器的主要逻辑实现。如果还有可生成的数据，返回一个包含了生成值和 done标志为 false 的对象；否则，done 会被置为 true<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="使用RxJS进行函数式和响应式编程"><a href="#使用RxJS进行函数式和响应式编程" class="headerlink" title="使用RxJS进行函数式和响应式编程"></a>使用RxJS进行函数式和响应式编程</h2><p>响应式思维与函数式思维没有什么不同，只是使用不同的工具集而已。实际上，大部分网络上的响应式编程的文档都是通过介绍函数式编程技术开始的。流带来的是声明式的代码和链式计算。因此，响应式编程倾向于和函数式编程一起使用，从而产生函数式响应式编程（Functional Reactive Programming，FRP）</p>]]></content>
    
    
    <categories>
      
      <category>函数式编程指南</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书分享</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《JavaScript函数式编程指南》第七章 函数式优化</title>
    <link href="/2024/01/03/functionalProgramming/book7/"/>
    <url>/2024/01/03/functionalProgramming/book7/</url>
    
    <content type="html"><![CDATA[<h1 id="第七章-函数式优化"><a href="#第七章-函数式优化" class="headerlink" title="第七章 函数式优化"></a>第七章 函数式优化</h1><h2 id="本章内容"><a href="#本章内容" class="headerlink" title="本章内容"></a>本章内容</h2><blockquote><p>如何识别高性能的函数式代码<br>JavaScript 函数执行的内部机制<br>嵌套函数的背景和递归<br>通过惰性求值优化函数调用<br>使用记忆化（memoization）加速程序执行<br>使用尾递归函数展开递归调用</p></blockquote><p>97%的时候我们应该忽略效率……过早的优化是一切罪恶的根源。然<br>而,我们决不能错过这关键的 3%的优化机会。</p><p>不理解其运行环境就使用新的范式是不明智的<br>函数式编程不会加快单个函数的求值速度</p><h2 id="7-1-函数执行机制"><a href="#7-1-函数执行机制" class="headerlink" title="7.1 函数执行机制"></a>7.1 函数执行机制</h2><h3 id="函数调用栈"><a href="#函数调用栈" class="headerlink" title="函数调用栈"></a>函数调用栈</h3><h4 id="什么是栈？"><a href="#什么是栈？" class="headerlink" title="什么是栈？"></a>什么是栈？</h4><p>栈是一个基本的数据结构，它的插入和取出顺序是后进先出（LIFO）。可以想象成一个个堆叠在一起的碟子：所有操作都只能从最顶部的碟子开始。<br><img src="/../img/book7/%E6%A0%88.gif" alt="栈"></p><h4 id="函数的执行与栈的关系？"><a href="#函数的执行与栈的关系？" class="headerlink" title="函数的执行与栈的关系？"></a>函数的执行与栈的关系？</h4><p>JavaScript 编程模型中的上下文堆栈负责管理函数执行以及关闭变量作用域。堆栈始终从全局执行上下文帧开始，其包含所有全局变量，</p><p>全局上下文帧永远驻留在堆栈的底部。每个函数的上下文帧都占用一定量的内存，实际取决于其中的局部变量的个数。如果没有任何局部变量，一个空帧大约 48 个字节。每个数字或布尔类型的局部变量和参数会占用 8 字节。所以，函数体声明越多的变量，就需要越大的堆栈帧</p><p><strong>注意：函数的作用域链与 JavaScript 对象的原型链不是一回事。虽然两者表现得很类似，但是原型链通过 prototype 属性建立对象继承的链接，而作用域链是指内部函数能访问到外部函数的闭包。</strong></p><h4 id="为什么是栈结构。"><a href="#为什么是栈结构。" class="headerlink" title="为什么是栈结构。"></a>为什么是栈结构。</h4><ul><li>JavaScript 是单线程的，这意味着执行的同步性。</li><li>有且只有一个全局上下文（与所有函数的上下文共享）。</li><li>函数上下文的数量是有限制的（对客户端代码，不同的浏览器可以有不同的限制）。</li><li>每个函数调用会创建一个新的执行上下文，递归调用也是如此</li></ul><h3 id="柯里化的上下文堆栈"><a href="#柯里化的上下文堆栈" class="headerlink" title="柯里化的上下文堆栈"></a>柯里化的上下文堆栈</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> _placeholder = &#123; <span class="hljs-string">&quot;@@functional/placeholder&quot;</span>: <span class="hljs-literal">true</span> &#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">_isPlaceholder</span>(<span class="hljs-params">a</span>) &#123;<br>  <span class="hljs-keyword">return</span> a === _placeholder;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">_curry1</span>(<span class="hljs-params">fn</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">f1</span>(<span class="hljs-params">a</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> === <span class="hljs-number">0</span> || <span class="hljs-title function_">_isPlaceholder</span>(a)) &#123;<br>      <span class="hljs-keyword">return</span> f1;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);<br>    &#125;<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">_curry2</span>(<span class="hljs-params">fn</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">f2</span>(<span class="hljs-params">a, b</span>) &#123;<br>    <span class="hljs-keyword">switch</span> (<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>        <span class="hljs-keyword">return</span> f2;<br>      <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">_isPlaceholder</span>(a)<br>          ? f2<br>          : <span class="hljs-title function_">_curry1</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">_b</span>) &#123;<br>              <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>(a, _b);<br>            &#125;);<br>      <span class="hljs-attr">default</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">_isPlaceholder</span>(a) &amp;&amp; <span class="hljs-title function_">_isPlaceholder</span>(b)<br>          ? f2<br>          : <span class="hljs-title function_">_isPlaceholder</span>(a)<br>          ? <span class="hljs-title function_">_curry1</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">_a</span>) &#123;<br>              <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>(_a, b);<br>            &#125;)<br>          : <span class="hljs-title function_">_isPlaceholder</span>(b)<br>          ? <span class="hljs-title function_">_curry1</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">_b</span>) &#123;<br>              <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>(a, _b);<br>            &#125;)<br>          : <span class="hljs-title function_">fn</span>(a, b);<br>    &#125;<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">const</span> add = <span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">addAll</span>(<span class="hljs-params">arr, fn</span>) &#123;<br>  <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; arr.<span class="hljs-property">length</span>; j++) &#123;<br>      result += <span class="hljs-title function_">fn</span>(arr[i], arr[j]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><span class="hljs-keyword">const</span> c_add = <span class="hljs-title function_">_curry2</span>(add);<br><span class="hljs-comment">//柯里化执行</span><br><span class="hljs-title function_">addAll</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>], c_add);<br><span class="hljs-comment">//非柯里化执行</span><br><span class="hljs-title function_">addAll</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>], add);<br></code></pre></td></tr></table></figure><h3 id="递归的弱点"><a href="#递归的弱点" class="headerlink" title="递归的弱点"></a>递归的弱点</h3><h4 id="递归导致的栈溢出"><a href="#递归导致的栈溢出" class="headerlink" title="递归导致的栈溢出"></a>递归导致的栈溢出</h4><p>函数调用自己时也会创建新的函数上下文。</p><p>永远无法满足结束条件，很容易导致堆栈溢出<br>如果你⻅过错误<code>Range Error: Maximum Call Stack Exceeded or toomuch recursion</code>，就会知道递归有问题了。</p><p>可执行 demo</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params">i</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  <span class="hljs-title function_">increment</span>(++i);<br>&#125;<br><span class="hljs-title function_">increment</span>(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>chrome 最大执行次数： 10438<br><img src="/../img/book7/chrome%E9%80%92%E5%BD%92%E6%9C%80%E5%A4%A7%E9%99%90%E5%BA%A6.gif" alt="chrome递归最大限度"></p><p>小房子 最大执行次数： 25160，但是 5000 以上就很慢了<br><img src="/../img/book7/%E5%B0%8F%E6%88%BF%E5%AD%90%E7%9A%84%E9%80%92%E5%BD%92%E6%9C%80%E5%A4%A7%E9%99%90%E5%BA%A6.gif" alt="小房子的递归最大限度"></p><p>这些数字只是为了说明递归是有限制的。代码预设应该要远远低于这些阈值，否则递归肯定是有问题的。</p><p><strong>vue 的优化</strong> RECURSION_LIMIT:100 次<br>依赖的响应性状态不断地触发改变,从而递归地触发自身渲染。例如：<br>组件模板、渲染函数、更新的钩子或 watch 源函数</p><h4 id="案例：斐波那契"><a href="#案例：斐波那契" class="headerlink" title="案例：斐波那契"></a>案例：斐波那契</h4><p>递归实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fib</span>(<span class="hljs-params">n</span>) &#123;<br>  <span class="hljs-keyword">if</span> (n === <span class="hljs-number">1</span> || n === <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> n - <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">fib</span>(n - <span class="hljs-number">1</span>) + <span class="hljs-title function_">fib</span>(n - <span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-title function_">fib</span>(<span class="hljs-number">6</span>);<br></code></pre></td></tr></table></figure><p><img src="/../img/book7/%E6%96%90%E6%B3%A2%E6%8B%89%E5%A5%91%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8%E6%A0%88.gif" alt="斐波拉契递归调用栈"></p><p>非递归实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fib</span>(<span class="hljs-params">n</span>) &#123;<br>  <span class="hljs-keyword">let</span> a = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">let</span> b = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">let</span> c = a + b;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">3</span>; i &lt; n; i++) &#123;<br>    a = b;<br>    b = c;<br>    c = a + b;<br>  &#125;<br>  <span class="hljs-keyword">return</span> c;<br>&#125;<br><span class="hljs-title function_">fib</span>(<span class="hljs-number">6</span>);<br></code></pre></td></tr></table></figure><p><img src="/../img/book7/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E9%9D%9E%E9%80%92%E5%BD%92%E6%A0%88.gif" alt="斐波那契"></p><p>虽然柯里化和递归导致更多的内存占用，但是鉴于它们带来的灵活性和复用性以及递归解决方案固有的正确性，又感觉这些额外的内存花费是值得的。</p><p>函数式编程还提供了其他范式没有的优化。大量函数推入堆栈会增加程序的内存占用，那么为什么不避免不必要的调用？</p><h2 id="7-2-使用惰性求值推迟执行"><a href="#7-2-使用惰性求值推迟执行" class="headerlink" title="7.2 使用惰性求值推迟执行"></a>7.2 使用惰性求值推迟执行</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p>惰性求值：只会在需要结果的时候才执行<br>贪婪求值：表达式绑定到变量时求值，不管结果是否会被用到</p></blockquote><p>当输入很大但只有一个小的子集有效时，避免不必要的函数调用可以体现出许多性能优势</p><ul><li>避免不必要的计算。</li><li>使用函数式类库</li></ul><h3 id="使用函数式组合子避免重复计算"><a href="#使用函数式组合子避免重复计算" class="headerlink" title="使用函数式组合子避免重复计算"></a>使用函数式组合子避免重复计算</h3><p>在最简单的情况下，可以通过只传递函数引用（或名称），然后有条件地选择调用或不调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> alt = R.<span class="hljs-title function_">curry</span>(<span class="hljs-function">(<span class="hljs-params">func1, func2, val</span>) =&gt;</span> <span class="hljs-title function_">func1</span>(val) || <span class="hljs-title function_">func2</span>(val));<br><span class="hljs-keyword">const</span> showStudent = R.<span class="hljs-title function_">compose</span>(<span class="hljs-title function_">append</span>(<span class="hljs-string">&quot;#student-info&quot;</span>), <span class="hljs-title function_">alt</span>(findStudent, createNewStudent));<br><span class="hljs-comment">//没有函数会过早地调用，因为组合子使用的只是它们的函数引用</span><br><span class="hljs-title function_">showStudent</span>(<span class="hljs-string">&quot;444-44-4444&quot;</span>);<br></code></pre></td></tr></table></figure><p>以上案例是避免不必要计算的简单方法之一</p><p>如果在运行前就定义好程序，就可以使用函数式库的 shortcut fusion 技术来优化</p><h3 id="利用-shortcut-fusion-快捷方式融合"><a href="#利用-shortcut-fusion-快捷方式融合" class="headerlink" title="利用 shortcut fusion(快捷方式融合)"></a>利用 shortcut fusion(快捷方式融合)</h3><blockquote><p>shortcut fusion 是一种合并迭代调用的优化策略;这有助于避免创建中间数据结构，并大大减少迭代执行的次数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">pricelt</span>(<span class="hljs-params">x</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) &#123;<br>    <span class="hljs-keyword">return</span> item.<span class="hljs-property">price</span> &lt; x;<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">var</span> gems = [<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Sunstone&quot;</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">4</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Amethyst&quot;</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">15</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Prehnite&quot;</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">20</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Sugilite&quot;</span>, <span class="hljs-attr">prrice</span>: <span class="hljs-number">7</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Diopside&quot;</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">3</span> &#125;,<br><br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Feldspar&quot;</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">13</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Dioptase&quot;</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">2</span> &#125;,<br>  &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Sapphire&quot;</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">20</span> &#125;,<br>];<br><br><span class="hljs-keyword">var</span> chosen = <span class="hljs-title function_">_</span>(gems).<span class="hljs-title function_">filter</span>(<span class="hljs-title function_">pricelt</span>(<span class="hljs-number">10</span>)).<span class="hljs-title function_">take</span>(<span class="hljs-number">3</span>).<span class="hljs-title function_">value</span>();<br></code></pre></td></tr></table></figure><p><img src="/../img/book7/s1.gif" alt="常规执行"><br><img src="/../img/book7/s2.gif" alt="shortcut fusion"></p><ul><li><code>_(gems)</code>拿到数据集，缓存起来</li><li>遇到 <code>filter</code> 方法，先记下来</li><li>遇到 <code>take</code> 方法，先记下来</li><li>遇到 <code>value</code> 方法，说明时机到了</li><li>把小本本拿出来，看下要求：要取出 3 个数，<code>price&lt;10</code></li><li>使用 <code>filter</code> 方法里的判断方法 priceLt 对数据进行逐个裁决</li></ul><h4 id="lodash-的-shortcut-fusion"><a href="#lodash-的-shortcut-fusion" class="headerlink" title="lodash 的 shortcut fusion"></a>lodash 的 shortcut fusion</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-variable constant_">MAX_ARRAY_LENGTH</span> = <span class="hljs-number">4294967295</span>; <span class="hljs-comment">// 最大的数组长度</span><br><br><span class="hljs-comment">// 缓存数据结构体</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">LazyWrapper</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">__wrapped__</span> = value;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">__iteratees__</span> = [];<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">__takeCount__</span> = <span class="hljs-variable constant_">MAX_ARRAY_LENGTH</span>;<br>&#125;<br><br><span class="hljs-comment">// 惰性求值的入口</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">lazy</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LazyWrapper</span>(value);<br>&#125;<br></code></pre></td></tr></table></figure><p>实现 filter</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">ar <span class="hljs-variable constant_">LAZY_FILTER_FLAG</span> = <span class="hljs-number">1</span>; <span class="hljs-comment">// filter方法的标记</span><br><br><span class="hljs-comment">// 根据 筛选方法iteratee 筛选数据</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">filter</span>(<span class="hljs-params">iteratee</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">__iteratees__</span>.<span class="hljs-title function_">push</span>(&#123;<br>        <span class="hljs-string">&#x27;iteratee&#x27;</span>: iteratee,<br>        <span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-variable constant_">LAZY_FILTER_FLAG</span><br>    &#125;);<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>&#125;<br><br><span class="hljs-comment">// 绑定方法到原型链上</span><br><span class="hljs-title class_">LazyWrapper</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">filter</span> = filter;<br></code></pre></td></tr></table></figure><p>take 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 截取n个数据</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">take</span>(<span class="hljs-params">n</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">__takeCount__</span> = n;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>;<br>&#125;<br><br><span class="hljs-title class_">LazyWrapper</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">take</span> = take;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 惰性求值</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">lazyValue</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">var</span> array = <span class="hljs-variable language_">this</span>.<span class="hljs-property">__wrapped__</span>;<br>  <span class="hljs-keyword">var</span> length = array.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">var</span> resIndex = <span class="hljs-number">0</span>;<br>  <span class="hljs-keyword">var</span> takeCount = <span class="hljs-variable language_">this</span>.<span class="hljs-property">__takeCount__</span>;<br>  <span class="hljs-keyword">var</span> iteratees = <span class="hljs-variable language_">this</span>.<span class="hljs-property">__iteratees__</span>;<br>  <span class="hljs-keyword">var</span> iterLength = iteratees.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">var</span> index = -<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">var</span> dir = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">var</span> result = [];<br><br>  <span class="hljs-comment">// 标签语句</span><br>  <span class="hljs-attr">outer</span>: <span class="hljs-keyword">while</span> (length-- &amp;&amp; resIndex &lt; takeCount) &#123;<br>    <span class="hljs-comment">// 外层循环待处理的数组</span><br>    index += dir;<br><br>    <span class="hljs-keyword">var</span> iterIndex = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">var</span> value = array[index];<br><br>    <span class="hljs-keyword">while</span> (++iterIndex &lt; iterLength) &#123;<br>      <span class="hljs-comment">// 内层循环处理链上的方法</span><br>      <span class="hljs-keyword">var</span> data = iteratees[iterIndex];<br>      <span class="hljs-keyword">var</span> iteratee = data.<span class="hljs-property">iteratee</span>;<br>      <span class="hljs-keyword">var</span> type = data.<span class="hljs-property">type</span>;<br>      <span class="hljs-keyword">var</span> computed = <span class="hljs-title function_">iteratee</span>(value);<br><br>      <span class="hljs-comment">// 处理数据不符合要求的情况</span><br>      <span class="hljs-keyword">if</span> (!computed) &#123;<br>        <span class="hljs-keyword">if</span> (type == <span class="hljs-variable constant_">LAZY_FILTER_FLAG</span>) &#123;<br>          <span class="hljs-keyword">continue</span> outer;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-keyword">break</span> outer;<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 经过内层循环，符合要求的数据</span><br>    result[resIndex++] = value;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-title class_">LazyWrapper</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">value</span> = lazyValue;<br></code></pre></td></tr></table></figure><p>Lodash 还有一些其他带有 shortcut fusion 优化的函数，如<code>_.drop</code>、<code>_.dropRight</code>、<code>_.dropRightWhile</code>、<code>_.dropWhile</code>、<code>_.first</code>、<code>_.initial</code>、<code>_.last</code>、<code>_.pluck</code>、<code>_.reject</code>、<code>_.rest</code>、<code>_.reverse</code>、<code>_.slice</code>、<code>_.takeRight</code>、<code>_.takeRightWhile</code>、<code>_.takeWhile</code>和<code>_.where</code>。</p><p>除此之外，函数式还有另一种避免重复计算的技术：记忆化（memorization）。</p><h2 id="7-3-实现需要时调用的策略"><a href="#7-3-实现需要时调用的策略" class="headerlink" title="7.3 实现需要时调用的策略"></a>7.3 实现需要时调用的策略</h2><p>加快应用程序执行的方法之一是避免计算重复值，特别是当这些计算的代价昂贵时。在传统的面向对象系统中，这可以通过在函数调用前检查高速缓存或代理层来实现。在返回时，给函数的结果赋予唯一的键值并持久化到缓存中。缓存作为耗时操作之前查询的中介或记忆体。</p><p>记忆化的方案与缓存类似。它就像以前的代码中，基于函数的参数创建与之对应的唯一的键，并将结果值存储到对应的键上，当再次遇到相同参数的函数时，立即返回存储的结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">memoized</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">//内部的工具方法负责为当前函数实例创建缓存逻辑</span><br>  <span class="hljs-keyword">let</span> key = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-variable language_">arguments</span>); <span class="hljs-comment">//将参数字符串化以获得对当前函数调用的键值。可以通过检测输入类型来创建更加鲁棒的键值生成方法。这只是一个简单的例子</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_cache</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_cache</span> || &#123;&#125;; <span class="hljs-comment">//为当前函数实例创建一个内部的缓存</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_cache</span>[key] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_cache</span>[key] || <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>); <span class="hljs-comment">//先试图读取缓存，通过输入来判断是否计算过。如果找到对应的值，则跳过函数调用直接返回；否则，执行计算</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_cache</span>[key];<br>&#125;;<br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">memoize</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-comment">//激活函数的记忆化</span><br>  <span class="hljs-keyword">let</span> fn = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-keyword">if</span> (fn.<span class="hljs-property">length</span> === <span class="hljs-number">0</span> || fn.<span class="hljs-property">length</span> &gt; <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> fn; <span class="hljs-comment">//只尝试记忆化一元函数</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> fn.<span class="hljs-property">memoized</span>.<span class="hljs-title function_">apply</span>(fn, <span class="hljs-variable language_">arguments</span>); <span class="hljs-comment">//将函数实体包裹在记忆化函数中</span><br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="案例阶乘"><a href="#案例阶乘" class="headerlink" title="案例阶乘"></a>案例阶乘</h3><p><code>n! = n* (n– 1) * (n– 2) * ... * 3 * 2 * 1</code></p><p><strong>注意：阶乘数是可以通过更小的阶乘数递归定义的，比如 <code>4!=4*3!</code></strong></p><p>无记忆的阶乘</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">jc</span>(<span class="hljs-params">n</span>) &#123;<br>  <span class="hljs-keyword">return</span> n === <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : n * <span class="hljs-title function_">jc</span>(n - <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-title function_">jc</span>(<span class="hljs-number">2</span>);<br><span class="hljs-title function_">jc</span>(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p><img src="/../img/book7/%E9%98%B6%E4%B9%98-%E6%97%A0%E8%AE%B0%E5%BF%86.gif" alt="阶乘-无记忆"></p><p>有记忆的阶乘</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">memoized</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> key = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(<span class="hljs-variable language_">arguments</span>);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_cache</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_cache</span> || &#123;&#125;;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">_cache</span>[key] = <span class="hljs-variable language_">this</span>.<span class="hljs-property">_cache</span>[key] || <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_cache</span>[key];<br>&#125;;<br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">memoize</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> fn = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-keyword">if</span> (fn.<span class="hljs-property">length</span> === <span class="hljs-number">0</span> || fn.<span class="hljs-property">length</span> &gt; <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> fn;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> fn.<span class="hljs-property">memoized</span>.<span class="hljs-title function_">apply</span>(fn, <span class="hljs-variable language_">arguments</span>);<br>  &#125;;<br>&#125;;<br><span class="hljs-keyword">const</span> factorial = <span class="hljs-keyword">function</span> <span class="hljs-title function_">jc</span>(<span class="hljs-params">n</span>) &#123;<br>  <span class="hljs-keyword">return</span> n === <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : n * <span class="hljs-title function_">factorial</span>(n - <span class="hljs-number">1</span>);<br>&#125;.<span class="hljs-title function_">memoize</span>();<br><span class="hljs-title function_">factorial</span>(<span class="hljs-number">2</span>);<br><span class="hljs-title function_">factorial</span>(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><p><img src="/../img/book7/%E9%98%B6%E4%B9%98-%E6%9C%89%E8%AE%B0%E5%BF%86.gif" alt="阶乘-有记忆"></p><p>第二次运行的速度比第一次快</p><h2 id="7-4-递归和尾递归优化"><a href="#7-4-递归和尾递归优化" class="headerlink" title="7.4 递归和尾递归优化"></a>7.4 递归和尾递归优化</h2><h3 id="尾部调用优化"><a href="#尾部调用优化" class="headerlink" title="尾部调用优化"></a>尾部调用优化</h3><blockquote><p>尾部调用优化（TCO）也称为尾部调用消除,是 ES6 添加的编译器增强功能。同时，在最后的位置调用别的函数也可以优化（虽然通常是本身），该调用位置称为尾部位置（尾递归因此而得名）</p></blockquote><p>这为什么算是一种优化？函数的最后一件事情如果是递归的函数调用，那么运行时会认为不必要保持当前的栈帧，因为所有工作已经完成，完全可以抛弃当前帧。在大多数情况下，只有将函数的上下文状态作为参数传递给下一个函数调用（正如在递归阶乘函数处看到的），才能使递归调用不需要依赖当前帧。通过这种方式，递归每次都会创建一个新的帧，回收旧的帧，而不是将新的帧叠在旧的上。</p><p><img src="/../img/book7/%E5%B0%BE%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8%E6%A8%A1%E5%BC%8F%E5%8F%98%E5%8C%96.png" alt="尾递归调用模式变化"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">jc</span>(<span class="hljs-params">n, current = <span class="hljs-number">1</span></span>) &#123;<br>  <span class="hljs-keyword">return</span> n === <span class="hljs-number">1</span> ? current : <span class="hljs-title function_">jc</span>(n - <span class="hljs-number">1</span>, n * current); <span class="hljs-comment">// 函数最后一条语句是下一次递归（即处于尾部）</span><br>&#125;<br><span class="hljs-title function_">jc</span>(<span class="hljs-number">2</span>);<br><span class="hljs-title function_">jc</span>(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure><h3 id="将非尾递归转换成尾递归"><a href="#将非尾递归转换成尾递归" class="headerlink" title="将非尾递归转换成尾递归"></a>将非尾递归转换成尾递归</h3><p>这是尾递归吗？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">factorial</span> = (<span class="hljs-params">n</span>) =&gt; (n === <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : n * <span class="hljs-title function_">factorial</span>(n - <span class="hljs-number">1</span>));<br></code></pre></td></tr></table></figure><p>递归调用并没有发生在尾部，因为最后返回的表达式是<code>n *factorial(n - 1)</code>。切记，<strong>最后一个步骤一定要是递归</strong>，这样才会在运行时 TCO 将 factorial 转换成一个循环。改成尾递归只需要两步。</p><ul><li>1）将当前乘法结果当作参数传入递归函数。</li><li>2）使用 ES6 的默认参数给定一个默认值（也可以部分地应用它们，但默认参数会让代码更整洁）</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">ES5 中模仿尾递归调用<br><br>目前主流的 <span class="hljs-keyword">JavaScript </span>实现 ES5 并不具备尾调用优化支持。ES6 将其加<br>入被称为适当尾调用的提案（在 ECMA<span class="hljs-number">-262</span> 规范的 <span class="hljs-number">14</span>.<span class="hljs-number">6</span> 部分）。还记得第 <span class="hljs-number">2</span><br>章中使用的 <span class="hljs-keyword">Babel </span>转译器（源代码到源代码的编译器）吗？那是用来测<br>试语言新特性的绝佳方式。<br><br>还有一种解决方式是使用 trampolining。trampolining 可以用迭代的方式模拟尾递归，<br>所以可以非常理想、容易地控制<span class="hljs-keyword">JavaScript </span>的堆栈。<br><br>trampoline 是一个接受函数的函数，它会多次调用函数，直到满足一<br>定的条件。一个可反弹或者重复的函数被封装在 thunk 结构中。thunk 只不<br>过是多了一层函数包裹。在函数式 <span class="hljs-keyword">JavaScript </span>背景下，可以用 thunk 及简单<br>的匿名函数包裹期望惰性求值的值。<br><br>thunk 和 trampolining 的话题已经超出了本书的范围，如果读者非常希<br>望用这些技术来优化递归函数，可以从这个概念开始展开研究<br></code></pre></td></tr></table></figure><p>如果需要一个图形渲染一个大型的数据，那么性能就成为一项关键要求。在这种情况下，开发者就可能需要做出取舍，即可能不需要编写优雅、可扩展的代码，而需要快速地完成工作。</p><h2 id="7-5-总结"><a href="#7-5-总结" class="headerlink" title="7.5 总结"></a>7.5 总结</h2><ul><li>在某些情况下，函数式代码可能比与其等效的命令式代码更慢或消耗的内存更多。</li><li>可以利用交替组合子以及函数式库（如 Lodash）中提供的支持来实施延迟策略。</li><li>memoization（内部函数级缓存策略）可用于避免重复对潜在费时函数进行求值。</li><li>将程序分解成简单的函数不仅可以创建可扩展代码，还可以通过记忆化来使其更高效。</li><li>递归可以通过分解把问题化为更简单的自相似问题，继而充分利用记忆化优化上下文堆栈的使用。</li><li>将函数转换为尾递归形式，就可以借助编译器优化消除尾调用。</li></ul><h2 id="推荐工具"><a href="#推荐工具" class="headerlink" title="推荐工具"></a>推荐工具</h2><p><a href="https://www.jsv9000.app/">事件循环可视化工具：https://www.jsv9000.app/</a><br><a href="https://www.npmjs.com/package/memoize">记忆函数：https://www.npmjs.com/package/memoize</a><br><a href="https://www.npmjs.com/package/promise-memoize">异步缓存：https://www.npmjs.com/package/promise-memoize</a></p>]]></content>
    
    
    <categories>
      
      <category>函数式编程指南</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书分享</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《JavaScript函数式编程指南》第六章 坚不可摧的代码</title>
    <link href="/2023/12/28/functionalProgramming/book6/"/>
    <url>/2023/12/28/functionalProgramming/book6/</url>
    
    <content type="html"><![CDATA[<h1 id="第六章-坚不可摧的代码"><a href="#第六章-坚不可摧的代码" class="headerlink" title="第六章 坚不可摧的代码"></a>第六章 坚不可摧的代码</h1><h2 id="本章内容"><a href="#本章内容" class="headerlink" title="本章内容"></a>本章内容</h2><blockquote><p>函数式编程会如何改变测试⽅式<br>认识到测试命令式代码的挑战<br>使⽤ QUnit 测试函数式代码<br>JSCheck 探索属性测试<br>使⽤ Blanket 测量程序的复杂性</p></blockquote><h2 id="函数式编程对单元测试的影响"><a href="#函数式编程对单元测试的影响" class="headerlink" title="函数式编程对单元测试的影响"></a>函数式编程对单元测试的影响</h2><blockquote><p>通常有 3 种测试类型：单元测试、集成测试和验收测试。在测试⾦字塔（⻅图 1）中，从验收测试（顶部）到单元测试（底部），函数式编程的影响越来越⼤。这是⾮常显⽽易⻅的，因为函数式编程是⼀种专注于函数和模块，及其组合的软件开发模式</p></blockquote><p><img src="/../img/book6/fn1.png" alt="图1"></p><blockquote><p>函数式编程的真正重点当然是函数、模块单元以及它们之间的交互。本书选取的测试库是流⾏的 QUnit。单元测试的基本结构如下：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">QUnit</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;Test Find Person&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">assert</span>) &#123;<br>  <span class="hljs-keyword">const</span> ssn = <span class="hljs-string">&quot;444-44-4444&quot;</span>;<br>  <span class="hljs-keyword">const</span> p = <span class="hljs-title function_">findPerson</span>(ssn);<br>  assert.<span class="hljs-title function_">equal</span>(p.<span class="hljs-property">ssn</span>, ssn);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="测试命令式代码的困难"><a href="#测试命令式代码的困难" class="headerlink" title="测试命令式代码的困难"></a>测试命令式代码的困难</h2><blockquote><p>测试命令式代码和写命令式代码⼀样难受。测试命令式代码是真正的挑战，因为它基于全局状态与变化，⽽不是控制数据流，再在其中加⼊计算。设计单元测试的其中⼀个主要原则是隔离。单元测试应该不需要察觉到周围其他测试或数据，但代码中的副作⽤使得这⼀原则很难履⾏。</p></blockquote><p>命令式代码的特点如下:</p><ul><li>很难识别或拆分成简单任务</li><li>依赖于共享资源，使得测试结果不⼀致</li><li>强⾏预定义求值的顺序</li></ul><h3 id="难以识别和分解任务"><a href="#难以识别和分解任务" class="headerlink" title="难以识别和分解任务"></a>难以识别和分解任务</h3><blockquote><p>本书前⾯提到的 showStudent 的命令式版本，图 2 尝试将它分割成⼀些部分。<br><img src="/../img/book6/fn2.png" alt="图2"><br>可以看到，该程序由紧密耦合的业务逻辑组成，业务在各个⽅⾯都与程序相互联系。完全没有理由让数据验证、获取学⽣记录以及修改 DOM 耦合在⼀起。这些完全可以拆成单独的业务单元再组合进来。此外，通过第 5 章的介绍，错误处理逻辑应该⽤ Monad 来分离处理</p></blockquote><h3 id="对共享资源的依赖会导致结果不⼀致"><a href="#对共享资源的依赖会导致结果不⼀致" class="headerlink" title="对共享资源的依赖会导致结果不⼀致"></a>对共享资源的依赖会导致结果不⼀致</h3><blockquote><p>下⾯⽤⼀个简单点的例⼦进⾏说明。回想⼀下命令式的 increment 函数：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span>; <span class="hljs-comment">// (global)</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> ++counter;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以写⼀个简单的单元测试，使其返回 1。但是如果运⾏ 100 次，返回的还是 1 吗？因为该函数修改依赖来⾃外部的数据（⻅图 3）:<br><img src="/../img/book6/fn3.png" alt="图3"></p><p>因为第⼀次修改了外部计数器变量，依赖于同样变量的第⼆次测试⾃然不会再返回 1，所以第⼆次测试失败了。同理，有副作⽤的函数也容易因顺序变化⽽发⽣错误。</p><h3 id="按预定义顺序执⾏"><a href="#按预定义顺序执⾏" class="headerlink" title="按预定义顺序执⾏"></a>按预定义顺序执⾏</h3><blockquote><p>单元测试应该是符合交换律的，意思是说，即使改变测试运⾏的顺序，也不应该对结果有任何影响。跟前⾯的原因⼀样，不纯的函数也不符合这⼀原则。要解决此问题，单元测试库，例如 QUnit 含有⼀些在建⽴和关闭时可以配置全局测试环境的外部机制。但⼀个测试的设置可能会跟另⼀个完全不同的，所以不得不在每个测试开始时设⽴先决条件。这也意味着，对于每个测试，测试⼈员需要负责识别被测代码中的所有副作⽤（外部依赖）。</p></blockquote><p>为了说明这⼀点，先创建⼀个 increment 的简单测试来验证其对负数、零和正数的⾏为（⻅图 4）。在第⼀次运⾏时（左侧图），所有测试都通过了。当随机打乱测试（右侧图）的顺序后，第⼆测试失败。这是因为测试运⾏在建⽴好的周边状态的假设上<br><img src="/../img/book6/fn4.png" alt="图4"></p><p>就算把每⼀个测试的状态都设置正确，让测试通过，但也不能保证它们的位置。只需要简单换⼀下位置，就⾜以让所有断⾔失效。<br>运⽤函数式的思维有助于构建可靠的测试。如果代码是函数式⻛格，这些好处将不请⾃来。预期往测试代码中硬塞函数式原则，还不如⼀开始就投⼊时间写函数式的代码。下⾯来看测试函数式代码的好处</p><h2 id="测试函数式代码"><a href="#测试函数式代码" class="headerlink" title="测试函数式代码"></a>测试函数式代码</h2><p>测试函数式代码的好处如下</p><ul><li>把函数当作⿊盒⼦</li><li>专注于业务逻辑，⽽不是控制流</li><li>使⽤ Monadic 隔离纯和不纯的代码</li></ul><h3 id="把函数当作⿊盒⼦"><a href="#把函数当作⿊盒⼦" class="headerlink" title="把函数当作⿊盒⼦"></a>把函数当作⿊盒⼦</h3><blockquote><p>函数式编程⿎励以松耦合的⽅式对⼀组输⼊做处理，使其与应⽤程序的其余部分相独⽴。这些函数⽆副作⽤，引⽤透明，因此不管调⽤多少次，也不管以什么样的顺序测试，都可以很容易地预测测试结果。这样就可以把函数作为⿊盒⼦，只专注于由给定的输⼊断⾔相应的输出。测试 showStudent 函数的代价与测试 increment 函数是⼀个级别的，如图 5 所⽰。<br><img src="/../img/book6/fn5.png" alt="图5"></p></blockquote><h3 id="专注于业务逻辑，⽽不是控制流"><a href="#专注于业务逻辑，⽽不是控制流" class="headerlink" title="专注于业务逻辑，⽽不是控制流"></a>专注于业务逻辑，⽽不是控制流</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fork = <span class="hljs-keyword">function</span> (<span class="hljs-params">join, func1, func2</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">join</span>(<span class="hljs-title function_">func1</span>(val), <span class="hljs-title function_">func2</span>(val));<br>  &#125;;<br>&#125;;<br><span class="hljs-keyword">const</span> toLetterGrade = <span class="hljs-keyword">function</span> (<span class="hljs-params">grade</span>) &#123;<br>  <span class="hljs-keyword">if</span> (grade &gt;= <span class="hljs-number">90</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;A&quot;</span>;<br>  <span class="hljs-keyword">if</span> (grade &gt;= <span class="hljs-number">80</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;B&quot;</span>;<br>  <span class="hljs-keyword">if</span> (grade &gt;= <span class="hljs-number">70</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;C&quot;</span>;<br>  <span class="hljs-keyword">if</span> (grade &gt;= <span class="hljs-number">60</span>) <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;D&quot;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;F&quot;</span>;<br>&#125;;<br><span class="hljs-keyword">const</span> computeAverageGrade = R.<span class="hljs-title function_">compose</span>(<br>  toLetterGrade,<br>  <span class="hljs-title function_">fork</span>(R.<span class="hljs-property">divide</span>, R.<span class="hljs-property">sum</span>, R.<span class="hljs-property">length</span>)<br>);<br><span class="hljs-title class_">QUnit</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;Compute Average Grade&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">assert</span>) &#123;<br>  assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">computeAverageGrade</span>([<span class="hljs-number">80</span>, <span class="hljs-number">90</span>, <span class="hljs-number">100</span>]), <span class="hljs-string">&quot;A&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>该程序⽤了许多简单的函数，如 Ramda 的 R.divide 、R.sum 和 R.length， 还⽤了⾃定义函数组合⼦ fork ，再将其结果与<br>toLetterGrade 组合。Ramda 提供的函数已经测试过了，因此没有必要⾃⼰再测⼀遍。这也是使⽤函数式库带来的好处，所以剩下需要做的只是写 toLetterGrade 的单元测试：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">QUnit</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;Compute Average Grade: toLetterGrade&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">assert</span>) &#123;<br>  assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">toLetterGrade</span>(<span class="hljs-number">90</span>), <span class="hljs-string">&quot;A&quot;</span>);<br>  assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">toLetterGrade</span>(<span class="hljs-number">200</span>), <span class="hljs-string">&quot;A&quot;</span>);<br>  assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">toLetterGrade</span>(<span class="hljs-number">80</span>), <span class="hljs-string">&quot;B&quot;</span>);<br>  assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">toLetterGrade</span>(<span class="hljs-number">89</span>), <span class="hljs-string">&quot;B&quot;</span>);<br>  assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">toLetterGrade</span>(<span class="hljs-number">70</span>), <span class="hljs-string">&quot;C&quot;</span>);<br>  assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">toLetterGrade</span>(<span class="hljs-number">60</span>), <span class="hljs-string">&quot;D&quot;</span>);<br>  assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">toLetterGrade</span>(<span class="hljs-number">59</span>), <span class="hljs-string">&quot;F&quot;</span>);<br>  assert.<span class="hljs-title function_">equal</span>(<span class="hljs-title function_">toLetterGrade</span>(-<span class="hljs-number">10</span>), <span class="hljs-string">&quot;F&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="使⽤-Monadic-式从不纯的代码中分离出纯函数"><a href="#使⽤-Monadic-式从不纯的代码中分离出纯函数" class="headerlink" title="使⽤ Monadic 式从不纯的代码中分离出纯函数"></a>使⽤ Monadic 式从不纯的代码中分离出纯函数</h3><blockquote><p>Monad 是一个自函子范畴上的幺半群，Monad 本身是一个非常简 单的东西, 像是 Rust 中的 Option 一样, 一旦理解, 就发现再也回不去之前没有他的世界了. Monad 并不仅局限于函数式编程语言, 也可以用其他的语言来表示.</p></blockquote><p>函数式编程的⽬的是让业务减少导致副作⽤的函数（如 IO），这样就可以增加应⽤程序逻辑的可测范围，同时解耦不需要负<br>责的 IO 边界测试。再来看 showStudent 的函数式版本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> showStudent = R.<span class="hljs-title function_">compose</span>(<br>  <span class="hljs-title function_">map</span>(<span class="hljs-title function_">append</span>(<span class="hljs-string">&quot;#student-info&quot;</span>)),<br>  liftIO,<br>  <span class="hljs-title function_">getOrElse</span>(<span class="hljs-string">&quot;unable to find student&quot;</span>),<br>  <span class="hljs-title function_">map</span>(csv),<br>  <span class="hljs-title function_">map</span>(R.<span class="hljs-title function_">props</span>([<span class="hljs-string">&quot;ssn&quot;</span>, <span class="hljs-string">&quot;firstname&quot;</span>, <span class="hljs-string">&quot;lastname&quot;</span>])),<br>  <span class="hljs-title function_">chain</span>(findStudent),<br>  <span class="hljs-title function_">chain</span>(checkLengthSsn),<br>  <span class="hljs-title function_">lift</span>(cleanInput)<br>);<br></code></pre></td></tr></table></figure><p>仔细对照函数式版本和⾮函数式版本的代码，就会发现函数式版本是如何使⽤组合和 Monad 来拆分命令式版本的。这样做⽴刻扩⼤了 showStudent 的可测试范围，并且清楚地识别与分离了纯和不纯的函数（见图 6）</p><blockquote><p><img src="/../img/book6/fn6.png" alt="图6"></p></blockquote><h2 id="通过代码覆盖率衡量有效性"><a href="#通过代码覆盖率衡量有效性" class="headerlink" title="通过代码覆盖率衡量有效性"></a>通过代码覆盖率衡量有效性</h2><h3 id="衡量有效输⼊的函数式代码的有效性"><a href="#衡量有效输⼊的函数式代码的有效性" class="headerlink" title="衡量有效输⼊的函数式代码的有效性"></a>衡量有效输⼊的函数式代码的有效性</h3><p>⾸先看⼀下命令式 showStudent 的代码覆盖统计数据。⽤ Blanket 和 QUnit 对这段代码进⾏测试.<br>运⾏下⾯的测试</p><p>命令式代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">showStudent</span>(<span class="hljs-params">ssn</span>) &#123;<br>  <span class="hljs-keyword">if</span> (ssn != <span class="hljs-literal">null</span>) &#123;<br>    ssn = ssn.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^\s*|\-|\s*$/g</span>, <span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">if</span> (ssn.<span class="hljs-property">length</span> !== <span class="hljs-number">9</span>) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Invalid Input&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">let</span> student = db.<span class="hljs-title function_">get</span>(ssn);<br>    <span class="hljs-keyword">if</span> (student) &#123;<br>      <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">`#<span class="hljs-subst">$&#123;elementId&#125;</span>`</span>).<span class="hljs-property">innerHTML</span> = <span class="hljs-string">`<span class="hljs-subst">$&#123;student.ssn&#125;</span>,</span><br><span class="hljs-string"> <span class="hljs-subst">$&#123;student.firstname&#125;</span>,</span><br><span class="hljs-string"> <span class="hljs-subst">$&#123;student.lastname&#125;</span>`</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Student not found!&quot;</span>);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Invalid SSN!&quot;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// test</span><br><span class="hljs-title class_">QUnit</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;Imperative showStudent with valid user&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">assert</span>) &#123;<br>  <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">showStudent</span>(<span class="hljs-string">&quot;444-44-4444&quot;</span>);<br>  assert.<span class="hljs-title function_">equal</span>(result, <span class="hljs-string">&quot;444-44-4444, Alonzo, Church&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>图 7 所⽰的 QUnit &#x2F;Blanket 声明式代码输出表明，语句的覆盖百分⽐为 80%。</p><blockquote><p><img src="/../img/book6/fn7.png" alt="图7"></p></blockquote><p>函数式代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> trim = <span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) &#123;<br>  <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^\s*|\s*$/g</span>, <span class="hljs-string">&quot;&quot;</span>);<br>&#125;;<br><span class="hljs-keyword">var</span> normalize = <span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) &#123;<br>  <span class="hljs-keyword">return</span> str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\-/g</span>, <span class="hljs-string">&quot;&quot;</span>);<br>&#125;;<br><span class="hljs-keyword">var</span> cleanInput = R.<span class="hljs-title function_">compose</span>(R.<span class="hljs-title function_">tap</span>(trace), normalize, R.<span class="hljs-title function_">tap</span>(trace), trim);<br><span class="hljs-keyword">var</span> csv = <span class="hljs-keyword">function</span> (<span class="hljs-params">columns</span>) &#123;<br>  <span class="hljs-keyword">return</span> columns.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;, &quot;</span>);<br>&#125;;<br><span class="hljs-keyword">var</span> safeFetchRecord = R.<span class="hljs-title function_">curry</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">store, studentId</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Either</span>.<span class="hljs-title function_">fromNullable</span>(store.<span class="hljs-title function_">get</span>(studentId)).<span class="hljs-title function_">getOrElseThrow</span>(<br>    <span class="hljs-string">&quot;Student not found with ID:&quot;</span> + studentId<br>  );<br>&#125;);<br><span class="hljs-keyword">var</span> validLength = <span class="hljs-keyword">function</span> (<span class="hljs-params">len, str</span>) &#123;<br>  <span class="hljs-keyword">return</span> str.<span class="hljs-property">length</span> === len;<br>&#125;;<br><span class="hljs-keyword">var</span> checkLengthSsn = <span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Either</span>.<span class="hljs-title function_">of</span>(str)<br>    .<span class="hljs-title function_">filter</span>(validLength.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-number">9</span>))<br>    .<span class="hljs-title function_">getOrElseThrow</span>(<span class="hljs-string">&quot;Input:&quot;</span> + str + <span class="hljs-string">&quot;is not a valid SSN number&quot;</span>);<br>&#125;;<br><span class="hljs-keyword">var</span> fundStudent = <span class="hljs-title function_">safeFetchRecord</span>(<span class="hljs-title function_">DB</span>(<span class="hljs-string">&quot;students&quot;</span>));<br><span class="hljs-keyword">const</span> showStudent = R.<span class="hljs-title function_">compose</span>(<br>  <span class="hljs-title function_">map</span>(<span class="hljs-title function_">append</span>(<span class="hljs-string">&quot;#student-info&quot;</span>)),<br>  liftIO,<br>  <span class="hljs-title function_">getOrElse</span>(<span class="hljs-string">&quot;unable to find student&quot;</span>),<br>  <span class="hljs-title function_">map</span>(csv),<br>  <span class="hljs-title function_">map</span>(R.<span class="hljs-title function_">props</span>([<span class="hljs-string">&quot;ssn&quot;</span>, <span class="hljs-string">&quot;firstname&quot;</span>, <span class="hljs-string">&quot;lastname&quot;</span>])),<br>  <span class="hljs-title function_">chain</span>(findStudent),<br>  <span class="hljs-title function_">chain</span>(checkLengthSsn),<br>  <span class="hljs-title function_">lift</span>(cleanInput)<br>);<br><br><span class="hljs-comment">// test</span><br><span class="hljs-title class_">QUnit</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&quot;Imperative showStudent with valid user&quot;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">assert</span>) &#123;<br>  <span class="hljs-keyword">const</span> result = <span class="hljs-title function_">showStudent</span>(<span class="hljs-string">&quot;444-44-4444&quot;</span>).<span class="hljs-title function_">run</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><p>图 8 所⽰的 QUnit &#x2F;Blanket 声明式代码输出表明，测试函数式代码覆盖率⾼达100%</p><blockquote><p><img src="/../img/book6/fn8.png" alt="图8"></p></blockquote><p>但是如果只⽤合法数据来测试，为什么错误处理的逻辑也能覆盖到呢？这就是Monad的神奇之处，它可以⽆缝地在整个程序中传递空值（使⽤Either.Left 或者Maybe.Nothing ），因此每个函数得以运⾏，但映射函数中的逻辑被跳过。函数式代码的灵活性都⾮常显著</p><h3 id="衡量⽆效输⼊的命令式代码和函数式代码的有效性"><a href="#衡量⽆效输⼊的命令式代码和函数式代码的有效性" class="headerlink" title="衡量⽆效输⼊的命令式代码和函数式代码的有效性"></a>衡量⽆效输⼊的命令式代码和函数式代码的有效性</h3><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog">QUnit<span class="hljs-variable">.test</span>(&#x27;Imperative Show Student <span class="hljs-keyword">with</span> <span class="hljs-literal">null</span>&#x27;, <span class="hljs-keyword">function</span> (<span class="hljs-keyword">assert</span>) &#123;<br> <span class="hljs-keyword">const</span> result = showStudent(<span class="hljs-literal">null</span>);<br> <span class="hljs-keyword">assert</span><span class="hljs-variable">.equal</span>(result, <span class="hljs-literal">null</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>所有被跳过的逻辑区域如图9.1所⽰</p><blockquote><p><img src="/../img/book6/fn9-1.png" alt="图9.1"><br>showStudent 的代码跳过了所有合法输⼊的路径，得到了⾮常低的40%的覆盖率。</p></blockquote><p>出现这种结果是因为控制流的if-else 块的存在，它导致了不同的分⽀，也导致了函数的复杂。<br>相⽐之下，函数式的null 处理更为优雅些，因为它避免了直接处理⾮法输⼊（⽐如null ）的逻辑。整个程序的结构（函数之间的交互）都⽆须做出任何调整，就可以成功地进⾏调⽤和测试。⼀旦有错误，函数式代码的输出会是Nothing 。开发者完全不必要检查null输出，只需要下⾯这个测试就⾜够了：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs verilog">QUnit<span class="hljs-variable">.test</span>(&#x27;Functional Show Student <span class="hljs-keyword">with</span> <span class="hljs-literal">null</span>&#x27;, <span class="hljs-keyword">function</span> (<span class="hljs-keyword">assert</span>) &#123;<br> <span class="hljs-keyword">const</span> result = showStudent(<span class="hljs-literal">null</span>)<span class="hljs-variable">.run</span>();<br> <span class="hljs-keyword">assert</span><span class="hljs-variable">.ok</span>(result<span class="hljs-variable">.isNothing</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>所有被跳过的逻辑区域如图9.2所⽰</p><blockquote><p><img src="/../img/book6/fn9-2.png" alt="图9.2"><br>函数式版本的showStudent 跳过操作数据的区域，这些区域对于合法输⼊会执⾏<br>但即使对于⽆效数据，函数式程序也不仅仅是跳过整段代码的执⾏。它优雅地、安全地在Monad中传递⽆效状态，覆盖率仍然能达到80%（两倍命令式代码）</p></blockquote><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>依赖于简单函数抽象的程序是模块化的。</li><li>基于纯函数的模块化的代码很容易测试</li><li>型测试⽅法，如基于属性的测试。</li><li>可测试的代码⼀定是简单的控制流。</li><li>简单的控制流可以降低整个程序的复杂度</li><li>降低复杂度的代码更容易推理。</li></ul>]]></content>
    
    
    <categories>
      
      <category>函数式编程指南</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书分享</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《JavaScript函数式编程指南》第五章 针对复杂应用的设计模式</title>
    <link href="/2023/12/12/functionalProgramming/book5/"/>
    <url>/2023/12/12/functionalProgramming/book5/</url>
    
    <content type="html"><![CDATA[<h1 id="第五章-针对复杂应用的设计模式"><a href="#第五章-针对复杂应用的设计模式" class="headerlink" title="第五章 针对复杂应用的设计模式"></a>第五章 针对复杂应用的设计模式</h1><h2 id="本章内容"><a href="#本章内容" class="headerlink" title="本章内容"></a>本章内容</h2><blockquote><p>设么是函子(Functor)<br>函子的用途<br>常用的函子</p></blockquote><h2 id="什么是函子-Functor"><a href="#什么是函子-Functor" class="headerlink" title="什么是函子(Functor)"></a>什么是函子(Functor)</h2><blockquote><p>在百科里面的定义：在范畴论中，函子是两个范畴之间的一种映射。函子可以看作是范畴论中的态射（morphism）的推广。函子可以将一个范畴A中的对象映射到另一个范畴B中的对象，同时也将A中的态射映射到B中的态射。函子还必须满足一些特定的性质，即保持范畴论中的同一性和复合性。函子在数学分析、代数拓扑、微分几何、表示论、数理逻辑、类型理论、编程语言等领域中都有应用。</p></blockquote><blockquote><p>在函数式编程里面：函子是一种受规则约束的数据类型，其中包含值(value)和值的变形关系(函数)。函子可以看作是一个容器，它包含了值，通过变形关系，我们可以在容器里面的值上加一些额外的操作，从而变形成另外一个容器。函子的价值在于，我们可以通过同样的变形关系，对不同的容器进行变形。这里的变形关系就是函数，函子就是函数式编程里面的函数。</p></blockquote><blockquote><p>具体的理解：函子是一种特殊的容器，通过一个普通的对象来实现，该对象具有map方法，map方法可以运行一个函数对值进行处理(变形关系)并返回一个包含新值的函子，该函子包含了处理后的值。</p></blockquote><h2 id="函子的用途"><a href="#函子的用途" class="headerlink" title="函子的用途"></a>函子的用途</h2><blockquote><p>它是一种新的函数组合方式，可以链式调用，可以用于约束传输的数据结构，可以映射适配函数的输出值与下一个函数输入值，可以一定程度上避免函数执行的副作用，当然除了这个之外我们还可以通过函子去控制异常，来进行异步操作等等。</p></blockquote><h2 id="常用的函子"><a href="#常用的函子" class="headerlink" title="常用的函子"></a>常用的函子</h2><h3 id="函子的基础定义"><a href="#函子的基础定义" class="headerlink" title="函子的基础定义"></a>函子的基础定义</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 函子</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Functor</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">val</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = val;<br>  &#125;<br>  <span class="hljs-title function_">map</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Functor</span>(<span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>));<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = (<span class="hljs-params">x</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">value</span>: x + <span class="hljs-number">1</span> &#125;;<br>&#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">double</span> = (<span class="hljs-params">x</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">value</span>: x * <span class="hljs-number">2</span> &#125;;<br>&#125;;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">square</span> = (<span class="hljs-params">x</span>) =&gt; &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">value</span>: <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(x, <span class="hljs-number">2</span>),<br>  &#125;;<br>&#125;;<br><br><span class="hljs-keyword">const</span> functor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Functor</span>(<span class="hljs-number">2</span>);<br><span class="hljs-keyword">const</span> result = functor<br>  .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">d</span>) =&gt;</span> <span class="hljs-title function_">add</span>(d))<br>  .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">d</span>) =&gt;</span> <span class="hljs-title function_">double</span>(d.<span class="hljs-property">value</span>))<br>  .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">d</span>) =&gt;</span> <span class="hljs-title function_">square</span>(d.<span class="hljs-property">value</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result.<span class="hljs-property">value</span>); <span class="hljs-comment">// &#123;value: 36&#125;</span><br></code></pre></td></tr></table></figure><blockquote><p>函数式编程的运算不直接操作值，而是由函子来完成。所有函子都有一个map对象。通过map方法访问里面的值，然后返回一个新的函子，这样就可以链式调用map方法了。</p></blockquote><h3 id="Pointed-函子"><a href="#Pointed-函子" class="headerlink" title="Pointed 函子"></a>Pointed 函子</h3><blockquote><p>Pointed 函子是实现了 of 静态方法的函子，of 方法是为了避免使用 new 来创建对象，使用 of 方法来替代 new 来创建对象，生成一个函子，使代码更具有一致性。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pointed</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Functor</span> &#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">of</span>(<span class="hljs-params">val</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Pointed</span>(val);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> res2 = <span class="hljs-title class_">Pointed</span>.<span class="hljs-title function_">of</span>(<span class="hljs-number">2</span>)<br>  .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">d</span>) =&gt;</span> <span class="hljs-title function_">add</span>(d))<br>  .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">d</span>) =&gt;</span> <span class="hljs-title function_">double</span>(d.<span class="hljs-property">value</span>))<br>  .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">d</span>) =&gt;</span> <span class="hljs-title function_">square</span>(d.<span class="hljs-property">value</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res2.<span class="hljs-property">value</span>); <span class="hljs-comment">// &#123;value: 36&#125;</span><br></code></pre></td></tr></table></figure><h3 id="MayBe-函子"><a href="#MayBe-函子" class="headerlink" title="MayBe 函子"></a>MayBe 函子</h3><blockquote><p>MayBe 函子是用来解决空值问题的，它的 of 方法判断传入的值是否为空，如果为空则返回一个空函子，如果不为空则返回一个包含传入值的函子，用来控制因为空值而导致的异常，引起的副作用。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Maybe 函子 用来解决空值的问题</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Maybe</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Functor</span> &#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">of</span>(<span class="hljs-params">val</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Maybe</span>(val);<br>  &#125;<br>  <span class="hljs-title function_">isNothing</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> === <span class="hljs-literal">null</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> === <span class="hljs-literal">undefined</span>;<br>  &#125;<br>  <span class="hljs-title function_">map</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isNothing</span>() ? <span class="hljs-variable language_">this</span> : <span class="hljs-title class_">Maybe</span>.<span class="hljs-title function_">of</span>(<span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>));<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> res3 = <span class="hljs-title class_">Maybe</span>.<span class="hljs-title function_">of</span>(<span class="hljs-number">2</span>)<br>  .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">d</span>) =&gt;</span> <span class="hljs-title function_">add</span>(d))<br>  .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">d</span>) =&gt;</span> <span class="hljs-title function_">double</span>(d.<span class="hljs-property">value</span>))<br>  .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">d</span>) =&gt;</span> <span class="hljs-title function_">square</span>(d.<span class="hljs-property">value</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res3.<span class="hljs-property">value</span>); <span class="hljs-comment">// &#123;value: 36&#125;</span><br><br><span class="hljs-keyword">const</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Holmes&quot;</span>,<br>  <span class="hljs-attr">address</span>: &#123;<br>    <span class="hljs-attr">street</span>: <span class="hljs-string">&quot;Baker Street&quot;</span>,<br>    <span class="hljs-attr">number</span>: <span class="hljs-string">&quot;221B&quot;</span>,<br>  &#125;,<br>&#125;;<br><br><span class="hljs-keyword">const</span> street = user &amp;&amp; user.<span class="hljs-property">address</span> &amp;&amp; user.<span class="hljs-property">address</span>.<span class="hljs-property">street</span>;<br><br><span class="hljs-keyword">const</span> res4 = <span class="hljs-title class_">Maybe</span>.<span class="hljs-title function_">of</span>(user)<br>  .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">user</span>) =&gt;</span> user.<span class="hljs-property">address</span>)<br>  .<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">address</span>) =&gt;</span> address.<span class="hljs-property">street</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res4.<span class="hljs-property">value</span>); <span class="hljs-comment">// Baker Street</span><br></code></pre></td></tr></table></figure><h3 id="Either-函子"><a href="#Either-函子" class="headerlink" title="Either 函子"></a>Either 函子</h3><blockquote><p>Either 函子是用来解决异常问题的，它的 of 方法判断传入的值是否为异常，如果是异常则返回一个包含异常信息的函子，如果不是异常则返回一个包含传入值的函子，用来控制因异常而导致的副作用。有两个值 left 和 right 用来表示错误和正确的值。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Either 函子 用来解决异常处理的问题 有两个值 left 和 right 用来表示错误和正确的值</span><br><span class="hljs-comment">// 主要用于两个用途： 代替条件运算(if...else)，提供默认值 代替异常处理(try...catch)，捕捉详细的错误信息</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Either</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Functor</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">left, right</span>) &#123;<br>    <span class="hljs-variable language_">super</span>();<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">left</span> = left;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">right</span> = right;<br>  &#125;<br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">of</span>(<span class="hljs-params">left, right</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Either</span>(left, right);<br>  &#125;<br>  <span class="hljs-title function_">isNothing</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">right</span> === <span class="hljs-literal">null</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">right</span> === <span class="hljs-literal">undefined</span>;<br>  &#125;<br>  <span class="hljs-title function_">map</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isNothing</span>()<br>      ? <span class="hljs-title class_">Either</span>.<span class="hljs-title function_">of</span>(<span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">left</span>), <span class="hljs-variable language_">this</span>.<span class="hljs-property">right</span>)<br>      : <span class="hljs-title class_">Either</span>.<span class="hljs-title function_">of</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">left</span>, <span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">right</span>));<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> res5 = <span class="hljs-title class_">Either</span>.<span class="hljs-title function_">of</span>(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x * <span class="hljs-number">2</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res5); <span class="hljs-comment">// Either &#123; value: null, left: 2, right: 10 &#125;</span><br><br><span class="hljs-comment">// 解析 JSON 字符串</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">parseJson</span>(<span class="hljs-params">jsonStr</span>) &#123;<br>  <span class="hljs-keyword">let</span> rst = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">let</span> err = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">try</span> &#123;<br>    rst = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(jsonStr);<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    err = e;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Either</span>.<span class="hljs-title function_">of</span>(err, rst);<br>&#125;<br><br><span class="hljs-comment">// =&gt; Either &#123; value: null, left: &#x27;SYNTAXERROR&#x27;, right: null &#125;</span><br><span class="hljs-keyword">const</span> res6 = <span class="hljs-title function_">parseJson</span>(<span class="hljs-string">&#x27;&#123;name:&quot;Lucy&quot;&#125;&#x27;</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> val.<span class="hljs-property">name</span>.<span class="hljs-title function_">toUpperCase</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res6); <span class="hljs-comment">// Either &#123; value: null, left: &#x27;SYNTAXERROR&#x27;, right: null &#125;</span><br><span class="hljs-comment">// =&gt; Either &#123; value: null, left: null, right: &#x27;LUCY&#x27; &#125;</span><br><span class="hljs-keyword">const</span> res7 = <span class="hljs-title function_">parseJson</span>(<span class="hljs-string">&#x27;&#123;&quot;name&quot;:&quot;Lucy&quot;&#125;&#x27;</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> val.<span class="hljs-property">name</span>.<span class="hljs-title function_">toUpperCase</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res7); <span class="hljs-comment">// Either &#123; value: null, left: null, right: &#x27;LUCY&#x27; &#125;</span><br></code></pre></td></tr></table></figure><h3 id="Monad-函子"><a href="#Monad-函子" class="headerlink" title="Monad 函子"></a>Monad 函子</h3><blockquote><p>Monad 函子是用来解决函子嵌套问题的，它的 of 方法判断传入的值是否为函子，如果是函子则返回一个包含传入值的函子，如果不是函子则返回一个包含传入值的函子，用来控制因函子嵌套而导致的副作用。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Monad 函子 用来解决函子嵌套的问题</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Monad</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Functor</span> &#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">of</span>(<span class="hljs-params">val</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Monad</span>(val);<br>  &#125;<br><br>  <span class="hljs-title function_">isNothing</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> === <span class="hljs-literal">null</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> === <span class="hljs-literal">undefined</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">map</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isNothing</span>()) <span class="hljs-keyword">return</span> <span class="hljs-title class_">Monad</span>.<span class="hljs-title function_">of</span>(<span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">let</span> rst = <span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Monad</span>.<span class="hljs-title function_">of</span>(rst);<br>  &#125;<br><br>  <span class="hljs-title function_">join</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">flatMap</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">map</span>(fn).<span class="hljs-title function_">join</span>();<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> res9 = <span class="hljs-title class_">Monad</span>.<span class="hljs-title function_">of</span>(<span class="hljs-number">3</span>).<span class="hljs-title function_">flatMap</span>(<span class="hljs-function">(<span class="hljs-params">n</span>) =&gt;</span> <span class="hljs-title class_">Monad</span>.<span class="hljs-title function_">of</span>(n + <span class="hljs-number">2</span>));<br><span class="hljs-keyword">const</span> res10 = <span class="hljs-title class_">Maybe</span>.<span class="hljs-title function_">of</span>(<span class="hljs-number">3</span>).<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">n</span>) =&gt;</span> <span class="hljs-title class_">Maybe</span>.<span class="hljs-title function_">of</span>(n + <span class="hljs-number">2</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res9); <span class="hljs-comment">// Monad &#123; value: 5 &#125;</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res10); <span class="hljs-comment">// Maybe &#123; value: &#123; value: 5 &#125; &#125;</span><br></code></pre></td></tr></table></figure><h3 id="IO-函子"><a href="#IO-函子" class="headerlink" title="IO 函子"></a>IO 函子</h3><blockquote><p>IO 函子是用来控制副作用的，它的 of 方法判断传入的值是否为函数，如果是函数则返回一个包含传入值的函子，如果不是函数则返回一个包含传入值的函子，用来控制因副作用而导致的副作用。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// IO 函子 用来解决副作用的问题</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IO</span> &#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">of</span>(<span class="hljs-params">val</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">IO</span>(<span class="hljs-function">() =&gt;</span> val);<br>  &#125;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">val</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = val;<br>  &#125;<br><br>  <span class="hljs-title function_">map</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">isNothing</span>()) <span class="hljs-keyword">return</span> <span class="hljs-variable constant_">IO</span>.<span class="hljs-title function_">of</span>(<span class="hljs-literal">null</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">IO</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">value</span>()));<br>  &#125;<br><br>  <span class="hljs-title function_">isNothing</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> === <span class="hljs-literal">null</span> || <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> === <span class="hljs-literal">undefined</span>;<br>  &#125;<br><br>  <span class="hljs-title function_">join</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">value</span>();<br>  &#125;<br><br>  <span class="hljs-title function_">flatMap</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title function_">IO</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">value</span>()).<span class="hljs-title function_">join</span>());<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readFile</span> = (<span class="hljs-params">name</span>) =&gt;<br>  <span class="hljs-keyword">new</span> <span class="hljs-title function_">IO</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;readFile&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`请求并返回<span class="hljs-subst">$&#123;name&#125;</span>文件内容`</span>;<br>  &#125;);<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">format</span> = (<span class="hljs-params">info</span>) =&gt;<br>  <span class="hljs-keyword">new</span> <span class="hljs-title function_">IO</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;format&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`格式化内容(&quot;<span class="hljs-subst">$&#123;info&#125;</span>&quot;)`</span>;<br>  &#125;);<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">print</span> = (<span class="hljs-params">info</span>) =&gt;<br>  <span class="hljs-keyword">new</span> <span class="hljs-title function_">IO</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;print&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`打印格式化后的内容：<span class="hljs-subst">$&#123;info&#125;</span>`</span>;<br>  &#125;);<br><br><span class="hljs-comment">// 并没有执行</span><br><span class="hljs-keyword">const</span> readAndPrint = <span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;book.pdf&quot;</span>).<span class="hljs-title function_">flatMap</span>(format).<span class="hljs-title function_">flatMap</span>(print);<br><br>readAndPrint.<span class="hljs-title function_">join</span>();<br></code></pre></td></tr></table></figure><h3 id="Task-函子"><a href="#Task-函子" class="headerlink" title="Task 函子"></a>Task 函子</h3><blockquote><p>Task 函子是用来控制异步的，它的 of 方法判断传入的值是否为函数，如果是函数则返回一个包含传入值的函子，如果不是函数则返回一个包含传入值的函子，用来控制因异步而导致的副作用。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Task 函子 用来解决异步的问题</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> &#123;<br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">of</span>(<span class="hljs-params">val</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-title function_">resolve</span>(val));<br>  &#125;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = fn;<br>  &#125;<br><br>  <span class="hljs-title function_">map</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">value</span>(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-title function_">fn</span>(val)));<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-title function_">join</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">value</span>(<span class="hljs-function">(<span class="hljs-params">task</span>) =&gt;</span> task.<span class="hljs-title function_">value</span>(resolve));<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-title function_">flatMap</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">map</span>(fn).<span class="hljs-title function_">join</span>();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">readFile</span> = (<span class="hljs-params">name</span>) =&gt;<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;readFile&quot;</span>);<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">`请求并返回<span class="hljs-subst">$&#123;name&#125;</span>文件内容`</span>);<br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;);<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">format</span> = (<span class="hljs-params">info</span>) =&gt;<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;format&quot;</span>);<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">`格式化内容(&quot;<span class="hljs-subst">$&#123;info&#125;</span>&quot;)`</span>);<br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;);<br><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">print</span> = (<span class="hljs-params">info</span>) =&gt;<br>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;print&quot;</span>);<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-title function_">resolve</span>(<span class="hljs-string">`打印格式化后的内容：<span class="hljs-subst">$&#123;info&#125;</span>`</span>);<br>    &#125;, <span class="hljs-number">1000</span>);<br>  &#125;);<br>  <br><span class="hljs-comment">// 并没有执行</span><br><span class="hljs-keyword">const</span> readAndPrint = <span class="hljs-title function_">readFile</span>(<span class="hljs-string">&quot;book.pdf&quot;</span>).<span class="hljs-title function_">flatMap</span>(format).<span class="hljs-title function_">flatMap</span>(print);<br><br><span class="hljs-comment">// 执行</span><br>readAndPrint.<span class="hljs-title function_">value</span>(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(val)); <span class="hljs-comment">// 打印格式化后的内容：格式化内容(&quot;请求并返回book.pdf文件内容&quot;)</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>函子是一种特殊的容器，通过一个普通的对象来实现，该对象具有map方法，map方法可以运行一个函数对值进行处理(变形关系)并返回一个包含新值的函子，该函子包含了处理后的值。它是一种新的函数组合方式，可以链式调用，可以用于约束传输的数据结构，可以映射适配函数的输出值与下一个函数输入值，可以一定程度上避免函数执行的副作用，当然除了这个之外我们还可以通过函子去控制异常，来进行异步操作等等。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>函数式编程指南</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书分享</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《JavaScript函数式编程指南》第四章 模块化且可重⽤的代码</title>
    <link href="/2023/12/05/functionalProgramming/book4/"/>
    <url>/2023/12/05/functionalProgramming/book4/</url>
    
    <content type="html"><![CDATA[<h1 id="第四章-模块化且可重⽤的代码"><a href="#第四章-模块化且可重⽤的代码" class="headerlink" title="第四章 模块化且可重⽤的代码"></a>第四章 模块化且可重⽤的代码</h1><blockquote><p>模块化是⼤型软件项⽬最重要的特性之⼀，它代表了将程序分成较⼩独⽴部分的程度。模块化程序的独特之处在于，其含义来⾃于其组成部分的性质。这些部分（称为⼦程序）都是可重复使⽤的组件，并可以合并为⼀个系统整体或单独在其他系统中使⽤。这使代码更加可读和可维护，同时使开发更加⾼效。</p></blockquote><h2 id="本章内容"><a href="#本章内容" class="headerlink" title="本章内容"></a>本章内容</h2><blockquote><p>函数链与函数管道的⽐较<br>Ramda.js 函数库<br>柯⾥化、部分应⽤（partial application）和函数绑定<br>通过函数式组合构建模块化程序<br>利⽤函数组合⼦增强程序的控制流</p></blockquote><h2 id="⽅法链与函数管道的⽐较"><a href="#⽅法链与函数管道的⽐较" class="headerlink" title="⽅法链与函数管道的⽐较"></a>⽅法链与函数管道的⽐较</h2><blockquote><p>⽅法链接（紧耦合，有限的表现⼒）。<br>函数的管道化（松耦合，灵活）。</p></blockquote><h3 id="什么是函数管道化"><a href="#什么是函数管道化" class="headerlink" title="什么是函数管道化"></a>什么是函数管道化</h3><p>函数管道化是一种编程技术，它将多个函数组合在一起，使它们按照一定的顺序依次执行，并将前一个函数的输出作为后一个函数的输入。这种方式可以将复杂的问题分解成简单的步骤，每个步骤都由一个函数来完成，从而使代码更加模块化和易于维护。<br>函数管道化还可以提高代码的可读性和可重用性，因为每个函数都可以单独测试和调试。<br>在函数式编程中，函数管道化是一个常见的技术，它可以帮助程序员更好地利用函数的组合性质。</p><h3 id="⽅法链与函数管道的区别"><a href="#⽅法链与函数管道的区别" class="headerlink" title="⽅法链与函数管道的区别"></a>⽅法链与函数管道的区别</h3><p>方法链接和管道都是将多个操作连接在一起的方式，但它们之间有一些区别。<br>1.方法链接<br>方法链接是一种将多个方法链接在一起的方式，其中每个方法都会对前一个方法的结果进行操作。这种链接方式通常用于函数式编程中，可以让代码更加简洁和可读。例如，在JavaScript中，可以使用方法链接来对数组进行操作，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">_.<span class="hljs-title function_">chain</span>(names)<br> .<span class="hljs-title function_">filter</span>(isValid) <br> .<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> s.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/_/</span>, <span class="hljs-string">&#x27; &#x27;</span>))<br> .<span class="hljs-title function_">uniq</span>()<br> .<span class="hljs-title function_">map</span>(_.<span class="hljs-property">startCase</span>)<br> .<span class="hljs-title function_">sort</span>()<br> .<span class="hljs-title function_">value</span>();<br></code></pre></td></tr></table></figure><p>每⼀个“点”后只能调⽤ Lodash 提供的⽅法<br><img src="/../img/function4-fn1.png" alt="数组的⽅法链需要通过调⽤所属对象中的⽅法来实现。⽽从内部来看，每个⽅法都会返回⼀个含有调⽤结果的新数组。"></p><p>从⾼阶函数⾓度来看，打破函数链的约束就能够⾃由地排列所有独⽴的函数操作，⽽可以使⽤函数管道来实现这⼀⽬的。</p><p>2.函数管道<br>函数式编程能够消除⽅法链中存在的限制，使得任何函数的组合都更加灵活。管道是松散结合的有向函数序列，⼀个函数的输出会作为下⼀个函数的输⼊。<br><img src="/../img/function4-fn2.png" alt="函数管道始于具有类型 A 参数的函数 f ，产⽣⼀个类型 B 的对象，随后按序传⼊函数 g ，并以输出的类型 C 对象作为最终结果。函数f 和 g 既可以来⾃于任何函数库，也可以是⾃定义的函数"><br>此模式就是许多企业应⽤程序中都能够看到的⾯向对象设计模式中的管道与过滤器模式，它是从函数式编程衍变⽽来的（其中的过滤器就是各个函数）。</p><p>⽅法链接通过对象的⽅法紧密连接；⽽管道以函数作为组件，将函数的输⼊和输出松散地连接在⼀起。但是，为了实现管道，被连接的函数必须在元数（arity）和类型上相互兼容。</p><h2 id="管道函数的兼容条件"><a href="#管道函数的兼容条件" class="headerlink" title="管道函数的兼容条件"></a>管道函数的兼容条件</h2><blockquote><p>类型——函数的返回类型必须与接收函数的参数类型相匹配。<br>元数——接收函数必须声明⾄少⼀个参数才能处理上⼀个函数的返回值。</p></blockquote><p>1.类型<br>由于JavaScirpt是弱类型语⾔，因此从类型⾓度来看，⽆须像使⽤⼀些静态类型语⾔⼀样太过关注类型。但开发者仍然需要了解⼀个函数所期望的参数类型。使⽤清晰的定义。举例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">addOne</span>(<span class="hljs-params">num: number</span>): number &#123;<br>  <span class="hljs-keyword">return</span> num + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">toString</span>(<span class="hljs-params">num: number</span>): string &#123;<br>  <span class="hljs-keyword">return</span> num.<span class="hljs-title function_">toString</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这两个函数的输入和输出类型都是明确的。现在我们想要将它们组合成一个管道函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">addOneAndToString</span>(<span class="hljs-params">num: number</span>): string &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">toString</span>(<span class="hljs-title function_">addOne</span>(num));<br>&#125;<br></code></pre></td></tr></table></figure><p>这个管道函数的输入类型是 number，输出类型是 string。因此，如果我们想要将它与另一个函数组合起来，那么这个函数的输入类型必须是 string，输出类型可以是任何类型，因为这是管道函数的最终输出类型。如果我们稍微修改一下 toString 函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">toString</span>(<span class="hljs-params">num: number | string</span>): string &#123;<br>  <span class="hljs-keyword">return</span> num.<span class="hljs-title function_">toString</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>现在这个函数的输入类型是 number | string，输出类型仍然是 string。那么我们就可以将它与 addOneAndToString 组合起来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">addOneAndToString</span>(<span class="hljs-params">num: number| string</span>): string &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">toString</span>(<span class="hljs-title function_">addOne</span>(num));<br>&#125;<br></code></pre></td></tr></table></figure><p>2.元数<br>元数定义为函数所接收的参数数量，也被称为函数的⻓度（length）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// isValid :: String -&gt; Boolean</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">isValid</span>(<span class="hljs-params">str</span>) &#123; <span class="hljs-comment">//使⽤简单</span><br> ...<br>&#125;<br><span class="hljs-comment">// makeAsyncHttp:: String, String, Array -&gt; Boolean</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">makeAsyncHttp</span> (method, url, data) &#123; <span class="hljs-comment">//难以使⽤，因为必须先计算出所有参数</span><br> ...<br>&#125;<br><br></code></pre></td></tr></table></figure><p>只具有单⼀参数的纯函数是最简单的，因为其实现⽬的⾮常单纯，也就意味着职责单⼀。因此，应该尽可能地使⽤具有少量参数的函数，这样的函数更加灵活和通⽤。然⽽，总是使⽤⼀元函数并⾮那么容易。例如，在真实世界中，isValid 函数可能会额外返回⼀个描述错误信息的值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">isValid :: <span class="hljs-title class_">String</span> -&gt; (<span class="hljs-title class_">Boolean</span>, <span class="hljs-title class_">String</span>) <span class="hljs-comment">//返回含有验证状态或错误信息的结构体</span><br><span class="hljs-title function_">isValid</span>(<span class="hljs-string">&#x27; 444-444-44444&#x27;</span>); <span class="hljs-comment">//-&gt; (false, &#x27;Input is too long!&#x27;)</span><br><br></code></pre></td></tr></table></figure><p>想要返回两个值的话，此时就用到了元组。<br>元组是一个描述定长数组的类型，数组的各项可以类型不同。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">return</span> &#123;<br> status : <span class="hljs-literal">false</span>, <br> <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Input is too long!&#x27;</span><br>&#125;;<br><span class="hljs-comment">//或者</span><br> <span class="hljs-keyword">return</span> [<span class="hljs-literal">false</span>, <span class="hljs-string">&#x27;Input is too long!&#x27;</span>];<br></code></pre></td></tr></table></figure><p>1、不可变的——⼀旦创建，就⽆法改变⼀个元组的内部内容。<br>2、避免创建临时类型——元组可以将可能毫不相关的数据相关联。⽽定义和实例化⼀些仅⽤于数据分组的新类型使得模型复杂并令⼈费解。<br>3、避免创建异构数组——包含不同类型元素的数组使⽤起来颇为困难，因为会导致代码中充满⼤量的防御性类型检查。传统上，数组意在存储相同类型的对象。</p><p>JavaScript并不原⽣地⽀持Tuple 数据类型。但是，JavaScript已经提供了实现元组所需的所有⼯具，Tuple 数据类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Tuple</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"> <span class="hljs-comment">/* types */</span> </span>) &#123;<br> <span class="hljs-keyword">const</span> typeInfo = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">//读取参数作为元组的元素类型</span><br><br><br> <span class="hljs-keyword">const</span> _T = <span class="hljs-keyword">function</span>(<span class="hljs-params"> <span class="hljs-comment">/* values */</span> </span>) &#123; <span class="hljs-comment">//声明内部类型_T，以保障类型与值匹配</span><br> <span class="hljs-keyword">const</span> values = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-number">0</span>); <span class="hljs-comment">//提取参数作为元组内的值</span><br><br>  <span class="hljs-comment">//检查⾮空值。函数式数据类型不允许空值</span><br>  <span class="hljs-keyword">if</span>(values.<span class="hljs-title function_">some</span>(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> val === <span class="hljs-literal">null</span> || val === <span class="hljs-literal">undefined</span>)) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceError</span>(<span class="hljs-string">&#x27;Tuples may not have any null values&#x27;</span>);<br>  &#125;<br>  <span class="hljs-keyword">if</span>(values.<span class="hljs-property">length</span> !== typeInfo.<span class="hljs-property">length</span>) &#123; <span class="hljs-comment">//按照定义类型的个数检查元组的元数</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;Tuple arity does not match its prototype&#x27;</span>);<br>  &#125;<br>  values.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">val, index</span>) &#123; <span class="hljs-comment">//使⽤ checkType 检查每⼀个值都能匹配其类型定义。</span><br>  <span class="hljs-comment">//其中的元素都可以通过_n 获取， n 为元素的索引（注意是从1 开始）</span><br>  <span class="hljs-variable language_">this</span>[<span class="hljs-string">&#x27;_&#x27;</span> + (index + <span class="hljs-number">1</span>)] = <span class="hljs-title function_">checkType</span>(typeInfo[index])(val);<br>  &#125;, <span class="hljs-variable language_">this</span>);<br>  <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>(<span class="hljs-variable language_">this</span>); <span class="hljs-comment">//让元组实例不可变</span><br> &#125;;<br><br> _T.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">values</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-comment">//提取元组中的元素，也可以使⽤ES6 的解构赋值把元素赋值到变量上</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-variable language_">this</span>).<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">k</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>[k];<br>  &#125;, <span class="hljs-variable language_">this</span>);<br> &#125;;<br> <span class="hljs-keyword">return</span> _T;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>使用举例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">StringPair</span> = <span class="hljs-title class_">Tuple</span>(<span class="hljs-title class_">String</span>, <span class="hljs-title class_">String</span>);<br><span class="hljs-keyword">const</span> name = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringPair</span>(<span class="hljs-string">&#x27;Barkley&#x27;</span>, <span class="hljs-string">&#x27;Rosser&#x27;</span>);<br>[first, last] = name.<span class="hljs-title function_">values</span>();<br>first; <span class="hljs-comment">//-&gt; &#x27;Barkley&#x27;</span><br>last; <span class="hljs-comment">//-&gt; &#x27;Rosser&#x27;</span><br><span class="hljs-keyword">const</span> fullname = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringPair</span>(<span class="hljs-string">&#x27;J&#x27;</span>, <span class="hljs-string">&#x27;Barkley&#x27;</span>, <span class="hljs-string">&#x27;Rosser&#x27;</span>); <span class="hljs-comment">//抛出元素不匹配的错误</span><br></code></pre></td></tr></table></figure><p>元组是减少函数元数的⽅式之⼀，但还可以使⽤更好的⽅式去应对那些不适于元组的情况。通过引⼊函数柯⾥化不仅可以降低元数，还可以增强代码的模块化和可重⽤性。</p><h2 id="柯⾥化的函数求值"><a href="#柯⾥化的函数求值" class="headerlink" title="柯⾥化的函数求值"></a>柯⾥化的函数求值</h2><p>JavaScript是允许在缺少参数的情况下对常规或⾮柯⾥化函数进⾏调⽤的。换句话说，如果定义⼀个函数f(a, b, c) ，并只在调⽤时传递a ，JavaScript运⾏时的调⽤机制会将b 和c 设为undefined<br><img src="/../img/function4-fn3.png" alt="再看柯⾥化函数，它要求所有参数都被明确地定义，因此当使⽤部分参数调⽤时，它会返回⼀个新的函数，在真正运⾏之前等待外部提供其余的参数。"></p><p><img src="/../img/function4-fn4.png" alt="柯⾥化函数 f 的求值。只有提供了所有参数，该函数才会输出具体的结果，否则它会返回另⼀个等待参数传递的函数"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123;  <span class="hljs-keyword">return</span> a + b;&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">curryingAdd</span>(<span class="hljs-params">a</span>) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">b</span>) &#123;    <span class="hljs-keyword">return</span> a + b;  &#125;&#125;<br><span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 3</span><br><span class="hljs-title function_">curryingAdd</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><p>由于JavaScript本⾝不⽀持⾃动柯⾥化函数，因此需要编写⼀些代码来启⽤它。⼆元参数的⼿动柯⾥化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">curry2</span>(<span class="hljs-params">fn</span>) &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">firstArg</span>) &#123; <span class="hljs-comment">//第⼀次调⽤ curry2，获得第⼀个参数</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">secondArg</span>) &#123; <span class="hljs-comment">//第⼆次调⽤获得第⼆个参数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">fn</span>(firstArg, secondArg); <span class="hljs-comment">//将两个参数应⽤到函数 fn 上</span><br>  &#125;;<br> &#125;;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如上所⽰，柯⾥化是⼀种词法作⽤域（闭包），其返回的函数只不过是⼀个接收后续参数的简单嵌套函数包装器。以下是⼀个简单应⽤：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> name = <span class="hljs-title function_">curry2</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">last, first</span>) &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringPair</span>(<span class="hljs-string">&#x27;Barkley&#x27;</span>, <span class="hljs-string">&#x27;Rosser&#x27;</span>);<br>&#125;);<br>[first, last] = <span class="hljs-title function_">name</span>(<span class="hljs-string">&#x27;Curry&#x27;</span>)(<span class="hljs-string">&#x27;Haskell&#x27;</span>).<span class="hljs-title function_">values</span>(); <span class="hljs-comment">//当给定两个参数时，函数会完全求值</span><br>first;<span class="hljs-comment">//-&gt; &#x27;Curry&#x27;</span><br>last; <span class="hljs-comment">//-&gt; &#x27;Haskell&#x27;</span><br><span class="hljs-title function_">name</span>(<span class="hljs-string">&#x27;Curry&#x27;</span>); <span class="hljs-comment">//-&gt; Function &lt;--- 当只提供⼀个参数时，返回⼀个函数，⽽不是将第⼆个参数当作 undefined</span><br></code></pre></td></tr></table></figure><h3 id="函数式库Ramda-js"><a href="#函数式库Ramda-js" class="headerlink" title="函数式库Ramda.js"></a>函数式库Ramda.js</h3><p>像 Lodash ⼀样，Ramda.js拥有众多可⽤于连接函数式程序的有⽤函数，并且对纯函数式编码⻛格提供了⽀持。之所以使⽤它，是因为可以很容易地实现参数柯⾥化、惰性应⽤和函数组合（参⻅本章后⾯的内容）。</p><p>跟其他函数库区别<br>其一：Lodash&#x2F;underscore 的函数库，因为它的很多函数把需要处理的参数放在了首位（ 例如 <code>map</code> ）这里推荐使用 Ramda，它应该是目前最符合函数式编程的工具库，它需要操作的数据参数都是放在最后的。</p><p>其二：柯里化：Ramda 几乎所有的函数都是自动柯里化的。也即可以使用函数必需参数的子集来调用函数，这会返回一个接受剩余参数的新函数。当所有参数都传入后，原始函数才被调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">isOdd</span> = (<span class="hljs-params">n</span>) =&gt; n % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>;<br><br>R.<span class="hljs-title function_">reject</span>(isOdd, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]); <span class="hljs-comment">//=&gt; [2, 4]</span><br><br>R.<span class="hljs-title function_">reject</span>(isOdd, &#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">d</span>: <span class="hljs-number">4</span>&#125;); <span class="hljs-comment">//=&gt; &#123;b: 2, d: 4&#125;</span><br></code></pre></td></tr></table></figure><p>柯⾥化的实际应⽤场景：实现可重⽤模块化函数模板。</p><h3 id="创建可重⽤的函数模板。"><a href="#创建可重⽤的函数模板。" class="headerlink" title="创建可重⽤的函数模板。"></a>创建可重⽤的函数模板。</h3><p>创建⼀个⽇志函数模板</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> logger = <span class="hljs-keyword">function</span>(<span class="hljs-params">appender, layout, name, level, message</span>) &#123;<br> <span class="hljs-keyword">const</span> appenders = &#123; <span class="hljs-comment">//预设 appenders</span><br> <span class="hljs-string">&#x27;alert&#x27;</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Log4</span>js.<span class="hljs-title class_">JSAlertAppender</span>(),<br> <span class="hljs-string">&#x27;console&#x27;</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Log4</span>js.<span class="hljs-title class_">BrowserConsoleAppender</span>()<br> &#125;;<br> <span class="hljs-keyword">const</span> layouts = &#123; <span class="hljs-comment">//预设布局layouts</span><br> <span class="hljs-string">&#x27;basic&#x27;</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Log4</span>js.<span class="hljs-title class_">BasicLayout</span>(),<br> <span class="hljs-string">&#x27;json&#x27;</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Log4</span>js.<span class="hljs-title class_">JSON</span>Layout(),<br> <span class="hljs-string">&#x27;xml&#x27;</span> : <span class="hljs-keyword">new</span> <span class="hljs-title class_">Log4</span>js.<span class="hljs-title class_">XMLLayout</span>()<br> &#125;;<br> <span class="hljs-keyword">const</span> appender = appenders[appender];<br> appender.<span class="hljs-title function_">setLayout</span>(layouts[layout]);<br> <span class="hljs-keyword">const</span> logger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Log4</span>js.<span class="hljs-title function_">getLogger</span>(name);<br> logger.<span class="hljs-title function_">addAppender</span>(appender);<br> logger.<span class="hljs-title function_">log</span>(level, message, <span class="hljs-literal">null</span>); <span class="hljs-comment">//使⽤配置好的logger 打印消息</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>通过柯⾥化logger ，可以集中管理和重⽤适⽤于任何场合的⽇志配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> log = R.<span class="hljs-title function_">curry</span>(logger)(<span class="hljs-string">&#x27;alert&#x27;</span>, <span class="hljs-string">&#x27;json&#x27;</span>, <span class="hljs-string">&#x27;FJS&#x27;</span>); <span class="hljs-comment">//只会应⽤第⼀个参数到函数 logger</span><br><span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;ERROR&#x27;</span>, <span class="hljs-string">&#x27;Error condition detected!!&#x27;</span>);<br><span class="hljs-comment">// -&gt; this will popup an alert dialog with the requested message</span><br></code></pre></td></tr></table></figure><p>如果要在⼀个函数或⽂件中记录多条错误⽇志，可以灵活地设置除最后⼀个参数之外的其他参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> logError = R.<span class="hljs-title function_">curry</span>(logger)(<span class="hljs-string">&#x27;console&#x27;</span>, <span class="hljs-string">&#x27;basic&#x27;</span>, <span class="hljs-string">&#x27;FJS&#x27;</span>,<span class="hljs-string">&#x27;ERROR&#x27;</span>);<br><span class="hljs-title function_">logError</span>(<span class="hljs-string">&#x27;Error code 404 detected!!&#x27;</span>);<br><span class="hljs-title function_">logError</span>(<span class="hljs-string">&#x27;Error code 402 detected!!&#x27;</span>);<br></code></pre></td></tr></table></figure><p>curry 函数的后续调⽤在后台被执⾏，最终⽣产⼀个⼀元函数。</p><p>除了能够有效提升代码的可重⽤性之外，将多元函数转换为⼀元函数才是柯⾥化的主要动机。柯⾥化的可替代⽅案是部分应⽤和函数绑定，它们受到JavaScript语⾔的适度⽀持，以产⽣更⼩的功能，在插⼊功能管道时也能很好地⼯作。</p><h2 id="部分应用和函数绑定"><a href="#部分应用和函数绑定" class="headerlink" title="部分应用和函数绑定"></a>部分应用和函数绑定</h2><p>部分应⽤是⼀种通过将函数的不可变参数⼦集初始化为固定值来创建更⼩元数函数的操作。简单来说，如果存在⼀个具有五个参数的函数，给出三个参数后，就会得到⼀个、两个参数的函数。</p><p>许多语言支持可选参数，但是Javascript不支持。Javascript采用一种完全不同的模式，它任允许意数量的参数传给函数。<br>部分应用在Javascript中的处理方式是：给函数的一个或多个参数绑定上值，然后返回另一个函数接受剩余的未绑定参数。 同样，珂理化的处理方式是把一个有多个参数的函数转换为一个只接受一个参数的函数，它返回的函数接受剩余的参数。</p><p>和柯里化区别：<br>1、柯⾥化在每次分步调⽤时都会⽣成嵌套的⼀元函数。在底层，函数的最终结果是由这些⼀元函数的逐步组合产⽣的。同时，curry 的变体允许同时传递⼀部分参数。因此，可以完全控制函数求值的时间与⽅式。<br>2、部分应⽤将函数的参数与⼀些预设值绑定（赋值），从⽽产⽣⼀个拥有更少参数的新函数。该函数的闭包中包含了这些已赋值的参数，在之后的调⽤中被完全求值。</p><h3 id="延迟函数绑定"><a href="#延迟函数绑定" class="headerlink" title="延迟函数绑定"></a>延迟函数绑定</h3><p>当期望目标函数使用某个所属对象来执行时，使用函数绑定来设置上下文对象就变得尤为重要。例如，浏览器中的setTimeout和setInterval等函数，如果不将this的引用设为全局上下文，即window对象，是不能正常工作的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">delayFunctionBinding</span>(<span class="hljs-params">func, context</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> func.<span class="hljs-title function_">apply</span>(context, <span class="hljs-variable language_">arguments</span>);<br>  &#125;;<br>&#125;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John&#x27;</span>,<br>  <span class="hljs-attr">greet</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello, &#x27;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&#x27;!&#x27;</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> greet = obj.<span class="hljs-property">greet</span>;<br><span class="hljs-title function_">greet</span>(); <span class="hljs-comment">// 输出：Hello, undefined!</span><br><br><span class="hljs-keyword">var</span> boundGreet = <span class="hljs-title function_">delayFunctionBinding</span>(obj.<span class="hljs-property">greet</span>, obj);<br><span class="hljs-title function_">boundGreet</span>(); <span class="hljs-comment">// 输出：Hello, John!</span><br></code></pre></td></tr></table></figure><p>在这个例子中，使用 delayFunctionBinding() 函数来创建一个新的函数 boundGreet，该函数在被调用时会将闭包中保存的 this 关键字绑定到 obj 对象上。这样，就可以正确地输出 Hello, John!。</p><h2 id="组合函数管道"><a href="#组合函数管道" class="headerlink" title="组合函数管道"></a>组合函数管道</h2><p>可以将任务分解为多个简单的函数，再通过组合来获得整个解决方案。<br>函数组合是一种将多个函数合并成一个函数的技术，其中每个函数的输出都作为下一个函数的输入，从而形成一个管道。<br>可以使用 compose 函数来实现函数组合。compose 函数可以接受任意数量的函数作为参数，并返回一个新函数，该函数将这些函数组合起来形成一个管道。<br>下面是一个使用 compose 函数实现级联算法的示例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = x =&gt; <span class="hljs-function"><span class="hljs-params">y</span> =&gt;</span> y + x; <br><span class="hljs-keyword">const</span> <span class="hljs-title function_">multiply</span> = x =&gt; <span class="hljs-function"><span class="hljs-params">y</span> =&gt;</span> y * x; <br><span class="hljs-keyword">const</span> <span class="hljs-title function_">subtract</span> = x =&gt; <span class="hljs-function"><span class="hljs-params">y</span> =&gt;</span>y - x; <br><span class="hljs-keyword">const</span> <span class="hljs-title function_">divide</span> = x =&gt; <span class="hljs-function"><span class="hljs-params">y</span> =&gt;</span> y / x; <br><span class="hljs-keyword">const</span> <span class="hljs-title function_">cascade</span> = (<span class="hljs-params">...fns</span>) =&gt; <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> fns.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, fn</span>) =&gt;</span> <span class="hljs-title function_">fn</span>(acc), x); <br><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">cascade</span>( <span class="hljs-title function_">add</span>(<span class="hljs-number">10</span>), <span class="hljs-title function_">multiply</span>(<span class="hljs-number">2</span>), <span class="hljs-title function_">subtract</span>(<span class="hljs-number">5</span>), <span class="hljs-title function_">divide</span>(<span class="hljs-number">3</span>) )(<span class="hljs-number">3</span>); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result); <span class="hljs-comment">// 输出 7</span><br><span class="hljs-comment">// 在这个示例代码中，我们首先定义了四个基本算术函数：add、multiply、subtract 和 divide。每个函数都接受一个参数，</span><br><span class="hljs-comment">//并返回一个新的函数，该函数将该参数与下一个参数组合起来进行计算。</span><br><span class="hljs-comment">// 然后，我们定义了一个名为 cascade 的函数，该函数接受任意数量的函数作为参数，并返回一个新函数，</span><br><span class="hljs-comment">//该函数将这些函数组合成一个管道。在管道中，每个函数的输出都作为下一个函数的输入。</span><br><span class="hljs-comment">// 最后，我们使用 cascade 函数将这些基本算术函数组合成一个级联算法，并将输入值设置为 3。运行结果为 7，</span><br><span class="hljs-comment">//因为管道中的函数先将输入值加上 10，然后将结果乘以 2，再减去 5，最后将结果除以 3。最终结果为 7。</span><br></code></pre></td></tr></table></figure><h3 id="HTML部件的组合"><a href="#HTML部件的组合" class="headerlink" title="HTML部件的组合"></a>HTML部件的组合</h3><p>组合的概念是很直观的，也不是函数式编程所独有的。看看HTML ⻚⾯中的部件是如何组织的。复杂的部件都是由简单的部件组合⽽来，⽽反过来⼜可以⽤于构建更⼤的部件。<br>例如，将3个输⼊⽂本组件与⼀个空容器组合起来可以得到⼀个简单的学⽣表单:<br><img src="/../img/function4-fn5.png" alt="将3个简单的⽂本组件与⼀个空容器组合以创建⼀个简历表单组件"><br>现在，学⽣表单也成为⼀个组件，可以与其他组件组合成更复杂的结构，从⽽⼀步步创建出⼀个完整的学⽣控制台表单:<br><img src="/../img/function4-fn6.png" alt="由地址表单、简历表单、按钮和⼀个容器等⼩部件组合的学⽣控制台表单"></p><p>为了演⽰，下⾯创建⼀个叫作Node 的递归结构的元组：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Node</span> = <span class="hljs-title class_">Tuple</span>(<span class="hljs-title class_">Object</span>, <span class="hljs-title class_">Tuple</span>);<br></code></pre></td></tr></table></figure><p>它可⽤于保存⼀个对象以及对另⼀个节点（元组）的引⽤。本质上，这是⼀个元素列表的函数式定义：由头部和尾部递归组合⽽成。<br>通过柯⾥化的element 函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> element = R.<span class="hljs-title function_">curry</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">val, tuple</span>) &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(val, tuple);<br>&#125;);<br><br></code></pre></td></tr></table></figure><p>读者可以创建以null 终⽌的任⼀类型的列表。<br><img src="/../img/function4-fn7.png" alt="由头部和尾部构成的数字列表。函数式语⾔中的数组已经具有head和tail两个函数"></p><h3 id="函数组合：描述与求值分离"><a href="#函数组合：描述与求值分离" class="headerlink" title="函数组合：描述与求值分离"></a>函数组合：描述与求值分离</h3><p>从本质上讲，函数组合是⼀种将已被分解的简单任务组织成复杂⾏为的整体过程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> str = <span class="hljs-string">`We can only see a short distance ahead but we can see plenty there that needs to be done`</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">explode</span> = (<span class="hljs-params">str</span>) =&gt; str.<span class="hljs-title function_">split</span>(<span class="hljs-regexp">/\s+/</span>); <span class="hljs-comment">// 将句⼦分割成单词数组</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">count</span> = (<span class="hljs-params">arr</span>) =&gt; arr.<span class="hljs-property">length</span>; <span class="hljs-comment">//单词数量</span><br><span class="hljs-keyword">const</span> countWords = R.<span class="hljs-title function_">compose</span>(count, explode);<br><span class="hljs-title function_">countWords</span>(str); <span class="hljs-comment">//-&gt; 19</span><br></code></pre></td></tr></table></figure><p>可以说，这段代码很容易阅读，从函数的组成部分⼀眼就能看出其⾏为。这段程序最有趣的是，直到countWords 被调⽤才会触发求值。换句话说，⽤其名称传递的函数（explode 和count ）在组合中是静⽌的。组合的结果是⼀个等待指定参数调⽤的另⼀个函数countWords 。这是函数式组合的强⼤之处：将函数的描述与求值分开。</p><h3 id="函数式库的组合"><a href="#函数式库的组合" class="headerlink" title="函数式库的组合"></a>函数式库的组合</h3><p>使⽤诸如Ramda这种函数式库的好处之⼀是，所有的函数已经被正确地柯⾥化，在组合函数管道时更具有通⽤性。<br>R.zip ——通过配对两个数组的内容来创建⼀个新数组。<br>R.prop ——指定在排序中要使⽤的值。本例中，以 1 作为参数指明使⽤⼦数组的第⼆个元素（成绩）。<br>R.sortBy ——通过给定的属性执⾏数组的⾃然升序排序。<br>R.reverse ——反转整个数组以获得第⼀个元素的最⾼数字。<br>R.pluck ——通过抽取指定索引处的元素构建数组。传递参数 0表⽰提取元素为学⽣姓名。<br>R.head ——获取第⼀个元素。</p><p>再来看⼀个例⼦，以下是⼀个班中各学⽣的名单和成绩获取最聪明的学⽣：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> students = [<span class="hljs-string">&#x27;Rosser&#x27;</span>, <span class="hljs-string">&#x27;Turing&#x27;</span>, <span class="hljs-string">&#x27;Kleene&#x27;</span>, <span class="hljs-string">&#x27;Church&#x27;</span>];<br><span class="hljs-keyword">const</span> grades = [<span class="hljs-number">80</span>, <span class="hljs-number">100</span>, <span class="hljs-number">90</span>, <span class="hljs-number">99</span>];<br><span class="hljs-keyword">const</span> smartestStudent = R.<span class="hljs-title function_">compose</span>(<br> R.<span class="hljs-property">head</span>,<br> R.<span class="hljs-title function_">pluck</span>(<span class="hljs-number">0</span>),<br> R.<span class="hljs-property">reverse</span>,<br> R.<span class="hljs-title function_">sortBy</span>(R.<span class="hljs-title function_">prop</span>(<span class="hljs-number">1</span>)),<br> R.<span class="hljs-property">zip</span>); <span class="hljs-comment">//⽤ Ramda 的⼀系列函数组合成新函数smartestStudent</span><br><span class="hljs-title function_">smartestStudent</span>(students, grades); <span class="hljs-comment">//-&gt; &#x27;Turing&#x27; &lt;--- 传给第⼀个函数</span><br>R.<span class="hljs-title function_">zip</span>()<span class="hljs-comment">//两个数组。每⼀步对数据进⾏不可变的变换，直到最后⼀个函数 R.head()，返回结果</span><br><br></code></pre></td></tr></table></figure><h3 id="point-free编程"><a href="#point-free编程" class="headerlink" title="point-free编程"></a>point-free编程</h3><p>Point-free编程是一种编程风格，其中函数不显式地引用它们的参数。相反，它们使用函数组合和柯里化等技术来构建更高级别的函数。这种风格的主要优点是可读性更好，因为它可以消除冗长的参数列表和重复的代码。它还可以促进代码的重用和模块化，因为它鼓励将函数分解为更小的、可组合的部分。Point-free编程通常与函数式编程语言和库一起使用，例如Haskell和Ramda。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">toUpperCase</span> = str =&gt; str.<span class="hljs-title function_">toUpperCase</span>();<br></code></pre></td></tr></table></figure><p>我们可以使用Point-free编程的方式来重写这个函数，如下所示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> toUpperCase = <span class="hljs-title class_">String</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toUpperCase</span>.<span class="hljs-property">call</span>.<span class="hljs-title function_">bind</span>(<span class="hljs-title class_">String</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toUpperCase</span>);<br></code></pre></td></tr></table></figure><p>这个函数使用了函数组合的方式，将toUpperCase()方法绑定到了call()方法上，从而实现了将字符串转换为大写的功能，而不需要使用变量。</p><p>point-free代码可能会对错误处理和调试造成影响。⽐如，在有异常抛出并产⽣副作⽤时，是否应该在组合函数中返回null来解决呢？尽管可以在函数中检查null ，但会导致很多的代码重复、样板代码以及为了程序进⾏⽽返回的合理默认值。同时，该怎样尝试调试出现在⼀⾏的所有命令呢？这些都需要关注的问题会在下⼀章中予以解决。</p><h2 id="使⽤函数组合⼦来管理程序的控制流"><a href="#使⽤函数组合⼦来管理程序的控制流" class="headerlink" title="使⽤函数组合⼦来管理程序的控制流"></a>使⽤函数组合⼦来管理程序的控制流</h2><p>命令式代码能够使⽤如if-else 和for 这样的过程控制机制，函数式则不能。所以，这需要⼀个替代⽅案——可以使⽤函数组合⼦。<br>组合器是⼀些可以组合其他函数（或其他组合⼦），并作为控制逻辑运⾏的⾼阶函数。组合⼦通常不声明任何变量，也不包含任何业务逻辑，它们旨在管理函数式程序的流程。除了compose 和pipe ，还有⽆数的组合⼦，⼀些最常⻅的组合⼦如下。<br>identity 组合子是返回与参数同值的函数，广泛使用于函数数学特性的检验。可以使用identity函数来编写compose的单元测试。<br>tap（K-组合⼦）它能够将无返回值的函数（例如记录日志、修改文件或HTML页面的函数）嵌入函数组合中，而无须创建其他的代码。它会将所属对象传入函数参数并返回该对象。</p><p>alt（OR-组合⼦）能够在提供函数响应的默认行为时执行简单的条件逻辑。该组合器以两个函数为参数，如果第一个函数返回值已定义（即，不是false、null或undefined），则返回该值；否则，返回第二个函数的结果。<br>该组合⼦的实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> alt = <span class="hljs-keyword">function</span> (<span class="hljs-params">func1, func2</span>) &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">func1</span>(val) || <span class="hljs-title function_">func2</span>(val);<br> &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>也可以使⽤curry 和lambda表达式写得更简洁：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> alt = R.<span class="hljs-title function_">curry</span>(<span class="hljs-function">(<span class="hljs-params">func1, func2, val</span>) =&gt;</span> <span class="hljs-title function_">func1</span>(val) ||<span class="hljs-title function_">func2</span>(val));<br></code></pre></td></tr></table></figure><p>可以将该组合⼦⽤在showStudent 程序中，来处理当获取操作不成功的情况，从⽽创建⼀个新的学⽣：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> showStudent = R.<span class="hljs-title function_">compose</span>( <span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;#student-info&#x27;</span>), csv, <span class="hljs-title function_">alt</span>(findStudent, createNewStudent));<br><span class="hljs-title function_">showStudent</span>(<span class="hljs-string">&#x27;444-44-4444&#x27;</span>);<br><br></code></pre></td></tr></table></figure><p>若要了解发⽣了什么，可以假设该代码模拟了⼀个简单的ifelse{&#x2F;0 } 语句，等同于以下的命令式条件逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> student = <span class="hljs-title function_">findStudent</span>(<span class="hljs-string">&#x27;444-44-4444&#x27;</span>);<br><span class="hljs-keyword">if</span>(student !== <span class="hljs-literal">null</span>) &#123;<br> <span class="hljs-keyword">let</span> info = <span class="hljs-title function_">csv</span>(student);<br> <span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;#student-info&#x27;</span>, info);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br> <span class="hljs-keyword">let</span> newStudent = <span class="hljs-title function_">createNewStudent</span>(<span class="hljs-string">&#x27;444-44-4444&#x27;</span>);<br> <span class="hljs-keyword">let</span> info = <span class="hljs-title function_">csv</span>(newStudent);<br> <span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;#student-info&#x27;</span>, info);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>seq（S-组合⼦）用于遍历函数序列。它以两个或更多的函数作为参数并返回一个新的函数，会用相同的值顺序调用所有这些函数。<br>该组合⼦的实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> seq = <span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-comment">/*funcs*/</span></span>) &#123;<br> <span class="hljs-keyword">const</span> funcs = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) &#123;<br>  funcs.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-title function_">fn</span>(val);<br>  &#125;);<br> &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>有了它，就可以序列化地执⾏相关但独⽴的多个操作。例如，在找到学⽣对象后，可以使⽤seq 将它们呈现在HTML⻚⾯上并将其输出到控制台。所有函数都以同⼀学⽣对象作为参数顺序执⾏：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> showStudent = R.<span class="hljs-title function_">compose</span>( <span class="hljs-title function_">seq</span>( <span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;#student-info&#x27;</span>), consoleLog), csv, findStudent));<br><br></code></pre></td></tr></table></figure><p>seq 组合⼦不会返回任何值，只会⼀个⼀个地执⾏⼀系列操作。如果要将其嵌⼊函数组合之间，可以使⽤R.tap 将它与其余部分进⾏桥接。</p><p>fork (join)组合子用于需要以两种不同的方式处理单个资源的情况。该组合子需要以3个函数作为参数，即以一个join函数和两个fork函数来处理提供的输入。<br>该组合⼦的实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fork = <span class="hljs-keyword">function</span>(<span class="hljs-params">join, func1, func2</span>)&#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">join</span>(<span class="hljs-title function_">func1</span>(val), <span class="hljs-title function_">func2</span>(val));<br> &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><p>现在来看看该组合⼦的使⽤⽅法。让我们重新通过⼀组数字形式的成绩计算出平均的字⺟形式的成绩。可以使⽤fork 来组织3个计算函数的求值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> computeAverageGrade =<br> R.<span class="hljs-title function_">compose</span>(getLetterGrade, <span class="hljs-title function_">fork</span>(R.<span class="hljs-property">divide</span>, R.<span class="hljs-property">sum</span>, R.<span class="hljs-property">length</span>));<br><span class="hljs-title function_">computeAverageGrade</span>([<span class="hljs-number">99</span>, <span class="hljs-number">80</span>, <span class="hljs-number">89</span>]); <span class="hljs-comment">//-&gt; &#x27;B&#x27;</span><br><br></code></pre></td></tr></table></figure><p>下⾯的例⼦⽤于检查均值和集合的中位数是否相等：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> eqMedianAverage = <span class="hljs-title function_">fork</span>(R.<span class="hljs-property">equals</span>, R.<span class="hljs-property">median</span>, R.<span class="hljs-property">mean</span>);<br><span class="hljs-title function_">eqMedianAverage</span>([<span class="hljs-number">80</span>, <span class="hljs-number">90</span>, <span class="hljs-number">100</span>])); <span class="hljs-comment">//-&gt; True</span><br><span class="hljs-title function_">eqMedianAverage</span>([<span class="hljs-number">81</span>, <span class="hljs-number">90</span>, <span class="hljs-number">100</span>])); <span class="hljs-comment">//-&gt; False</span><br></code></pre></td></tr></table></figure><p>有些⼈将组合视为约束，但看来恰恰相反：组合⼦使代码编写更加灵活，并有利于point-free⻛格编程。因为组合⼦都是纯函数，它们也能够结合其他组合⼦使⽤，为任何类型的应⽤程序提供⽆数的替代⽅案并减少复杂度。我们会在后续章节中再次使⽤它们。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>⽤于连接可重⽤的、模块化的、组件化程序的函数链与管道。</li><li>Ramda.js是⼀个功能强⼤的函数库，适⽤于函数的柯⾥化与组合。</li><li>可以通过部分求值和柯⾥化来减少函数元数，利⽤对参数⼦集的部分求值将函数转化为⼀元函数。</li><li>可以将任务分解为多个简单的函数，再通过组合来获得整个解决⽅案。</li><li>以point-free的⻛格编写，并⽤函数组合⼦来组织的程序控制流，可解决现实问题。</li></ul>]]></content>
    
    
    <categories>
      
      <category>函数式编程指南</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书分享</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AngularJS 技术分享</title>
    <link href="/2023/11/29/angularJs/share1/"/>
    <url>/2023/11/29/angularJs/share1/</url>
    
    <content type="html"><![CDATA[<h1 id="AngularJS-技术分享"><a href="#AngularJS-技术分享" class="headerlink" title="AngularJS 技术分享"></a>AngularJS 技术分享</h1><p>AngularJS 是一种基于 JavaScript 的开源前端 web 框架，它使用 TypeScript 作为开发语言，提供了一套丰富的组件库，它可以帮助开发人员构建大型、复杂的Web应用程序。</p><blockquote><p>💡  AngularJS 采用了 MVC（Model-View-Controller）架构模式，将应用划分为三个核心部件：模型（Model）、视图（View）和控制器（Controller），使得应用的结构更加清晰，维护性和扩展性更好。</p></blockquote><h1 id="AngularJS执行流程"><a href="#AngularJS执行流程" class="headerlink" title="AngularJS执行流程"></a>AngularJS执行流程</h1>]]></content>
    
    
    
    <tags>
      
      <tag>技术分享</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《JavaScript函数式编程指南》第三章 轻数据结构，重操作</title>
    <link href="/2023/11/27/functionalProgramming/book3/"/>
    <url>/2023/11/27/functionalProgramming/book3/</url>
    
    <content type="html"><![CDATA[<h1 id="第三章-轻数据结构，重操作"><a href="#第三章-轻数据结构，重操作" class="headerlink" title="第三章 轻数据结构，重操作"></a>第三章 轻数据结构，重操作</h1><h2 id="本章内容"><a href="#本章内容" class="headerlink" title="本章内容"></a>本章内容</h2><blockquote><p>理解程序的控制流<br>更易理解的代码与数据<br>命令抽象函数 map、 reduce 以及 filter<br>Lodash.js 及函数链<br>递归的思考</p></blockquote><h3 id="为什么选择这本书"><a href="#为什么选择这本书" class="headerlink" title="为什么选择这本书"></a>为什么选择这本书</h3><p>💡  前面已经了解了为什么要选择函数式以及为什么要选择JavaScript。这一部分开始，将讨论一些实用的概念，应用函数式编程来解决现实问题。</p><p><a name="ij2QS"></a></p><h1 id="1、理解程序的控制流"><a href="#1、理解程序的控制流" class="headerlink" title="1、理解程序的控制流"></a>1、理解程序的控制流</h1><blockquote><p>程序为实现业务目标所要行进的路径被称为控制流。</p></blockquote><p>命令式程序需要暴露所有的必要步骤才能及其详细地描述其控制流。这些步骤通常涉及大量的循环和分支，以及随语句执行变化的各种变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> loop = <span class="hljs-title function_">optC</span>();<br><span class="hljs-keyword">while</span>(loop)&#123;<br>  <span class="hljs-keyword">var</span> condition = <span class="hljs-title function_">optA</span>();<br>  <span class="hljs-keyword">if</span>(condition)&#123;<br>    <span class="hljs-title function_">optB1</span>();<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-title function_">optB2</span>();<br>  &#125;<br>  loop = <span class="hljs-title function_">optC</span>();<br>&#125;<br><span class="hljs-title function_">optD</span>();<br></code></pre></td></tr></table></figure><p>下图显示了上述程序的简单流程图<br /><br><img src="/../img/function3-fn1.png" alt="简单流程图"><br><br />condition 表示任意表达式，该表达式求值的结果不一定是布尔类型，如果不是布尔类型，ECMAScript 会调用Boolean() 转换函数，将这个表达式结果转换为一个布尔类型，当该值为 true 时，执行 if 代码块中的内容，否则，执行 else 代码块中的内容。<br />声明式程序，特别是函数式程序，则多使用以简单拓扑链接的独立黑盒操作组合而成的较小结构化控制流，从而提升程序的抽象层次。这些连接在一起的操作只是一些能够将状态传递至下一个操作的高阶函数，如下图。使用函数式开发风格操作数据结构，其实就是将数据与控制流视为一些高级组件的简单连接。<br />使用这种方式可以形成类似这样的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">optA</span>().<span class="hljs-title function_">optB</span>().<span class="hljs-title function_">optC</span>().<span class="hljs-title function_">optD</span>();  <span class="hljs-comment">//这样用点连接表示有共同的对象上定义过这些方法</span><br></code></pre></td></tr></table></figure><p><img src="/../img/function3-fn2.png" alt="链式操作"><br><br />采用这种链式操作能够使程序简洁、流畅并富有表现力，能够从计算逻辑中很好地分离控制流，因此可以使得代码和数据更易推理。<br><a name="cn2e0"></a></p><h1 id="2、链接方法"><a href="#2、链接方法" class="headerlink" title="2、链接方法"></a>2、链接方法</h1><blockquote><p>链接方法在函数式编程中常常用于串联一系列的操作。<br>方法链是一种能够在一个语句中调用多个方法的面向对象编程模式。当这些方法属于同一个对象时，方法链又称为方法级联。尽管该模式大多出现在面向对象的应用程序中，但在一些特定条件下，如操作不可变对象时，也能很好地用于函数式编程中。既然在函数式代码中是禁止修改对象的，又如何能使用这种方法链模式呢？ <br /></p></blockquote><p>让我们来看一个字符串处理的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;Functional Programming&#x27;</span>.<span class="hljs-title function_">substring</span>(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>).<span class="hljs-title function_">toLowerCase</span>() + <span class="hljs-string">&#x27;is fun&#x27;</span>;<br></code></pre></td></tr></table></figure><p>在上述示例中，<code>substring</code> 和 <code>toLowerCase</code> 都是（通过 <code>this</code>）在隶属的字符串对象上操作并返回一个新字符串的方法。JavaScript中字符串的加号（+）运算符被重载为连接字符串操作的语法糖，它也会返回一个新的字符串。通过一系列变换后的结果与原先字符串毫无引用关系，而原先的字符串也不会有任何变化。这种行为是理所当然的，因为按照设计，字符串是不可变的。从面向对象的角度来看，这没有什么特别的。但从函数式编程的角度来看，这是一种理想行为，因为不需要使用 <code>Lenses</code> 来进行字符串变换了。<br><br/><br>如果用更加函数式的风格重构上面的代码，它会像这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">concat</span>(<span class="hljs-title function_">toLowerCase</span>(<span class="hljs-title function_">substring</span>(<span class="hljs-string">&#x27;Functional Programming&#x27;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">10</span>)), <span class="hljs-string">&#x27;is fun&#x27;</span>)<br></code></pre></td></tr></table></figure><p>上述代码符合函数式风格，所有参数都应在函数声明中明确定义，而且它没有副作用，也不会修改的原有对象。但可以说，这样的代码写起来并没有方法链流畅。而且它也更难阅读，因为需要一层层地剥离外部函数，才能知晓内部真正发生的事情。<br><br/><br>要遵守不可变的编程原则，函数式中也会应用这种隶属于单个对象实例的方法链。能用该模式来处理数组变换吗？其实 JavaScript 也将这种字符串的行为推广到数组上了，大多数人之所以还在用 for 循环作为权宜之计，是因为他们并不了解这些特性。<br><br/><br>下面是一个简单的例子，展示了如何使用链式调用风格来实现一个简单的函数式编程应用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 定义一个函数，用于对数组进行过滤</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">filter</span>(<span class="hljs-params">array, predicate</span>) &#123;<br>    <span class="hljs-keyword">return</span> array.<span class="hljs-title function_">filter</span>(predicate);<br>&#125;<br><br><span class="hljs-comment">// 定义一个函数，用于对数组进行映射</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">map</span>(<span class="hljs-params">array, mapper</span>) &#123;<br>    <span class="hljs-keyword">return</span> array.<span class="hljs-title function_">map</span>(mapper);<br>&#125;<br><br><span class="hljs-comment">// 定义一个函数，用于对数组进行reduce</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">reduce</span>(<span class="hljs-params">array, reducer, initialValue</span>) &#123;<br>    <span class="hljs-keyword">return</span> array.<span class="hljs-title function_">reduce</span>(reducer, initialValue);<br>&#125;<br><br><span class="hljs-comment">// 使用链式调用风格来执行一系列操作</span><br><span class="hljs-keyword">var</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><br><span class="hljs-keyword">var</span> filtered = <span class="hljs-title function_">filter</span>(numbers, <span class="hljs-keyword">function</span> (<span class="hljs-params">number</span>) &#123;<br>    <span class="hljs-keyword">return</span> number &gt; <span class="hljs-number">2</span>;<br>&#125;);<br><br><span class="hljs-keyword">var</span> mapped = <span class="hljs-title function_">map</span>(filtered, <span class="hljs-keyword">function</span> (<span class="hljs-params">number</span>) &#123;<br>    <span class="hljs-keyword">return</span> number * <span class="hljs-number">2</span>;<br>&#125;);<br><br><span class="hljs-keyword">var</span> reduced = <span class="hljs-title function_">reduce</span>(mapped, <span class="hljs-keyword">function</span> (<span class="hljs-params">accumulator, number</span>) &#123;<br>    <span class="hljs-keyword">return</span> accumulator + number;<br>&#125;, <span class="hljs-number">0</span>);<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(reduced);  <span class="hljs-comment">// 输出：24</span><br></code></pre></td></tr></table></figure><p>在这个例子中，我们定义了三个纯函数：<code>filter</code>、<code>map</code> 和 <code>reduce</code>。然后我们使用链式调用来串联这些操作。首先，我们使用 <code>filter</code> 函数来过滤出一个只包含大于2的数字的数组。然后，我们使用 <code>map</code> 函数来将这个数组中的每个元素乘以2。最后，我们使用 <code>reduce</code> 函数来将这个数组中的所有元素加起来。<br><a name="jg1cn"></a></p><h1 id="3、函数链"><a href="#3、函数链" class="headerlink" title="3、函数链"></a>3、函数链</h1><p>面向对象程序将继承作为代码重用的主要机制。回忆之前章节中，Student 类继承了父类 Person 的所有状态和方法。读者也许在一些纯面向对象的语言中更多见到的是这种模式，特别是在数据结构的实现代码中。例如在 Java 中，有一大堆继承于基础接口 List 的各种实体List 类，如ArrayList 、LinkedList 、DoublyLinkedList 、CopyOnWrite ArrayList 等，它们都源自共同的父类，并各自添加了一些特定的功能。<br/><br>函数式编程则采用了不同的方式。它不是通过创建一个全新的数据结构类型来满足特定的需求，而是使用如数组这样的普通类型，并施加在一套粗粒度的高阶操作之上，这些操作是底层数据形态所不可见的。这些操作会作如下设计。<br/></p><blockquote><p>• 接收函数作为参数，以便能够注入解决特定任务的特定行为。<br/><br>• 代替充斥着临时变量与副作用的传统循环结构，从而减少所要维护以及可能出错的代码。</p></blockquote><p>函数式编程的一个常见模式是函数链，或称为“管道”模式。这种模式的核心思想是将一个数据的转换过程分解为一系列的函数，这些函数一个接一个地被调用，每个函数都产生一个新的数据并将其传递给下一个函数。</p><p>函数链通常使用高阶函数（接收函数作为参数或返回函数的函数）和链式调用实现。比如，以下是一个简单的 JavaScript 函数链示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">double</span> = x =&gt; x * <span class="hljs-number">2</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">square</span> = x =&gt; x * x;<br><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">square</span>(<span class="hljs-title function_">double</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// result is 100</span><br></code></pre></td></tr></table></figure><p>在这个例子中，我们创建了三个函数：<code>double</code>、<code>square</code> 和 <code>result</code>。<code>double</code> 接收一个数字并返回其两倍，<code>square</code> 接收一个数字并返回其平方，然后我们通过链式调用（<code>square(double(5))</code>）将这两个函数串联起来。这个链式的调用顺序表示数据的转换过程：首先将 5 传递给 <code>double</code>，得到 10，然后传递给 <code>square</code>，得到 100。<br /><br /><br>下面让我们仔细研究一下。本章中的示例都是基于一个 Person 对象的集合。为了方便起见，我们只声明四个对象，但相同的概念同样适用于较大的集合：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Haskell&#x27;</span>, <span class="hljs-string">&#x27;Curry&#x27;</span>, <span class="hljs-string">&#x27;111-11-1111&#x27;</span>);<br>p1.<span class="hljs-property">address</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>(<span class="hljs-string">&#x27;US&#x27;</span>);<br>p1.<span class="hljs-property">birthYear</span> = <span class="hljs-number">1900</span>;<br><br><span class="hljs-keyword">const</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Barkley&#x27;</span>, <span class="hljs-string">&#x27;Rosser&#x27;</span>, <span class="hljs-string">&#x27;222-22-2222&#x27;</span>);<br>p2.<span class="hljs-property">address</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>(<span class="hljs-string">&#x27;Greece&#x27;</span>);<br>p2.<span class="hljs-property">birthYear</span> = <span class="hljs-number">1907</span>;<br><br><span class="hljs-keyword">const</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;John&#x27;</span>, <span class="hljs-string">&#x27;von Neumann&#x27;</span>, <span class="hljs-string">&#x27;333-33-3333&#x27;</span>);<br>p3.<span class="hljs-property">address</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>(<span class="hljs-string">&#x27;Hungary&#x27;</span>);<br>p3.<span class="hljs-property">birthYear</span> = <span class="hljs-number">1903</span>;<br><br><span class="hljs-keyword">const</span> p4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Alonzo&#x27;</span>, <span class="hljs-string">&#x27;Church&#x27;</span>, <span class="hljs-string">&#x27;444-44-4444&#x27;</span>);<br>p4.<span class="hljs-property">address</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>(<span class="hljs-string">&#x27;US&#x27;</span>);<br>p4.<span class="hljs-property">birthYear</span> = <span class="hljs-number">1903</span>;<br></code></pre></td></tr></table></figure><h2 id="了解lambda表达式"><a href="#了解lambda表达式" class="headerlink" title="了解lambda表达式"></a>了解lambda表达式</h2><blockquote><p>lambda表达式通常被称为箭头函数。这是ES6（ECMAScript 2015）引入的一种新的函数表达式，<br>比起传统的函数声明，它提供了一种更简洁的语法形式来声明一个匿名函数。<br>尽管 lambda 函数也可以写成多行形式，但就像在第2章中见到的，单行是最普遍的形式。使用 lambda 表达式或普通函数声明语法一般只会影响到代码的可读性，其本质是一样的。</p></blockquote><p>下面是Lambda表达式的基本语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">(parameters) =&gt; &#123; statements &#125;<br></code></pre></td></tr></table></figure><p>下面是一个可用于提取个人姓名的示例函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">name</span> = p =&gt; p.<span class="hljs-property">fullname</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">name</span>(p1));    <span class="hljs-comment">//-&gt; &#x27;Haskell Curry&#x27;</span><br></code></pre></td></tr></table></figure><p>(P) &#x3D;&gt; p.fullname 这种简洁的语法糖表明它只接收一个参数 p 并隐式地返回p.fullname。<br/><br>下图显示了这种新语法的结构。</p><p><img src="/../img/function3-fn3.png" alt="箭头函数的结构。lambda函数的右侧可以是一个表达式或是一个封闭的多个语句块﻿"></p><p>这是另一个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">greet</span> = (<span class="hljs-params">name</span>) =&gt; <span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>!`</span>;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">greet</span>(<span class="hljs-string">&quot;World&quot;</span>));  <span class="hljs-comment">// 输出 &quot;Hello, World!&quot;</span><br></code></pre></td></tr></table></figure><p>在这个例子中，<code>greet</code> 是一个箭头函数，接收一个参数 <code>name</code>，并返回一个字符串。箭头函数可以包含多条语句，但它们不能有函数体（即花括号 <code>&#123;&#125;</code> 中的内容）。这意味着箭头函数只能包含一条语句。</p><p>箭头函数还有一些主要的特性：</p><ol><li><strong>简洁的语法</strong>：箭头函数允许你使用一个简洁的语法来创建函数。没有参数的箭头函数仅仅是一个表达式，因此可以省略掉 <code>return</code> 关键字。例如，<code>x =&gt; x * x</code> 就等同于 <code>(x) =&gt; &#123; return x * x; &#125;</code>。</li><li>**绑定 <code>this</code>**：在箭头函数中，<code>this</code> 是词法的，箭头函数的<code>this</code>在定义函数的时候绑定，而不是在执行函数的时候绑定。箭头函数没有自己的<code>this</code> 对象，箭头函数的<code>this</code> 永远指向其父级作用域，这意味着你不能在箭头函数内部改变 <code>this</code> 的值。这和普通函数不同，普通函数中的 <code>this</code> 是动态的，并且在运行时确定。</li><li><strong>无参数的 <code>arguments</code> 对象</strong>：箭头函数不绑定自己的 <code>arguments</code> 对象。如果你在箭头函数内部使用 <code>arguments</code>，它实际上是外部作用域中的 <code>arguments</code> 对象。</li><li>**不绑定自己的 <code>new.target</code>**：箭头函数没有 <code>new.target</code> 属性。如果你尝试在箭头函数中使用 <code>new.target</code>，它总是返回 <code>undefined</code>。</li><li><strong>不能作为构造函数</strong>：由于箭头函数没有自己的 <code>this</code>，因此你不能使用 new 关键字来创建一个箭头函数的实例。这是因为 <code>this</code> 在箭头函数中是词法的，并且总是指向调用该函数的对象。</li><li><strong>没有<code>call</code>、<code>apply</code>、和 <code>bind</code> 方法</strong>：箭头函数没有自己的 <code>call</code>、<code>apply</code> 和 <code>bind</code> 方法。如果你尝试调用这些方法，它们实际上是调用外部作用域中的这些方法。</li><li><strong>没有原型链</strong>：箭头函数没有自己的原型链。如果你尝试访问箭头函数的 <code>prototype</code> 属性，它总是返回 <code>undefined</code>。此外，箭头函数不能被用作其他函数的原型。</li><li><strong>可以嵌套</strong>：箭头函数可以嵌套在其他箭头函数中，这是 JavaScript 中一种常见的模式。这使得代码更加简洁和可读。</li><li><strong>没有 <code>arguments</code> 对象和 <code>callee</code> 属性</strong>：由于箭头函数没有自己的 <code>arguments</code> 对象和 <code>callee</code> 属性，因此你无法在箭头函数内部访问这些属性。<blockquote><p>词法作用域就是在你写代码的时候就已经知道了变量的作用域，在处理代码时会保持作用域不变。箭头函数的this在定义函数的时候绑定,而不是在执行函数的时候绑定 箭头函数没有自己的this对象 箭头函数的this永远指向其父级作用域 任何方法都改变不了this</p></blockquote></li></ol><p>lambda表达式适用于函数式的函数定义，因为它总是需要返回一个值。对于单行表达式，其返回值就是函数体的值。另一个值得注意的是一等函数与lambda表达式之间的关系。函数名代表的不是一个具体的值，而是一种（惰性计算的）可获取其值的描述。换句话说，函数名指向的是代表着如何计算该数据的箭头函数。这就是在函数式编程中可以将函数作为数值使用的原因。我们将在本章进一步讨论它，并在第7章讨论惰性计算函数。<br/><br>此外，函数式编程中鼓励使用的<code>map</code> 、<code>reduce</code> 以及 <code>filter</code> 等核心高阶函数都能够与 lambda 表达式良好地配合使用。很多函数式的 JavaScript 代码都需要处理数据列表，这也就是衍生 JavaScript 的函数式语言鼻祖起名为 LISP（列表处理）的原因。JavaScript 5.1 本身就提供特定版本的该类操作——称为函数式array extras 。但为了能够联合其他相似操作以提供完整的解决方案，本书会选择使用 Lodash.js 函数式库中提供的此类操作。它的工具包包含丰富的能够处理常见编程任务的基础函数（安装方法见下面），因此非常利于编写函数式程序。安装之后，就可以通过全局的 _ （下画线符号）对象来访问其功能。</p><p><strong>映射（Map）、过滤（Filter）和规约（Reduce）</strong>：这是函数式编程中最常用的三个操作。映射是将一个函数应用于一个列表中的每个元素；过滤是根据某种条件筛选出列表中的元素；规约是将一个函数应用于一个列表中的所有元素，然后将结果合并成一个单一的值。你可以使用数组的<code>map</code>、<code>filter</code>和<code>reduce</code>方法来进行这些操作。<br />这些函数都是接受一个函数作为参数，并在此基础上对数组或其他可迭代对象进行操作。<br />以下是这些函数的基本用法：</p><ol><li><code>map(callback: Function, thisArg: Any)</code>: 对数组中的每个元素都调用一次 <code>callback</code> 函数，并返回一个包含回调函数返回值的新数组。</li><li><code>reduce(callback: Function, initialValue: Any): Any</code>: 对数组中的每个元素执行一次 <code>callback</code> 函数，并返回一个单一的输出值。</li><li><code>filter(callback: Function, thisArg: Any): Array</code>: 创建一个新的数组，包含通过 <code>callback</code> 测试的所有元素。</li></ol><p>这些函数可以极大的简化代码，提高代码的可读性和可维护性。同时，由于它们都是高阶函数，可以方便的创建出复杂的数据处理流程。<br /><br>例如，你可以用这些函数来对数组进行一系列的操作，如过滤出满足某些条件的元素，对每个元素进行一些计算，然后将结果合并成一个新的数组。这在传统的命令式编程中可能需要大量的循环和条件语句才能实现，而在函数式编程中只需要几行代码就能完成。<br /><br>此外，由于这些函数都是纯函数，数据结构不会被改变，只返回新的值，我们可以更容易地理解和预测程序的行为。这使得代码更容易阅读和维护。</p><h1 id="4、Lodash"><a href="#4、Lodash" class="headerlink" title="4、Lodash"></a>4、Lodash</h1><p>本书中使用Lodash.js 函数式库中提供的操作，来提供完整的解决方案</p><blockquote><p>Lodash <br/><br>A modern JavaScript utility library delivering modularity, performance &amp; extras.</p></blockquote><p>Lodash 是一个现代化的，实用的 JavaScript 工具库，提供了模块化、高性能，以及一些附加功能。提供了许多用于处理数组、对象、数字、字符串、函数等的有用功能。它旨在提高开发者的效率，简化代码，并提供一致性的方法。<br /><br>Lodash 库提供了一些常用的工具函数，如链式调用、数组操作、对象操作、工具方法等。它还支持模块化加载，可以根据实际需要只加载需要的功能，而不必加载整个库。之前很多人把Lodash作为一个功能库来使用。当ES5、ES6给原生js增加了很多方便的方法以后，有很多人开始讨论，是否还有使用Lodash的必要。其实，Lodash中，除了提供了一些常用的便捷方法以外，还提供了与函数式编程相关的一些方法，比如说函数的柯里化、函数组合等。<br /></p><blockquote><p>Lodash 中的下画线<br/><br>Lodash 之所以使用下画线约定，是因为它是从著名且广泛使用的 <code>Undesrscore.js</code> 项目中衍生而来（<a href="http://underscorejs.org/">http://underscorejs.org</a>)）。为了能够直接替换<code>Underscore</code>，Lodash 仍然保持与其一致的 API。但从本质上讲，为了能够以更为优雅的方式构建函数链，本书将完全重写lodash，这也伴随着一些性能的提升（我们将在第7章深入了解）。</p></blockquote><h2 id="lodash-的安装"><a href="#lodash-的安装" class="headerlink" title="lodash 的安装"></a>lodash 的安装</h2><p>安装 lodash 的安装方法如下：</p><ol><li><p>使用 npm 安装 lodash：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install lodash<br></code></pre></td></tr></table></figure></li><li><p>使用 yarn 安装 lodash：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">yarn add lodash<br></code></pre></td></tr></table></figure></li><li><p>在浏览器中直接使用lodash<br>下载lodash.js或者lodash.min.js文件，然后在html中通过src引入即可:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;lodash.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="用-map做数据变换"><a href="#用-map做数据变换" class="headerlink" title="用_.map做数据变换"></a>用<code>_.map</code>做数据变换</h2><blockquote><p><code>_.map</code> 是 Lodash 库中的一个函数，用于遍历数组并创建一个新数组，新数组中的元素是原数组元素调用回调函数后的结果。</p></blockquote><p><strong>以下是 <code>_.map</code> 的基本使用方法：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">_.<span class="hljs-title function_">map</span>(array, [iteratee = _.<span class="hljs-property">identity</span>])<br></code></pre></td></tr></table></figure><p><strong>参数：</strong></p><ul><li><strong><code>array</code> (Array): 需要遍历的数组。</strong></li><li><strong><code>iteratee</code> (Function, optional): 回调函数。</strong></li></ul><p><strong>返回值：</strong></p><ul><li><strong>(Array): 返回一个新数组。</strong></li></ul><p><strong>示例：</strong><br /><br>假设我们有一个数组 <code>[1, 2, 3, 4]</code>，我们想要将每个元素乘以2，我们可以这样做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">var</span> doubled = _.<span class="hljs-title function_">map</span>(numbers, <span class="hljs-keyword">function</span>(<span class="hljs-params">num</span>) &#123;<br>  <span class="hljs-keyword">return</span> num * <span class="hljs-number">2</span>;<br>&#125;);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(doubled); <span class="hljs-comment">// =&gt; [2, 4, 6, 8]</span><br></code></pre></td></tr></table></figure><p>上述例子中，**<code>_.map</code>** 遍历 <strong><code>numbers</code></strong> 数组，并将每个元素乘以2。然后它返回一个新的数组 **<code>doubled</code>**，该数组包含原始数组元素经过回调函数处理后的结果。<br /></p><p>假设需要对一个较大数据集合中的所有元素进行变换，例如，从一个学生对象的列表中提取每个人的全名。你曾经有多少次不得不写出这样的语句？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> result = [];<br><span class="hljs-keyword">var</span> persons = [p1, p2, p3, p4];<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; persons.<span class="hljs-property">length</span>; i++)&#123;<br>  <span class="hljs-keyword">var</span> p = persons[i];<br>  <span class="hljs-keyword">if</span>( p !== <span class="hljs-literal">null</span> &amp;&amp; p !== <span class="hljs-literal">undefined</span>)&#123;<br>    result.<span class="hljs-title function_">push</span>(p.<span class="hljs-property">fullname</span>);    <span class="hljs-comment">//命令式的方案会假设fullname是Student的方法</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>高阶函数 <code>map</code>（也称为collect ）能够将一个迭代函数有序地应用于一个数组中的每个元素，并返回一个长度相等的新数组。以下是使用 <code>_.map</code> 的函数式风格版本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">_.<span class="hljs-title function_">map</span>(persons,<br>      <span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> (s !== <span class="hljs-literal">null</span> &amp;&amp; s !== <span class="hljs-literal">undefined</span>) ? s.<span class="hljs-property">fullname</span> : <span class="hljs-string">&#x27;&#x27;</span>    <span class="hljs-comment">//通过高阶函数去掉了所有var声明</span><br>);<br></code></pre></td></tr></table></figure><p>该操作的标准定义如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">map</span>(f, [e0, e1, e2...]) -&gt; [r0, r1, r2...];  <span class="hljs-comment">//其中,f(en) = rn</span><br></code></pre></td></tr></table></figure><p>如果整个集合元素需要进行变换，map 函数是极其有用的——再也不必编写循环，并处理奇怪的作用域问题了。此外，由于其是不可变的，因此输出是一个全新的数组。map 需要以一个函数f 以及拥有 n 个元素的集合作为输入，由左到右对每个元素应用函数f 后，返回一个长度为 n 的新数组。该行为如下图所示。<br><img src="/../img/function3-fn4.jpg" alt="操作 map 对数组的每个元素应用迭代函数 f ，并返回一个等长的数组"></p><p>在 <code>_.map</code> 的例子中，我们遍历了学生的对象数组并提取出他们的名字。可以用 lambda 表达式作为迭代函数（这是通常的做法）。原有的数组不会被改变，而新返回的数组包含以下元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-string">&#x27;Haskell Curry&#x27;</span>, <span class="hljs-string">&#x27;Barkley Rosser&#x27;</span>, <span class="hljs-string">&#x27;John von Neumann&#x27;</span>, <span class="hljs-string">&#x27;Alonzo Church&#x27;</span>]<br></code></pre></td></tr></table></figure><p>理解抽象层次背后的事情永远是有好处的，下面来看 <code>map</code> 是如何实现的。<br/><br><strong><code>Map</code>的实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">map</span>(<span class="hljs-params">arr, fn</span>)&#123;    <span class="hljs-comment">//接收一个函数和一个数组，应用函数到数组中的每一个元素，然后返回同样大小的新数组</span><br>  <span class="hljs-keyword">let</span> idx = <span class="hljs-number">0</span>,<br>      len = arr.<span class="hljs-property">length</span>,<br>      result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(len);<span class="hljs-comment">//结果：一个与输入数组同样长度的数组</span><br>  <span class="hljs-keyword">while</span>(++idex &lt; len)&#123;<br>    result[index] = <span class="hljs-title function_">fn</span>(array[idx], idx, arr);<span class="hljs-comment">//应用函数fn到数组中的每一个元素，再把结果放入数组</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上所示，<code>_.map</code> 也是基于标准循环的。该函数已经处理了迭代的逻辑，因此无须为一些如循环变量或边界检查这样的琐事而操心，只需关注在迭代函数中功能逻辑的合理性即可。这个例子展示了函数式库如何辅助开发着写出纯函数式的代码。<br /><br><code>map</code> 是一个只会从左到右遍历的操作，对于从右到左的遍历，必须先反转数组。JavaScript 中的 <code>Array.reverse()</code> 操作是不能在这里使用的，因为它会改变原数组。可以将 Lodash 中功能等价的 <code>reverse</code> 操作与 <code>map</code> 连接起来写成一行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">_</span>(persons).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">map</span>(<br>  <span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> (p !== <span class="hljs-literal">null</span> &amp;&amp; p !== undefinde) ? p.<span class="hljs-property">fullname</span> :<span class="hljs-string">&#x27;&#x27;</span><br>);<br></code></pre></td></tr></table></figure><p>请注意该例子中语法的细小区别。Lodash 提供了一种不错的非侵入式的方式来与代码继承。开发者所需要做的就是用符号_(…) 将要操作的对象包起来，这样就拥有了其强大功能的完全控制，可以实现任何想要的变换。</p><blockquote><p>容器的映射<br/><br>将数据结构（即例子中的数组）映射为转换后的值，这个理念具有更加深远的意义。正如可以用任意函数映射一个数组，也可以用函数映射一个对象（见第5章）。</p></blockquote><p>现在可以在数据上应用一个变换函数了。如果能够基于新的结构得出某个结果就更好了。这就是 <code>reduce</code> 函数要做的事了。</p><h2 id="用-reduce收集结果"><a href="#用-reduce收集结果" class="headerlink" title="用_.reduce收集结果"></a>用_.reduce收集结果</h2><blockquote><p><code>_.reduce</code> 是 Lodash 库中的一个函数，它对集合中的每个元素执行一个 reducer 函数，并将结果合并为单一的输出值。</p></blockquote><p>这个函数的签名如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">_.<span class="hljs-title function_">reduce</span>(array, [<span class="hljs-title function_">callback</span>(accumulator, value, index, array)], [thisArg])<br></code></pre></td></tr></table></figure><p>参数解释：</p><ul><li><code>array</code> (Array): 需要遍历的数组。</li><li><code>callback</code> (Function): 执行每个数组元素上的操作的回调函数，接受四个参数： <ul><li><code>accumulator</code> (Mixed): 累加器累积回调的返回值；</li><li><code>value</code> (Mixed): 数组中当前正在处理的元素；</li><li><code>index</code> (Number): 数组中当前正在处理的元素的索引；</li><li><code>array</code> (Array): 调用 <code>reduce</code> 的数组。</li></ul></li><li><code>thisArg</code> (Mixed): 作为 <code>callback</code> 中 <code>this</code> 的值使用的对象。</li></ul><p>转换数据之后，如何从中收集具有意义的结果呢？假设要从一个 Person 对象集合中计算出人数最多的国家，就可以使用 reduce 函数来实现。<br/><br>高阶函数 <code>reduce</code> 将一个数组中的元素精简为单一的值。该值是由每个元素与一个累积值通过一个函数计算得出的，如下图所示。<br><img src="/../img/function3-fn5.jpg" alt="将数组 reduce 为单一值。每次迭代都会计算出基于先前结果的累积值，直至到达数组的末尾。reduce 的最终结果始终是单一值"></p><p>上图可以更正式地表示为以下描述：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">reduce</span>(f,[e0, e1, e2, e3],accum) -&gt; <span class="hljs-title function_">f</span>(<span class="hljs-title function_">f</span>(<span class="hljs-title function_">f</span>(<span class="hljs-title function_">f</span>(acc, e0), e1, e2, e3)))) -&gt; R<br></code></pre></td></tr></table></figure><p><code>_.reduce</code>的基本实现大致如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reduce</span>(<span class="hljs-params">collection, iteratee, accumulator</span>) &#123;<br>  <span class="hljs-comment">// 确保 collection 是数组或对象</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Array</span>.<span class="hljs-title function_">isArray</span>(collection) &amp;&amp; !<span class="hljs-title function_">isLength</span>(collection)) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&#x27;Expected the collection to be an array, string or object&#x27;</span>);<br>  &#125;<br>  <span class="hljs-comment">// 如果提供了初始值，将其作为累加器；否则，从集合的第一个元素开始迭代</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> &lt; <span class="hljs-number">3</span>) &#123;<br>    accumulator = collection[<span class="hljs-number">0</span>];<br>    collection = collection.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-comment">// 迭代集合中的每一个元素</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> index <span class="hljs-keyword">in</span> collection) &#123;<br>    <span class="hljs-keyword">var</span> value = collection[index];<br>    accumulator = <span class="hljs-title function_">iteratee</span>(accumulator, value, index);<br>  &#125;<br>  <span class="hljs-comment">// 返回累加器的值</span><br>  <span class="hljs-keyword">return</span> accumulator;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个基础的实现，实际上的 <code>_.reduce</code>可能会包含更多的错误检查和优化。例如，如果提供的迭代器不是一个函数，Lodash 会抛出一个错误。此外，Lodash 还提供了一些特殊的迭代器函数，如<code>_.reduceRight</code>（从右到左迭代集合）， <code>_.reduceApply</code>（使用户能够将一个函数作为累加器），等等。<br />这个函数的工作原理是从数组的第一个元素开始，对每个元素应用一个函数，该函数将之前的返回值（初始值为提供的初始值）和当前元素作为参数。在处理完所有元素后，返回最终的返回值。</p><p>以下为书中介绍的 <code>reduce</code> 的实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">reduce</span>(<span class="hljs-params">arr, fn,[accumulator]</span>) &#123;<br>  <span class="hljs-keyword">let</span> idx = -<span class="hljs-number">1</span>,<br>      len = arr.<span class="hljs-property">length</span>;<br>  <span class="hljs-keyword">if</span> (!accumulator &amp;&amp; len &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果不提供累加值，就会用第一个元素作为累加值</span><br>    accumulator = arr[++idx];<br>  &#125;<br>  <span class="hljs-keyword">while</span> (++idx &lt; len) &#123;<br>    accumulator = <span class="hljs-title function_">fn</span>(accumulator, <span class="hljs-comment">// 应用fn到每一个元素，将结果放到累加值中</span><br>    arr[idx], idx, arr);<br>  &#125;<br>  <span class="hljs-keyword">return</span> accumulator; <span class="hljs-comment">// 返回累加值</span><br>&#125;<br></code></pre></td></tr></table></figure><p><code>reduce</code> 需要接收以下参数<br/><br> • fn ——迭代函数会应用于数组的每个元素，其参数包含累积值、当前值、当前索引以及数组本身。<br/><br> • 累加器——累积初始值，之后会用于存储每次迭代函数的计算结果，并不断被传入子函数中。<br/></p><p>以下是一个简单的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> array = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">const</span> sum = _.<span class="hljs-title function_">reduce</span>(array, <span class="hljs-function">(<span class="hljs-params">acc, val</span>) =&gt;</span> acc + val);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(sum); <span class="hljs-comment">// 输出：10</span><br></code></pre></td></tr></table></figure><p>上述例子中，我们使用 <code>_.reduce</code> 将数组中的所有元素加在一起。回调函数接收两个参数：累加器（<code>acc</code>）和当前值（<code>val</code>）。在第一次调用回调时，累加器的初始值是第一个元素。然后，每次调用回调时，我们将累加器的值增加当前的值，直到处理完所有元素。最后，我们得到的结果是这些元素的总和。<br/><br>下面写一个简单的程序来收集一个 Person 对象数组的一些统计数据。假设要找住在某个特定国家的人数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">_</span>(persons).<span class="hljs-title function_">reduce</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">stat, person</span>) &#123;<br>  <span class="hljs-keyword">const</span> country = person.<span class="hljs-property">address</span>.<span class="hljs-property">country</span>; <span class="hljs-comment">// 抽取国家信息</span><br>  stat[country] = _.<span class="hljs-title function_">isUndefined</span>(stat[country]) ? <span class="hljs-number">1</span> : stat[country] + <span class="hljs-number">1</span>; <span class="hljs-comment">// 记录人数，初始为1，每当找到同样国家的同学则加1</span><br>  <span class="hljs-keyword">return</span> stat;  <span class="hljs-comment">// 返回累加值</span><br>&#125;,&#123;&#125;);  <span class="hljs-comment">//以空对象作为初始累加器</span><br></code></pre></td></tr></table></figure><p>这段代码能够将输入的数组转换为表征各国人数的单一对象：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<br>  <span class="hljs-string">&#x27;US&#x27;</span>:<span class="hljs-number">2</span>,<br>  <span class="hljs-string">&#x27;Greece&#x27;</span>:<span class="hljs-number">1</span>,<br>  <span class="hljs-string">&#x27;Hungary&#x27;</span>:<span class="hljs-number">1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>为进一步简化，可以使用普适的 <code>map-reduce</code> 组合。通过链接这些函数，并提供具有特定行为的函数参数，就可以提高 <code>map</code> 和 <code>reduce</code> 函数的威力。抽象地讲，该程序流将具有如下结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">_</span>(persons).<span class="hljs-title function_">map</span>(func1).<span class="hljs-title function_">reduce</span>(func2);<br></code></pre></td></tr></table></figure><p>其中，func1 和func2 用于实现所需的特定行为。<br>下面示例结合 <code>map</code> 与 <code>reduce</code> 进行统计计算 展示了将业务函数与控制流分离的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">getCountry</span> = person =&gt; person.<span class="hljs-property">address</span>.<span class="hljs-property">country</span>;<br><span class="hljs-keyword">const</span> gatherStats = <span class="hljs-keyword">function</span> (<span class="hljs-params">stat, criteria</span>) &#123;<br>  stat[criteria] = _.<span class="hljs-title function_">isUndefined</span>(stat[criteria]) ? <span class="hljs-number">1</span> : stat[criteria] + <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">return</span> stat;<br>&#125;;<br><span class="hljs-title function_">_</span>(persons).<span class="hljs-title function_">map</span>(getCountry).<span class="hljs-title function_">reduce</span>(gatherStats, &#123;&#125;);<br></code></pre></td></tr></table></figure><p>这段代码使用 <code>map</code> 将对象数组进行预处理，提取出所有国家信息。之后，再使用 <code>reduce</code> 来收集最终的结果。这段代码与前面代码具有完全相同的输出，但更加清晰并更具可扩展性。与其直接去访问对象属性，不如考虑（使用Ramda）提供的lens来访问 <code>address.city</code> 属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> cityPath = [<span class="hljs-string">&#x27;address&#x27;</span>,<span class="hljs-string">&#x27;city&#x27;</span>];<br><span class="hljs-keyword">const</span> cityLens = R.<span class="hljs-title function_">lens</span>(R.<span class="hljs-title function_">path</span>(cityPath), R.<span class="hljs-title function_">assocPath</span>(cityPath));<br></code></pre></td></tr></table></figure><p>这样就能够很容易地基于人们所处的城市计算出结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">_</span>(persons).<span class="hljs-title function_">map</span>(R.<span class="hljs-title function_">view</span>(cityLens)).<span class="hljs-title function_">reduce</span>(gatherStats, &#123;&#125;);<br></code></pre></td></tr></table></figure><p>此外，还可以使用 _.groupBy 函数以一种更加简洁的方式来获得同样的结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">_.<span class="hljs-title function_">groupBy</span>(persons, R.<span class="hljs-title function_">view</span>(cityLens));<br></code></pre></td></tr></table></figure><p>与 map 不同，由于 <code>reduce</code> 依赖于累积的结果，如果不使用满足交换率的操作，从左到右与从右到左的计算可能产生不同的结果。为了说明这一点，考虑一个数组求和的简单程序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">_</span>([<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]).<span class="hljs-title function_">reduce</span>(_.<span class="hljs-property">add</span>);   <span class="hljs-comment">// 13</span><br></code></pre></td></tr></table></figure><p>使用反向的操作 <code>_.reduceRight</code> 函数也能够获得同样的结果。这是因为加法是一种满足交换律的运算，反之则有可能产生完全不同的结果，比如采用除法运算。如果使用之前的符号描述，<code>_.reduceRight</code> 可以作如下表示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">reduceRight</span>(f, [e0, e1, e2],accum) -&gt; (e0, <span class="hljs-title function_">f</span>(e1, <span class="hljs-title function_">f</span>(e2, <span class="hljs-title function_">f</span>(e3,accum)))) -&gt; R<br></code></pre></td></tr></table></figure><p>举例来说，以下两个使用 <code>_.divide</code> 的程序将计算出完全不同的结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">([<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]).<span class="hljs-title function_">reduce</span>(_.<span class="hljs-property">divide</span>) !== ([<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]).<span class="hljs-title function_">reduceRight</span>(_.<span class="hljs-property">divide</span>);<br></code></pre></td></tr></table></figure><p>此外，<code>reduce</code> 是一个会应用到所有元素的操作，这意味着没有办法将其“短路”来避免其应用于整个数组。假设需要对一组输入值进行校验，也许你会想用 <code>reduce</code> 将其转换为一个布尔值来表示所有参数是否合法。但是，使用 <code>reduce</code> 会比较低效，因为它会访问列表中的每一个值。其实，一旦找到了一个无效的输入，就不必继续校验剩下的值了。让我们看看如何使用 <code>_.some</code> 以及其他如 <code>_.isUndefined</code> 和 <code>_.isNull</code> 这样的有趣函数来进行更高效的验证。当要应用于列表中的每个元素时，<code>_.some</code> 函数能够在找到第一个真值（true ）后立即返回：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">isNotValid</span> = val =&gt; _.<span class="hljs-title function_">isUndefined</span>(val) || _.<span class="hljs-title function_">isNull</span>(val);  <span class="hljs-comment">//undefined 与 null 时为不合法</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">notAllValid</span> = args =&gt; (<span class="hljs-title function_">_</span>(args).<span class="hljs-title function_">some</span>(isNotValid)); <span class="hljs-comment">//函数 some 会在遍历到第一个 true 时返回 这在寻找数组中是否存在合法值时非常有用</span><br>notAllValid ([<span class="hljs-string">&#x27;string&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">undefined</span>]) <span class="hljs-comment">//false</span><br>notAllValid ([<span class="hljs-string">&#x27;string&#x27;</span>, <span class="hljs-number">0</span>, &#123;&#125;])  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>还可以使用与非全真的逻辑非（也就是全真）函数 <code>_.every</code> ，无论对单个元素返回 true 与否，都会检查所有元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">isValid</span> = val =&gt; !_.<span class="hljs-title function_">isUndefined</span>(val) &amp;&amp; !_.<span class="hljs-title function_">isNull</span>(val);<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">allValid</span> = args =&gt; <span class="hljs-title function_">_</span>(args).<span class="hljs-title function_">every</span>(isValid);<br><span class="hljs-title function_">allValid</span>([<span class="hljs-string">&#x27;string&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">null</span>]); <span class="hljs-comment">// false</span><br><span class="hljs-title function_">allValid</span>([<span class="hljs-string">&#x27;string&#x27;</span>, <span class="hljs-number">0</span>, &#123;&#125;]);  <span class="hljs-comment">//  true</span><br></code></pre></td></tr></table></figure><p>正如前面所看到的，无论是 <code>map</code> 还是 <code>reduce</code> 都会遍历整个数组。通常并不想处理数据结构中的所有元素，而是期望跳过任何为 <code>null</code> 或 <code>undefined</code> 的值。要是在计算之前有一个能够去除或过滤掉列表中某些元素的方法就更好了。<br/><br>下面介绍 <code>_.filter</code> 函数。</p><h2 id="用-filter删除不需要的元素"><a href="#用-filter删除不需要的元素" class="headerlink" title="用_.filter删除不需要的元素"></a>用_.filter删除不需要的元素</h2><blockquote><p><code>_.filter</code> 是一个用于筛选数组中符合特定条件的元素的函数。它接收两个参数：一个数组和一个断言函数（predicate function）。</p></blockquote><p>断言函数是一个返回布尔值的函数，用于判断数组中的每个元素是否符合筛选条件。当断言函数返回 <strong><code>true</code></strong> 时，该元素会被保留在筛选后的数组中；当断言函数返回 <strong><code>false</code></strong> 时，该元素会被排除。<br/><br>在处理较大的数据集合时，往往需要删除部分不能参与计算的元素。例如，需要计算只生活在欧洲国家的人或是出生在某一年的人。与其在代码中到处用 <code>if-else</code> 语句，不如用 <code>_.filter</code> 来实现。<br/><br>filter （也称为select ）是一个能够遍历数组中的元素并返回一个新子集数组的高阶函数，其中的元素由谓词函数 p 计算得出的 true 值结果来确定。<br/><br>正式的符号描述如下图所示。<br/></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">filter</span>(p, [d0, d1, d2, d3...dn]) -&gt; [d0,d1,...dn] （输入的子集）<br></code></pre></td></tr></table></figure><p><img src="/../img/function3-fn6.jpg" alt="filter 操作以一个数组为输入，并施加一个选择条件 p ，从而产生一个可能较原数组更小的子集。条件p 也称为函数谓词"></p><p>一种 filter 的实现如下所示<br/><br><strong>filter 的实现</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">filter</span>(<span class="hljs-params">arr, predicate</span>) &#123;<br><span class="hljs-keyword">let</span> idx = -<span class="hljs-number">1</span>,<br>    len = arr.<span class="hljs-property">length</span>,<br>    result = [];  <span class="hljs-comment">//结果数组为原数组的子集</span><br><span class="hljs-keyword">while</span> (++idx &lt; len) &#123;<br>  <span class="hljs-keyword">let</span> value = arr[idx];<br>  <span class="hljs-keyword">if</span> (<span class="hljs-title function_">predicate</span>(value, idx, <span class="hljs-variable language_">this</span>)) &#123;  <span class="hljs-comment">//调用谓词函数，如果结果为真，则保留，否则略过</span><br>    result.<span class="hljs-title function_">push</span>(value);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>除了需要提供数组外，<code>filter</code> 需要接收一个可用于测试数组中每个元素的 predicate 谓词函数。如果谓词为 true ，则将该元素保留在结果中，否则略过。这就是为什么通常会用 filter 从数组中删除无效数据：<br/></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">＿(persons).<span class="hljs-title function_">filter</span>(isValid).<span class="hljs-title function_">map</span>(fullname);<br></code></pre></td></tr></table></figure><p>但它的应用不止如此。假设需要从 <code>Person</code> 对象集合中提取生于1903年的人，那么用 <code>_.filter</code> 要比使用条件语句更简单明了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">bornIn1903</span> = person =&gt; person.<span class="hljs-property">birthYear</span> === <span class="hljs-number">1903</span>;<br>＿(persons).<span class="hljs-title function_">filter</span>(bornIn1903).<span class="hljs-title function_">map</span>(fullname).<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27; and &#x27;</span>);<br><span class="hljs-comment">// &#x27;Alonzo Church and Haskell Curry&#x27;    </span><br></code></pre></td></tr></table></figure><blockquote><p>数组推导式 <br/><br><code>map</code> 和 <code>filter</code> 都是能够根据当前数组生成新数组的高阶函数。很多如 <code>Haskell</code> 和 <code>Clojure</code> 等函数式语言中都能看到它们的身影。组合 <code>map</code> 和 <code>filter</code> 的另一种方法是使用数组推导式 ——也被称为列表推导式 。这是一种使用关键字 <code>for…of</code> 和 <code>if</code> 的简明语法并能够将 <code>map</code> 和 <code>filter</code> 的功能封装在一起的函数式特性：</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-keyword">for</span> (x <span class="hljs-keyword">of</span> iterable) <span class="hljs-keyword">if</span> (condition) x]<br></code></pre></td></tr></table></figure><p>在撰写本文时，ECMAScript 7 中存在一个增加数组推导式的提议。它能用简洁的表达式来组装新数组（这也就是为什么整个表达式被包裹在 [] 中）。例如，之前的代码可以如下重构：<br/></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">[<span class="hljs-keyword">for</span> (p <span class="hljs-keyword">of</span> people) <span class="hljs-keyword">if</span> (p.<span class="hljs-property">birthYear</span> === <span class="hljs-number">1903</span>) p.<span class="hljs-property">fullname</span>].<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27; and &#x27;</span>);<br></code></pre></td></tr></table></figure><p>下面是一个使用 <strong><code>_.filter</code></strong> 的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-keyword">const</span> evenNumbers = _.<span class="hljs-title function_">filter</span>(numbers, <span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> num % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(evenNumbers); <span class="hljs-comment">// [2, 4]</span><br></code></pre></td></tr></table></figure><p>在上面的示例中，我们有一个包含整数的数组 **<code>numbers</code>**。我们使用 <strong><code>_.filter</code></strong> 和一个断言函数来筛选出偶数，并存储在 <strong><code>evenNumbers</code></strong> 数组中。断言函数检查每个数字是否为偶数，如果是偶数则返回 **<code>true</code>**，否则返回 **<code>false</code>**。因此，最终的输出为 **<code>[2, 4]</code>**，即原始数组中的偶数。</p><p>这些技术的应用都基于这些具有扩展性和强大功能的函数，它们不仅有助开发者写出干净的代码，还能够提高开发者对数据的理解。使用声明式的编程风格，开发者可以专注于应用程序的输出，而不是其实现，从而更深地理解应用程序。</p><h1 id="5、代码推理"><a href="#5、代码推理" class="headerlink" title="5、代码推理"></a>5、代码推理</h1><p>回想一下，在JavaScript中，共享着一个全局命名空间的成千上万行代码被一次性加载到单个页面中。尽管最近业务逻辑的模块划分领域得到了越来越多的重视，但仍有数以千计生成中的项目没有这么做。<br/><br>那么“代码推理”到底是什么意思呢？之前的章节用“松散”这个词来表征分析一个程序任何一个部分，并建立相应心智模型的难易程度。该模型分为两部分：动态部分包括所有变量的状态和函数的输出，而静态部分包含可读性以及设计的表达水平。两个部分都很重要。读者将在本书中了解到，不可变性和纯函数会使得该模型的构建更加容易。<br/><br>之前的内容强调将高阶操作链接起来构成程序的价值。命令式的程序流与函数式的程序流有着本质的不同。函数式的控制流能够在不需要研究任何内部细节的条件下提供该程序意图的清晰结构，这样就能更深刻地了解代码，并获知数据在不同阶段是如何流入和流出的。<br/></p><h2 id="声明式惰性计算函数链"><a href="#声明式惰性计算函数链" class="headerlink" title="声明式惰性计算函数链"></a><strong>声明式惰性计算函数链</strong></h2><blockquote><p><strong>声明式惰性计算函数链通常涉及到使用高阶函数、柯里化（currying）和延迟执行等技术。</strong></p></blockquote><p>第1章中提到，函数式程序是由一些简单函数组成的，尽管每个函数只完成一小部分功能，但组合在一起就能够解决很多复杂的任务。本节将介绍一种能够连接一组函数来构建整个程序的方法。<br/><br>函数式编程的声明式模型将程序视为对一些独立的纯函数的求值，从而在必要的抽象层次之上构建出流畅且表达清晰的代码。这样就可以构成一个能够清晰表达应用程序意图的本体或词汇表。使用如 map 、reduce 和 filter 这样的基石来搭建纯函数，可使代码易于推理并一目了然。<br/><br>这个层次的抽象的强大之处在于，它会使开发者开始认识到各种操作应该对所采用的底层数据结构不可见。从理论上说，无论是使用数组、链表、二叉树还是其他数据结构，它都不应该改变程序原本的语义。正是出于这个原因，函数式编程选择更关注于操作而不是数据结构。<br/><br>下面是一个简单的例子，展示了如何使用这些技术来创建一个声明式惰性计算函数链：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 声明一个简单的柯里化函数，用于计算阶乘</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">factorial</span>(<span class="hljs-params">n</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">m</span>) &#123;<br>    <span class="hljs-keyword">return</span> n * m;<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 使用柯里化函数来创建阶乘函数</span><br><span class="hljs-keyword">const</span> factorial5 = <span class="hljs-title function_">factorial</span>(<span class="hljs-number">5</span>);<br><br><span class="hljs-comment">// 使用阶乘函数计算结果</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">factorial5</span>(<span class="hljs-number">10</span>)); <span class="hljs-comment">// 输出 5 * 10 = 50</span><br><br><span class="hljs-comment">// 声明一个惰性计算的函数，它使用柯里化函数进行计算</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">lazyFactorial</span>(<span class="hljs-params">n</span>) &#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">factorial</span> = (<span class="hljs-params">n</span>) =&gt; <span class="hljs-function">(<span class="hljs-params">m</span>) =&gt;</span> n * m;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params">m</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">factorial</span>(n)(m);<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 使用惰性计算的函数来创建阶乘函数</span><br><span class="hljs-keyword">const</span> lazyFactorial5 = <span class="hljs-title function_">lazyFactorial</span>(<span class="hljs-number">5</span>);<br><br><span class="hljs-comment">// 在需要的时候进行计算</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">lazyFactorial5</span>(<span class="hljs-number">10</span>)); <span class="hljs-comment">// 输出 5 * 10 = 50</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">lazyFactorial5</span>(<span class="hljs-number">20</span>)); <span class="hljs-comment">// 输出 5 * 20 = 100</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>factorial</code> 是一个柯里化函数，它返回一个新的函数，这个新的函数会计算阶乘。<code>lazyFactorial</code> 是一个惰性计算的函数，它使用柯里化函数来创建一个新的函数，这个新的函数会在需要的时候进行计算。<br /><br><strong>Lodash的惰性计算函数链</strong><br /><br>Lodash 的 <code>_.chain</code> 方法可以创建一个惰性函数链。这个函数链允许使用链式编程（Chaining）的方式来组织一系列的函数调用。<br /><br>当使用 <code>_.chain</code> 方法时，Lodash 会返回一个新的函数。这个新函数会包装我们的原始函数，并将所有的操作都缓存起来，直到调用这个新函数的执行方法（例如 <code>.value()</code> 或 <code>.run()</code>）。<br /><br>举个例子，假设我们有一个简单的加法函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <code>_.chain</code> 方法，我们可以将其包装为一个惰性函数链：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;lodash&#x27;</span>);<br><span class="hljs-keyword">const</span> chainedAdd = _.<span class="hljs-title function_">chain</span>(add);<br></code></pre></td></tr></table></figure><p>现在，<code>chainedAdd</code> 是一个包装过的函数，它允许我们使用链式编程的方式来进行操作：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> result = <span class="hljs-title function_">chainedAdd</span>(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>).<span class="hljs-title function_">value</span>(); <span class="hljs-comment">// result is 3</span><br></code></pre></td></tr></table></figure><p>上述例子中，<code>chainedAdd(1)</code> 返回一个新的函数，它记住了 <code>add</code> 函数和第一个参数 <code>1</code>。然后，我们将第二个参数 <code>2</code> 传递给这个新函数，并调用 <code>.value()</code> 方法来执行这个惰性函数链。最后，我们得到了结果 <code>3</code>。</p><p>惰性计算的一个主要优点是它可以避免不必要的计算。例如，如果你有一个函数链，其中有一些操作是相互独立的，那么使用惰性计算可以确保这些操作只在必要的时候才会执行。这可以提高程序的性能和效率。</p><h2 id="类SQL的数据：函数即数据"><a href="#类SQL的数据：函数即数据" class="headerlink" title="类SQL的数据：函数即数据"></a><strong>类SQL的数据：函数即数据</strong></h2><p>本章已经介绍了各种各样的函数，比如map 、reduce 、filter 、groupBy 、sortBy 、uniq 等。将这些函数组成一个列表，可用来梳理数据相关的信息。如果在更高层面细细思考，就会发现这些函数与SQL相似，这不是偶然的。<br/></p><p>开发者惯于使用SQL及其功能来了解和梳理数据的含义。例如，可以用下表所示的内容来表示person对象的集合。<br><img src="/../img/function3-fn7.jpg" alt="表格化的person数据表示"></p><p>事实证明，在构建程序时，使用查询语言来思考与函数式编程中操作数组类似——使用通用关键字表或代数方法来增强对数据及其结构的深层次思考。下面的SQL查询语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> p.firstname, p.birthYear <span class="hljs-keyword">FROM</span> Person p<br><span class="hljs-keyword">WHERE</span> p.birthYear <span class="hljs-operator">&gt;</span> <span class="hljs-number">1903</span> <span class="hljs-keyword">and</span> p.country <span class="hljs-keyword">IS</span> <span class="hljs-keyword">NOT</span> <span class="hljs-string">&#x27;US&#x27;</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> p.firstname, p.birthYear<br></code></pre></td></tr></table></figure><p>使开发者能够清楚地看到运行此代码后数据是什么样子的。在实现此程序的 JavaScript 版本之前，先设置一些函数别名来辅助说明这一点。Lodash支持一种称为mixins 的功能，可以用来为核心库扩展新的函数，并使得它们可以以相同的方式连接：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">_.<span class="hljs-title function_">mixin</span>(&#123;<span class="hljs-string">&#x27;select&#x27;</span>: _.<span class="hljs-property">pluck</span>,<br>          <span class="hljs-string">&#x27;from&#x27;</span>: _.<span class="hljs-property">chain</span>,<br>          <span class="hljs-string">&#x27;where&#x27;</span>: _.<span class="hljs-property">filter</span>,<br>          <span class="hljs-string">&#x27;groupBy&#x27;</span>: _.<span class="hljs-property">sortByOrder</span>&#125;);  <br></code></pre></td></tr></table></figure><p>应用此 mixin 对象后，就可以编写出如下所示的程序。<br>类似 SQL 的 JavaScript 代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">_.<span class="hljs-title function_">from</span>(persons)<br>  .<span class="hljs-title function_">where</span>(<span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> p.<span class="hljs-property">birthYear</span> &gt; <span class="hljs-number">1900</span> &amp;&amp; p.<span class="hljs-property">address</span>.<span class="hljs-property">country</span> !== <span class="hljs-string">&#x27;US&#x27;</span>)<br>  .<span class="hljs-title function_">groupBy</span>([<span class="hljs-string">&#x27;firstname&#x27;</span>, <span class="hljs-string">&#x27;birthYear&#x27;</span>])<br>  .<span class="hljs-title function_">select</span>(<span class="hljs-string">&#x27;firstname&#x27;</span>, <span class="hljs-string">&#x27;birthYear&#x27;</span>)<br>  .<span class="hljs-title function_">value</span>();<br>  <span class="hljs-comment">// [&#x27;Alan&#x27;, &#x27;Barkley&#x27;, &#x27;John&#x27;]</span><br></code></pre></td></tr></table></figure><p>上述示例中，创建了一个SQL关键字到对应别名函数的映射，从而可以更深刻地理解一个查询语言的函数式特性。<br/><br><strong>JavaScript中的mixin</strong><br/><br>mixin 是定义与特定类型（也就是上例中 SQL 命令）相关的函数的抽象子集对象。该对象在代码中不会被直接使用，而是作为对另一个对象行为的扩展（它有点类似于其他编程语言中的特质）。目标对象则能够使用 mixin 中的各种功能。<br/><br>在面向对象的世界中，除了继承或者在不支持的语言中（比如 JavaScript 就是其中之一）模拟地多重继承，mixin是另一种代码重用的方式。本书中过多地介绍mixin，但如果能够正确使用，它会很强大。更多关于mixin的信息，参见<a href="https://javascriptweblog.wordpress.com/2011/05/31/a-fresh-look-at-javascript-mixins">https://javascriptweblog.wordpress.com/2011/05/31/a-fresh-look-at-javascript-mixins</a>。</p><blockquote><p>Lodash 的 mixins 是一种将自定义功能添加到 Lodash 库中的机制。通过 mixins，您可以将自己的函数与 Lodash 的核心函数混合在一起，以扩展 Lodash 的功能。</p></blockquote><p>在类SQL的数据模型中，mixins可以被视为一种将函数和数据结合在一起的机制。通过mixins，我们可以将一些函数定义为数据的一部分，并将它们与表中的数据进行关联。<br /><br>例如，假设我们有一个”users”表，其中包含用户的姓名、年龄和电子邮件地址等数据。我们可以创建一个mixin，将一些与用户相关的函数定义为该表的一部分。这些函数可以包括验证电子邮件地址是否有效、生成密码哈希值或检查用户是否符合特定条件的函数<br /><br>通过将这些函数定义为mixins，我们可以将它们与表中的数据进行关联，并在查询中使用它们。例如，我们可以编写一个查询来选择年龄大于18岁并且电子邮件地址有效的用户。在这种情况下，我们可以使用mixin中定义的函数来验证电子邮件地址是否有效，并将它们与表中的数据进行关联。<br /><br>总的来说，mixins提供了一种将函数和数据结合在一起的方法，以扩展类SQL的数据模型的功能。通过将函数定义为mixins，我们可以将它们与表中的数据进行关联，并在查询中使用它们来执行更复杂的操作。<br /><br><strong>要创建 Lodash mixins，您需要遵循一些简单的规则和最佳实践：</strong></p><ol><li><strong>将自定义函数放在一个对象中，该对象将作为 mixin 传递给 <code>_.mixin()</code> 方法。</strong></li><li><strong>确保自定义函数具有适当的命名，以避免与 Lodash 的核心函数发生冲突。</strong></li><li><strong>自定义函数应该使用 Lodash 的核心函数来实现其功能。</strong></li><li><strong>避免在 mixin 中覆盖 Lodash 的核心函数。</strong></li><li><strong>在 mixin 对象中使用一个属性 <code>length</code> 来指定应该从调用函数中排除的参数数量。</strong></li></ol><p><strong>下面是一个简单的示例，演示如何创建一个 Lodash mixin：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 自定义函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">greet</span>(<span class="hljs-params">name</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Hello, <span class="hljs-subst">$&#123;name&#125;</span>!`</span>);<br>&#125;<br><br><span class="hljs-comment">// 创建 mixin 对象</span><br><span class="hljs-keyword">const</span> myMixin = &#123;<br>  <span class="hljs-attr">greet</span>: greet,<br>&#125;;<br><br><span class="hljs-comment">// 将 mixin 添加到 Lodash 库中</span><br>_.<span class="hljs-title function_">mixin</span>(myMixin);<br><br><span class="hljs-comment">// 使用 mixin 中的函数</span><br>_.<span class="hljs-title function_">greet</span>(<span class="hljs-string">&#x27;John&#x27;</span>); <span class="hljs-comment">// 输出：Hello, John!</span><br></code></pre></td></tr></table></figure><p>通过将自定义函数添加到 mixin 对象中，并使用 <code>_.mixin()</code> 方法将其添加到 Lodash 库中，您就可以在您的代码中使用这些自定义函数，就像它们是 Lodash 核心函数一样。<br /><br>现在读者应该相信，函数式编程的抽象能力比命令式代码更加强大。还有比使用查询语言的语义来处理和解析数据更好的方法吗？像SQL一样，上面的 JavaScript 代码以函数的形式对数据进行建模，也就是函数即数据 。因为它是声明式的，描述了数据输出是什么 ，而不是数据是如何得到的 。到目前为止，并不需要任何常见的循环语句——本书的其余部分也不打算使用它们。相反，应该用高阶抽象代替循环。<br /><br>另一种用于替换循环的常见技术是递归，尤其当处理一些“自相似”的问题时，可以用其来抽象迭代。对于这些类型的问题，序列函数链会显得效率低下或不适用。而递归实现了自己的处理数据的方式，从而大大缩短了标准循环的执行时间。</p><h1 id="6、学会递归地思考"><a href="#6、学会递归地思考" class="headerlink" title="6、学会递归地思考"></a>6、学会递归地思考</h1><p>有时，要解决的问题是困难且复杂的。这种情况下，开发者应该立刻去寻找方法来分解它。如果问题可以分解成较小的问题，就可以逐个解决，再将这些结论组合起来构建出整个问题的解决方案。在Haskell、Scheme和Erlang这样的纯函数编程语言中，数组遍历是不能没有递归的，因为这些语言根本没有循环结构。<br/><br>而在JavaScript中，递归具有许多应用场景，例如解析XML、HTML文档或图形等。本节将解释什么是递归，然后通过一个练习教读者如何去递归地思考，最后将概述可以使用递归解析的几种数据结构。<br/></p><h2 id="递归（Recursion）"><a href="#递归（Recursion）" class="headerlink" title="递归（Recursion）"></a><strong>递归（Recursion）</strong></h2><p>递归是函数式编程的一个重要组成部分，它涉及到函数自我调用的概念。递归可以用于解决许多问题，包括计算阶乘、斐波那契数列、树的遍历等等。<br /><br>递归是一种旨在通过将问题分解成较小的自相似问题来解决问题本身的技术，将这些小的自相似问题结合在一起，就可以得到最终的解决方案。递归函数包含以下两个主要部分。<br /><br>•  基例（也称为终止条件）。<br /><br>•  递归条件。<br /><br>基例是能够令递归函数计算出具体结果的一组输入，而不必再重复下去。递归条件则处理函数调用自身的一组输入（必须小于原始值）。如果输入不变小，那么递归就会无限期地运行，直至程序崩溃。随着函数的递归，输入会无条件地变小，最终到达触发基例的条件，以一个值作为递归过程的终止。<br /><br>第2章使用递归来深度冻结整个嵌套的对象结构。如果遇到的对象是基本类型或已经被冻结，就会触发基例；否则，就会继续遍历对象结构，因为发现了更多未被冻结的对象。递归很适合处理这种问题，因为在任何一个层次上，要解决的任务是完全一样的。但是，递归思考可能会是一个挑战，下面开始吧。<br /></p><h2 id="学会递归地思考"><a href="#学会递归地思考" class="headerlink" title="学会递归地思考"></a><strong>学会递归地思考</strong></h2><p>递归的思考方式，其实就像解决生活中的问题一样，也需要分解问题，逐步解决。例如，如果我们有一个大的任务需要完成，我们可以将其分解为几个小任务，然后分别完成这些小任务。同样，在递归中，我们也需要将一个大问题分解为几个小问题，然后逐个解决这些小问题，最终解决大问题。<br /><br>递归不是一个容易掌握的概念。与函数式编程一样，最难的部分是忘记常规的方法。本书的重点不是让读者成为一个递归大师，因为它不是一种常用的技术手段。但重要的是，本书期望通过它来锻炼读者的大脑，并帮助读者更好地学习如何分析可递归的问题。<br /><br>递归地思考需要考虑递归自身以及自身的一个修改版本。递归对象是自定义的。例如，想象将树枝组合成一棵树。一个树枝有叶子以及其他的树枝，而它们又有更多的叶子和更多的树枝。这个过程将无限地持续下去，只有在达到外部限制时才会停止，本例中就是树的大小。<br /><br>下面基于这一思想来解决一个简单的问题：对数组中的所有数求和。先实现命令式的版本，再实现函数式的版本。命令式的大脑可以自然而然地形成一个解决方案，遍历数组并不断地累积一个值：<br /><br>数组中的所有数求和。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> acc = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.<span class="hljs-property">length</span>; i++)&#123;<br>  acc += nums[i];<br>&#125;<br></code></pre></td></tr></table></figure><p>通常开发者会使用一个累加器，因为要计算一个总和时，这绝对是必要的。但是需要使用循环吗？在这一点上，开发者很清楚可以使用函数式的武器（例如_.reduce ）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">_</span>(nums).<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc, current</span>) =&gt;</span> acc + current, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>将循环抽成框架，可以将应用程序代码抽象出来。但是可以做得更好，从代码中彻底移除迭代。使用函数 _.reduce 无须考虑循环，甚至是数组的大小。可以通过将第一个元素添加到其余部分来计算结果，从而实现递归思维。这种思想过程可以想象成如下的序列求和操作，这被称为横向思维：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">sum[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>] = <span class="hljs-number">1</span> + sum[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]<br>                       = <span class="hljs-number">1</span> + <span class="hljs-number">2</span> + sum[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]<br>                       = <span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span> + sum[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]<br></code></pre></td></tr></table></figure><p>递归和迭代是一枚硬币的两面。在不可变的条件下，递归提供了一种更具表现力、强大且优秀的迭代替代方法。事实上，纯函数式语言甚至没有标准的循环结构，如 do 、for 和 while ，因为所有循环都是递归完成的。递归使代码更易理解，因为它是以多次在较小的输入上重复相同的操作为基础的。下面示例中的递归解决方案使用 Lodash 的 _.first 和 _.rest 函数分别访问数组的第一个元素和剩余元素。<br/><br>递归求和</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">if</span>(_.<span class="hljs-title function_">isEmpty</span>(arr)) &#123; <span class="hljs-comment">//基例（终止条件）</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> _.<span class="hljs-title function_">first</span>(arr) + <span class="hljs-title function_">sum</span>(_.<span class="hljs-title function_">rest</span>(arr)); <span class="hljs-comment">// 递归条件：使用更小一些的输入集调用自身。这里通过_.first和_.rest 缩减输入集</span><br>&#125;<br><span class="hljs-title function_">sum</span>([]); <span class="hljs-comment">//-&gt; 0</span><br><span class="hljs-title function_">sum</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]); <span class="hljs-comment">//-&gt;45</span><br></code></pre></td></tr></table></figure><p>空数组会满足基例，返回 0。而对于非空数组，就会继续将第一个元素与数组的其余部分递归地求和。从底层来看，递归调用会在栈中不断堆叠。当算法满足终止条件时，运行时就会展开调用栈并执行加操作，因此所有返回语句都将被执行。递归就是通过语言运行时这种机制代替了循环。<br/><br>以下是算法实现的步骤视图：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1</span> + sum[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]<br><span class="hljs-number">1</span> + <span class="hljs-number">2</span> +sum[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]<br><span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span> + sum[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]<br><span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span> + <span class="hljs-number">4</span> + sum[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]<br><span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span> + <span class="hljs-number">4</span> + <span class="hljs-number">5</span> + sum[<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]<br><span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span> + <span class="hljs-number">4</span> + <span class="hljs-number">5</span> + <span class="hljs-number">6</span> + sum[<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]<br><span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span> + <span class="hljs-number">4</span> + <span class="hljs-number">5</span> + <span class="hljs-number">6</span> + <span class="hljs-number">7</span> + sum[<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]<br><span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span> + <span class="hljs-number">4</span> + <span class="hljs-number">5</span> + <span class="hljs-number">6</span> + <span class="hljs-number">7</span> + <span class="hljs-number">8</span> + sum[<span class="hljs-number">9</span>]<br><span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span> + <span class="hljs-number">4</span> + <span class="hljs-number">5</span> + <span class="hljs-number">6</span> + <span class="hljs-number">7</span> + <span class="hljs-number">8</span> + <span class="hljs-number">9</span> + sum[]<br><span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span> + <span class="hljs-number">4</span> + <span class="hljs-number">5</span> + <span class="hljs-number">6</span> + <span class="hljs-number">7</span> + <span class="hljs-number">8</span> + <span class="hljs-number">9</span> + <span class="hljs-number">0</span>   <span class="hljs-comment">//-&gt;halts, stack unwinds</span><br><span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span> + <span class="hljs-number">4</span> + <span class="hljs-number">5</span> + <span class="hljs-number">6</span> + <span class="hljs-number">7</span> + <span class="hljs-number">8</span> + <span class="hljs-number">9</span><br><span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span> + <span class="hljs-number">4</span> + <span class="hljs-number">5</span> + <span class="hljs-number">6</span> + <span class="hljs-number">7</span> + <span class="hljs-number">17</span><br><span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span> + <span class="hljs-number">4</span> + <span class="hljs-number">5</span> + <span class="hljs-number">6</span> + <span class="hljs-number">24</span><br><span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span> + <span class="hljs-number">4</span> + <span class="hljs-number">5</span> + <span class="hljs-number">30</span><br><span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span> + <span class="hljs-number">4</span> + <span class="hljs-number">35</span><br><span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">3</span> + <span class="hljs-number">39</span><br><span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">42</span><br><span class="hljs-number">1</span> + <span class="hljs-number">44</span><br><span class="hljs-number">45</span><br></code></pre></td></tr></table></figure><p>看到这里，自然要考虑一下递归和迭代的性能问题。毕竟，编译器在处理循环的优化问题上是非常强大的。JavaScript 的 ES6 带来了一种称之为尾调用优化 的优化功能，可以使递归和迭代的性能表现更加接近。考虑一个稍微有所不同的sum 实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">arr, acc = <span class="hljs-number">0</span></span>) &#123;<br>  <span class="hljs-keyword">if</span>(_.<span class="hljs-title function_">isEmpty</span>(arr)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">sum</span>(_.<span class="hljs-title function_">rest</span>(arr), acc + _.<span class="hljs-title function_">first</span>(arr)); <span class="hljs-comment">//&lt;---发生在尾部的递归调用</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这个版本的实现将递归调用作为函数体中最后的步骤，也就是尾部位置。在第7章讨论函数式优化问题时，我们会探索这样做的好处。</p><h2 id="递归定义的数据结构"><a href="#递归定义的数据结构" class="headerlink" title="递归定义的数据结构"></a>递归定义的数据结构</h2><blockquote><p>递归定义的数据结构主要有栈和树</p></blockquote><p>栈是一种具有特殊性质的数据结构，其操作方式主要是后进先出（LIFO），即最后添加到栈中的元素最先被取出。递归在栈中的应用主要体现在活动记录和递归调用上，每次方法调用都会创建一个新的活动记录，将方法调用的状态和局部变量压入栈中，当方法返回时，再从栈中弹出活动记录，恢复方法调用的状态，继续执行后续代码。</p><p>树是一种非线性数据结构，由节点和边组成，其中节点表示元素，边表示节点之间的父子关系。递归在树中的应用主要体现在树的遍历上，例如二叉树的深度优先遍历和广度优先遍历，都可以使用递归实现。在深度优先遍历中，递归函数会根据当前节点的状态进行不同的操作，例如对于叶子节点，直接返回；对于左子节点，递归调用深度优先遍历函数；对于右子节点，递归调用深度优先遍历函数。在广度优先遍历中，递归函数会依次访问每个节点的左子节点和右子节点，然后再访问其父节点。</p><p>总的来说，递归在数据结构中的应用能够使代码更加简洁、易于理解和维护。</p><p>读者可能想知道person 对象示例数据中的那些名字。20世纪 20 年代，函数式编程（lambda 演算、范畴论等）背后的数学社区非常活跃。大部分发表的研究成果都是融合一些由Alonzo Church 这样的知名大学教授提出的思想和定理。事实上，许多数学家，如Barkley Rosser、Alan Turing和Stephen Kleene等，都是Church 的博士生。后来他们也有了自己的博士生。下图为这种师徒关系（的一部分）的示意图。<br><img src="/../img/function3-fn8.jpg" alt="函数式编程发展历程中具有杰出贡献和影响力的数学家。树形结构中从父节点到子节点的连线代表了“是其学生”这种关系"></p><p>这种结构在软件中是很寻常的，它可用于建模XML文档、文件系统、分类法、种别、菜单部件、逐级导航、社交图谱等，所以学习如何处理它们至关重要。上图显示了一组节点，其连线表示了导师-学生这一关系。到目前为止，我们已经利用函数式技术解析过一些扁平化的数据结构，如数组。但这些操作对树形数据是无效的。因为 JavaScript 没有内置的树型对象，所以需要基于节点创建一种简单的数据结构。节点是一种包含了当前值、父节点引用以及子节点数组的对象。在上图中，Rosser 的父节点是 Church ，其子节点有 Mendelson 和 Sacks 。如果一个节点没有父节点，比如 Church ，则被称为根节点。以下是节点 类型的定义，代码如下所示。<br/><br>节点对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">val</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_val</span> = val;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_parent</span> = <span class="hljs-literal">null</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_children</span> = [];<br>  &#125;<br>  <span class="hljs-title function_">isRoot</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">isValid</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">_parent</span>); <span class="hljs-comment">//&lt;---之前创建的函数</span><br>  &#125;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">children</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_children</span>;<br>  &#125;<br>  <span class="hljs-title function_">hasChildren</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_children</span>.<span class="hljs-property">length</span> &gt; <span class="hljs-number">0</span>;<br>  &#125;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">value</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_val</span>;<br>  &#125;<br>  <span class="hljs-keyword">set</span> <span class="hljs-title function_">value</span>(<span class="hljs-params">val</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_val</span> = val;<br>  &#125;<br>  <span class="hljs-title function_">append</span>(<span class="hljs-params">child</span>) &#123;<br>    child.<span class="hljs-property">_parent</span> = <span class="hljs-variable language_">this</span>; <span class="hljs-comment">//&lt;--- 设置父节点</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_children</span>.<span class="hljs-title function_">push</span>(child); <span class="hljs-comment">//&lt;---孩子节点加入孩子列表中</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>; <span class="hljs-comment">//&lt;--- 返回该节点（便于方法级联）</span><br>  &#125;<br>  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`Node (val: <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>._val&#125;</span>, children:<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>._children.length&#125;</span>)`</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以这样创建一个新节点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> church = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Alonzo&#x27;</span>, <span class="hljs-string">&#x27;Church&#x27;</span>, <span class="hljs-string">&#x27;111-11-1111&#x27;</span>));<span class="hljs-comment">// &lt;--- 重复树中的所有节点</span><br></code></pre></td></tr></table></figure><p>树是包含了一个根节点的递归定义的数据结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tree</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">root</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_root</span> = root;<br>  &#125;<br>  <span class="hljs-keyword">static</span> <span class="hljs-title function_">map</span>(<span class="hljs-params">node, fn, tree = <span class="hljs-literal">null</span></span>) &#123; <span class="hljs-comment">//&lt;---使用静态方法以免与Array.prototype.map混淆。静态方法也能像单例函数一样高效</span><br>    node.<span class="hljs-property">value</span> = <span class="hljs-title function_">fn</span>(node.<span class="hljs-property">value</span>);  <span class="hljs-comment">//&lt;---调用遍历器函数，并更新树中的节点值</span><br>    <span class="hljs-keyword">if</span>(tree === <span class="hljs-literal">null</span>) &#123;<br>      tree = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Tree</span>(node);  <span class="hljs-comment">//&lt;---与 Array.prototype.map 类似。结果是一个新的结构</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(node.<span class="hljs-title function_">hasChildren</span>()) &#123; <span class="hljs-comment">//&lt;---如果节点没有孩子，则返回（基例）</span><br>      _.<span class="hljs-title function_">map</span>(node.<span class="hljs-property">children</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">child</span>) &#123; <span class="hljs-comment">//&lt;---将函数应用到每一个孩子节点</span><br>        <span class="hljs-title class_">Tree</span>.<span class="hljs-title function_">map</span>(child, fn, tree); <span class="hljs-comment">//&lt;--- 递归地调用每一个孩子节点</span><br>      &#125;);<br>    &#125;<br>    <span class="hljs-keyword">return</span> tree;<br>  &#125;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">root</span>() &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_root</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>节点的主要逻辑在于 append 方法。要给一个节点追加一个子节点，需要将该节点设置为子节点的 parent 引用，并把子节点添加至该节点的子节点列表中。通过从根部不断地将节点链接到其他子节点来填充一棵树，由 church 开始：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">church.<span class="hljs-title function_">append</span>(rosser).<span class="hljs-title function_">append</span>(turing).<span class="hljs-title function_">append</span>(kleene);<br>kleene.<span class="hljs-title function_">append</span>(nelson).<span class="hljs-title function_">append</span>(constable);<br>rosser.<span class="hljs-title function_">append</span>(mendelson).<span class="hljs-title function_">append</span>(sacks);<br>turing.<span class="hljs-title function_">append</span>(gandy);<br></code></pre></td></tr></table></figure><p>每个节点都包裹着一个 person 对象。递归算法执行整个树的先序遍历，从根开始并且下降到所有子节点。由于其自相似性，从根节点遍历树和从任何节点遍历子树是完全一样的，这就是递归定义。为此，可以使用与 Array.prototype.map 语义类似的高阶函数 Tree.map ——它接收一个对每个节点求值的函数。可以看出，无论用什么数据结构来建模（这里是树形数据结构），该函数的语义应该保持不变。从本质上讲，任何数据类型都可以使用map并保持其结构不变。本书第5章会更正式地介绍这种保持数据结构的映射函数。<br/><br>树的先序遍历按照以下步骤执行，从根节点开始。<br/><br>1）显示根元素的数据部分。<br/><br>2）通过递归地调用先序函数来遍历左子树。<br/><br>3）以相同的方式遍历右子树。<br/><br>下图显示了算法采用的路径。<br/><br><img src="/../img/function3-fn9.jpg" alt="递归的先序遍历，从根节点开始，一直向左下降，然后再向右移动"><br>函数 Tree.map 有两个必需的输入：根节点（即树的开始）以及转换每个节点数值的迭代函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Tree</span>.<span class="hljs-title function_">map</span>(church, <span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> p.<span class="hljs-property">fullname</span>);<br></code></pre></td></tr></table></figure><p>它以先序方式遍历树，并将给定的函数应用于每个节点，输出以下结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;Alonzo Church&#x27;</span>, <span class="hljs-string">&#x27;Barkley Rosser&#x27;</span>, <span class="hljs-string">&#x27;Elliot Mendelson&#x27;</span>, <span class="hljs-string">&#x27;Gerald Sacks&#x27;</span>, <span class="hljs-string">&#x27;Alan Turing&#x27;</span>, <span class="hljs-string">&#x27;Robin Gandy&#x27;</span>, <span class="hljs-string">&#x27;Stephen Kleene&#x27;</span>, <span class="hljs-string">&#x27;Nels Nelson&#x27;</span>, <span class="hljs-string">&#x27;Robert Constable&#x27;</span><br></code></pre></td></tr></table></figure><p>在操作不可变、无副作用的数据类型时，封装数据以控制其访问的思想是函数式编程的关键。本书第5章将进一步介绍这一思想。解析数据结构是软件和函数式编程最基本的方面之一。本章更深入地探讨了利用可扩展函数库（即Lodash）中的函数式特性来进行函数式风格的 JavaScript 开发。这种风格有利于流式建模，将包含业务逻辑的高阶操作连接在一起，从而达到最终的业务目的。<br>不可否认的是，编写流式风格的代码也有利于可重用性和模块化，但目前的讨论还比较浅显。本书第4章更深入地介绍流式编程，将重点放在构建真正的函数管道上。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1、高阶函数，如 map、reduce 和 filter，是函数式编程的重要组成部分，也是提高代码可扩展性的重要工具。这些函数可以接收其他函数作为参数，或者返回一个函数作为结果，从而让代码更加模块化和可复用。<br /><br>2、Lodash是一个非常流行的工具库，它提供了许多有用的函数来处理数组、对象和其他数据类型。通过使用Lodash，我们可以更轻松地处理数据，同时可以创建控制流和数据交换明确分离的程序。<br /><br>3、使用声明式的函数式编程可以帮助我们编写更易理解、可维护和可扩展的程序。它强调的是计算结果值，而不是副作用和状态变化，这使得代码更加简洁、可读性更好、可维护性更强。<br /><br>4、可以通过编写函数将高阶抽象映射到SQL语句，从而更深入地理解数据。这种抽象映射可以帮助简化SQL语句的编写和执行，提高代码的可读性和可维护性。<br /><br>5、递归在计算机科学中是一种非常强大的解决问题的方法，它可以用来解决许多复杂的问题，包括自相似问题。</p>]]></content>
    
    
    <categories>
      
      <category>函数式编程指南</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书分享</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《JavaScript函数式编程指南》第二章 ⾼阶JavaScript</title>
    <link href="/2023/11/19/functionalProgramming/book2/"/>
    <url>/2023/11/19/functionalProgramming/book2/</url>
    
    <content type="html"><![CDATA[<h1 id="第二章-⾼阶JavaScript"><a href="#第二章-⾼阶JavaScript" class="headerlink" title="第二章 ⾼阶JavaScript"></a>第二章 ⾼阶JavaScript</h1><h2 id="函数式与面向对象-OOP"><a href="#函数式与面向对象-OOP" class="headerlink" title="函数式与面向对象(OOP)"></a>函数式与面向对象(OOP)</h2><blockquote><p>面向对象的JavaScript<br>当说到⼀个对象与另⼀个对象之间具有⼦类型或派⽣类型的关系时， 指的是它们之间存在的原型关系。有必要指出，尽管 JavaScript 是⾯向对 象的，但其并不具备像 Java 这样的语⾔中典型的继承关系。<br>在ES6中，可以通过使⽤像关键字class 和extends 这样的语法糖 来建⽴对象之间的原型链接（尽管很多情况下这样做是不对的）。这样的 特性使得定义对象之间的继承更加简单，但却隐藏了 JavaScript 强⼤的原 型机制的真实⾏为。</p></blockquote><p>⾯向对象的应⽤程序⼤多是命令式的，因此在很⼤程度上依赖于使⽤基于对象的封装来保护其⾃⾝和继承的可变状态的完整性，再通过实例⽅法来暴露或修改这些状态。其结果是，对象的数据与其具体的⾏为以⼀种内聚的包裹的形式紧耦合在⼀起。⽽这就是⾯向对象程序的⽬的，也正解释了为什么对象是抽象的核⼼。</p><p>再看函数式编程，它不需要对调⽤者隐藏数据，通常使⽤⼀些更 ⼩且⾮常简单的数据类型。由于⼀切都是不可变的，对象都是可以直接拿来使⽤的，⽽且是通过定义在对象作⽤域外的函数来实现的。换句话说，数据与⾏为是松耦合的。</p><p><img src="/../img/function2-oop1.png" alt="⾯向对象的程序设计通过特定的⾏为将很多数据类型逻辑地连接在⼀起，函数式编程 则关注如何在这些数据类型之上通过组合来连接各种操作。因此存在⼀个两种编程范式都可 以被有效利⽤的平衡点。"></p><p>在实践中，⼀些极好的⾯向对象代码均使⽤了两种编程范式——正是在这个相交的平衡点上。要做到这⼀点，你需要把对象视为不可变的实 体或值，并将它们的功能拆分成可应⽤在该对象上的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-keyword">get</span> <span class="hljs-title function_">fullname</span>() &#123;<br>    <span class="hljs-comment">// ⽐如在 ⽅法中，会推荐使⽤this来访问对象的状态</span><br>    <span class="hljs-keyword">return</span> [<span class="hljs-variable language_">this</span>.<span class="hljs-property">_firstname</span>, <span class="hljs-variable language_">this</span>.<span class="hljs-property">_lastname</span>].<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27; &#x27;</span>); <br> &#125;<br><br><span class="hljs-comment">// 拆分出如下的函数 函数中this可以替换为传⼊的参数对象</span><br> <span class="hljs-keyword">var</span> <span class="hljs-title function_">fullname</span> = person =&gt; [person.<span class="hljs-property">firstname</span>, person.<span class="hljs-property">lastname</span>].<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27; &#x27;</span>);<br></code></pre></td></tr></table></figure><p><img src="/../img/function2-oop2.png" alt="⾯向对象的关键是创建继承层次结构（如继承Person 的Student 对象）并将⽅法与 数据紧密的绑定在⼀起。函数式编程则更倾向于通过⼴义的多态函数交叉应⽤于不同的数据 类型，同时避免使⽤this"></p><p>将fullname()分离⾄独⽴的函数，可以避免使⽤ this 引⽤来访问对象数据。使⽤this的缺点是它给予了超出⽅法作⽤域的实例层级的数据访问能⼒，从⽽可能导致副作⽤。<code>使⽤函数式编程，对象数据不再与代码的特定部分紧密耦合，从⽽更具重⽤性和可维护性</code>。</p><p>对象类中的peopleInSameCountry和studentsInSameCountryAndSchool，使⽤this和super 将各种操作与当前对象以及⽗对象紧紧地耦合在⼀起。</p><p><a href="https://code.juejin.cn/pen/7303183148479676470">代码在线演示</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 任务1: 是找到与给定的学⽣⽣活在同⼀国家的所有朋友</span><br><span class="hljs-comment"> * 任务2: 找到与给定的学⽣⽣活在同⼀个国家且在同⼀所学校上学的所有学⽣</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 任务1: 是找到与给定的学⽣⽣活在同⼀国家的所有朋友</span><br><span class="hljs-comment"> * 任务2: 找到与给定的学⽣⽣活在同⼀个国家且在同⼀所学校上学的所有学⽣</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Address</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">country, state, city, zip, street</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_country</span> = country;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_state</span> = state;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_city</span> = city;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_zip</span> = zip;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_street</span> = street;<br>  &#125;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">street</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_street</span>;<br>  &#125;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">city</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_city</span>;<br>  &#125;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">state</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_state</span>;<br>  &#125;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">zip</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_zip</span>;<br>  &#125;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">country</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_country</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">firstname, lastname, ssn</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_firstname</span> = firstname;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_lastname</span> = lastname;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_ssn</span> = ssn;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_address</span> = <span class="hljs-literal">null</span>;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_birthYear</span> = <span class="hljs-literal">null</span>;<br>  &#125;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">ssn</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_ssn</span>;<br>  &#125;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">firstname</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_firstname</span>;<br>  &#125;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">lastname</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_lastname</span>;<br>  &#125;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">address</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_address</span>;<br>  &#125;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">birthYear</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_birthYear</span>;<br>  &#125;<br>  <span class="hljs-comment">//使⽤setter⽅法并不代表要改变对象，⽽只是创 建含有不同属性的对象，⽽且⽆需⻓参数构造函数的⽅式。在创建并设置好对象后，它们 的状态将不会改变（本章之后的部分会解释处理⽅式）</span><br>  <span class="hljs-keyword">set</span> <span class="hljs-title function_">birthYear</span>(<span class="hljs-params">year</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_birthYear</span> = year;<br>  &#125;<br>  <span class="hljs-comment">// 使⽤setter⽅法并不代表要改变对象，⽽只是创建含 有不同属性的对象，⽽且⽆需⻓参数构造函数的⽅式。在创建并设置好对象后，它们的状态将不会改变（本章后的部分会解释处理⽅式）</span><br>  <span class="hljs-keyword">set</span> <span class="hljs-title function_">address</span>(<span class="hljs-params">addr</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_address</span> = addr;<br>  &#125;<br>  <span class="hljs-title function_">toString</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`Person(<span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>._firstname&#125;</span>, <span class="hljs-subst">$&#123;<span class="hljs-variable language_">this</span>._lastname&#125;</span>)`</span>;<br>  &#125;<br>  <span class="hljs-comment">// Person class</span><br>  <span class="hljs-title function_">peopleInSameCountry</span>(<span class="hljs-params">friends</span>) &#123;<br>    <span class="hljs-keyword">var</span> result = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> idx <span class="hljs-keyword">in</span> friends) &#123;<br>      <span class="hljs-keyword">var</span> friend = friends[idx];<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">address</span>.<span class="hljs-property">country</span> === friend.<span class="hljs-property">address</span>.<span class="hljs-property">country</span>) &#123;<br>        result.<span class="hljs-title function_">push</span>(friend);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;;<br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Person</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">firstname, lastname, ssn, school</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(firstname, lastname, ssn);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">_school</span> = school;<br>  &#125;<br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">school</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">_school</span>;<br>  &#125;<br>  <span class="hljs-comment">// Student class</span><br>  <span class="hljs-comment">// 使⽤super调⽤⽗类的数据</span><br>  <span class="hljs-title function_">studentsInSameCountryAndSchool</span>(<span class="hljs-params">friends</span>) &#123;<br>    <span class="hljs-keyword">var</span> closeFriends = <span class="hljs-variable language_">super</span>.<span class="hljs-title function_">peopleInSameCountry</span>(friends);<br>    <span class="hljs-keyword">var</span> result = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> idx <span class="hljs-keyword">in</span> closeFriends) &#123;<br>      <span class="hljs-keyword">var</span> friend = closeFriends[idx];<br>      <span class="hljs-keyword">if</span> (friend.<span class="hljs-property">school</span> === <span class="hljs-variable language_">this</span>.<span class="hljs-property">school</span>) &#123;<br>        result.<span class="hljs-title function_">push</span>(friend);<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>  &#125;;<br>&#125;<br><br><br><span class="hljs-keyword">var</span> curry = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&#x27;Haskell&#x27;</span>, <span class="hljs-string">&#x27;Curry&#x27;</span>,<br> <span class="hljs-string">&#x27;111-11-1111&#x27;</span>, <span class="hljs-string">&#x27;Penn State&#x27;</span>);<br>curry.<span class="hljs-property">address</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>(<span class="hljs-string">&#x27;US&#x27;</span>);<br><span class="hljs-keyword">var</span> turing = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&#x27;Alan&#x27;</span>, <span class="hljs-string">&#x27;Turing&#x27;</span>,<span class="hljs-string">&#x27;222-22-2222&#x27;</span>, <span class="hljs-string">&#x27;Princeton&#x27;</span>);<br>turing.<span class="hljs-property">address</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>(<span class="hljs-string">&#x27;England&#x27;</span>);<br><span class="hljs-keyword">var</span> church = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&#x27;Alonzo&#x27;</span>, <span class="hljs-string">&#x27;Church&#x27;</span>,<br> <span class="hljs-string">&#x27;333-33-3333&#x27;</span>, <span class="hljs-string">&#x27;Princeton&#x27;</span>);<br>church.<span class="hljs-property">address</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>(<span class="hljs-string">&#x27;US&#x27;</span>);<br><span class="hljs-keyword">var</span> kleene = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&#x27;Stephen&#x27;</span>, <span class="hljs-string">&#x27;Kleene&#x27;</span>,<br> <span class="hljs-string">&#x27;444-44-4444&#x27;</span>, <span class="hljs-string">&#x27;Princeton&#x27;</span>);<br>kleene.<span class="hljs-property">address</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>(<span class="hljs-string">&#x27;US&#x27;</span>);<br><br><span class="hljs-comment">// Stephen-Kleene</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(church.<span class="hljs-title function_">studentsInSameCountryAndSchool</span>([curry, turing, kleene]).<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">t</span> =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;t.firstname&#125;</span>-<span class="hljs-subst">$&#123;t.lastname&#125;</span>`</span>))<br><br><br><span class="hljs-comment">// 创建selector函数，⽤来⽐较学⽣的国籍与学校</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">selector</span>(<span class="hljs-params">country, school</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">student</span>) &#123;<br>    <span class="hljs-comment">//访问对象。 我会在本章后⾯的部分展⽰访问对象的更好⽅式</span><br>    <span class="hljs-keyword">return</span> student.<span class="hljs-property">address</span>.<span class="hljs-property">country</span> === country &amp;&amp; student.<span class="hljs-property">school</span> === school;<br>  &#125;;<br>&#125;<br><span class="hljs-comment">// 使⽤filter⽤selector过滤数组</span><br><span class="hljs-keyword">var</span> findStudentsBy = <span class="hljs-keyword">function</span> (<span class="hljs-params">friends, selector</span>) &#123;<br>  <span class="hljs-keyword">return</span> friends.<span class="hljs-title function_">filter</span>(selector);<br>&#125;;<br><br><span class="hljs-comment">// Alonzo-Church,Stephen-Kleene</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">findStudentsBy</span>([curry, turing, church, kleene], <span class="hljs-title function_">selector</span>(<span class="hljs-string">&#x27;US&#x27;</span>, <span class="hljs-string">&#x27;Princeton&#x27;</span>)).<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">t</span> =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;t.firstname&#125;</span>-<span class="hljs-subst">$&#123;t.lastname&#125;</span>`</span>));<br><br><br></code></pre></td></tr></table></figure><p>⾯向对象和函数式编程⼀些重要性质的⽐较如下：</p><table><thead><tr><th></th><th>函数式</th><th>⾯向对象</th></tr></thead><tbody><tr><td>组合单元</td><td>函数</td><td>对象（类）</td></tr><tr><td>编程⻛格</td><td>声明式</td><td>命令式</td></tr><tr><td>数据和⾏为</td><td>独⽴且松耦合的纯函数</td><td>与⽅法紧耦合的类</td></tr><tr><td>状态管理</td><td>将对象视为不可变的值</td><td>主张通过实例⽅法改变对象</td></tr><tr><td>程序流控制</td><td>函数与递归</td><td>循环与条件</td></tr><tr><td>线程安全</td><td>可并发编程</td><td>难以实现</td></tr><tr><td>封装性</td><td>因为⼀切都是不可变的，所以没有必要</td><td>因为⼀切都是不可变的</td></tr></tbody></table><p>尽管它们之间存在差异，但有效构建应⽤程序的⽅法是混合两种 范式。⼀⽅⾯，可以使⽤与组成类型之间存在⾃然关系的富领域模型；另⼀⽅⾯，可以拥有⼀组能够应⽤于这些类型之上的纯函数。</p><p>由于JavaScript 既是⾯向对象的，⼜是函数式的，因此在编写函数式代码时，需要特别注意控制状态的变化。</p><h3 id="管理JavaScript对象的状态"><a href="#管理JavaScript对象的状态" class="headerlink" title="管理JavaScript对象的状态"></a>管理JavaScript对象的状态</h3><p>程序的状态可以定义为在任⼀时刻存储在所有对象之中的数据快照。</p><p>可惜的是，JavaScript 是在对象状态安全⽅⾯做得最差的语⾔之 ⼀。JavaScript 的对象是⾼度动态的，其属性可以在任何时间被修改、 增加或删除。</p><h3 id="将对象视为数值"><a href="#将对象视为数值" class="headerlink" title="将对象视为数值"></a>将对象视为数值</h3><h4 id="函数式编程中的数值"><a href="#函数式编程中的数值" class="headerlink" title="函数式编程中的数值"></a>函数式编程中的数值</h4><p>字符串和数字 - 是任何编程语⾔中最简单的数据类型 这样认为 WHY?<br>部分原因在于，在传统意义上，这些原始类型本 ⾝就是不可变的，⽽这给我们的内⼼带来了其他⾃定义类型所⽆法给予的平和。<br>在函数式编程中，我们将具有此种⾏为的类型称为数值。</p><h4 id="JavaScript的对象也只是可在任意时间添加、删除和更改的属性包⽽已。如何解决？"><a href="#JavaScript的对象也只是可在任意时间添加、删除和更改的属性包⽽已。如何解决？" class="headerlink" title="JavaScript的对象也只是可在任意时间添加、删除和更改的属性包⽽已。如何解决？"></a>JavaScript的对象也只是可在任意时间添加、删除和更改的属性包⽽已。如何解决？</h4><p>ES6的const关键字并不能达到函数式编程所需要的不可变性的⽀持⽔平</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> gravity_ms = <span class="hljs-number">9.806</span>;<br>gravity_ms = <span class="hljs-number">20</span>; <span class="hljs-comment">// JavaScript会在运⾏时阻⽌再赋值</span><br><br><br><span class="hljs-keyword">const</span> student = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-string">&#x27;Alonzo&#x27;</span>, <span class="hljs-string">&#x27;Church&#x27;</span>, <span class="hljs-string">&#x27;666-66-6666&#x27;</span>, <span class="hljs-string">&#x27;Princeton&#x27;</span>);<br>student.<span class="hljs-property">lastname</span> = <span class="hljs-string">&#x27;Mourning&#x27;</span>; <span class="hljs-comment">// 属性已经变了</span><br></code></pre></td></tr></table></figure><p>在 JavaScript 中，可以使⽤函数来保障 ZIP code 的内部状态访问 权限，通过返回⼀个对象字⾯接⼝ 来公开⼀⼩部分⽅法给调⽤者，这样就可以将_code 和_location 视为伪私有变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">zipCode</span>(<span class="hljs-params">code, location</span>) &#123;<br> <span class="hljs-keyword">let</span> _code = code;<br> <span class="hljs-keyword">let</span> _location = location || <span class="hljs-string">&#x27;&#x27;</span>;<br> <span class="hljs-keyword">return</span> &#123;<br>  <span class="hljs-attr">code</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> _code;<br>  &#125;,<br>  <span class="hljs-attr">location</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> _location;<br>  &#125;,<br>  <span class="hljs-attr">fromString</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">str</span>) &#123;<br>    <span class="hljs-keyword">let</span> parts = str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;-&#x27;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-title function_">zipCode</span>(parts[<span class="hljs-number">0</span>], parts[<span class="hljs-number">1</span>]);<br>  &#125;,<br>  <span class="hljs-attr">toString</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> _code + <span class="hljs-string">&#x27;-&#x27;</span> + _location;<br>  &#125;<br> &#125;;<br>&#125;<br><span class="hljs-keyword">const</span> princetonZip = <span class="hljs-title function_">zipCode</span>(<span class="hljs-string">&#x27;08544&#x27;</span>, <span class="hljs-string">&#x27;3345&#x27;</span>);<br>princetonZip.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">//&#x27;08544-3345&#x27;</span><br></code></pre></td></tr></table></figure><p>值对象是⼀种可简单应⽤于⾯向对象和函数式编程的轻量级⽅式。与关键字const组合在⼀起使⽤，我们就可以创建具有与字符串或数字类似语义的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">coordinate</span>(<span class="hljs-params">lat, long</span>) &#123;<br>  <span class="hljs-keyword">let</span> _lat = lat;<br>  <span class="hljs-keyword">let</span> _long = long;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">latitude</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> _lat;<br>    &#125;,<br>    <span class="hljs-attr">longitude</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> _long;<br>    &#125;,<br>    <span class="hljs-comment">// 让⽅法返回⼀个新的副本（例如 translate ）是另⼀种实现不s可变性的⽅式。</span><br>    <span class="hljs-attr">translate</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">dx, dy</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-title function_">coordinate</span>(_lat + dx, _long + dy); <span class="hljs-comment">// 返回翻译过的 坐标副本</span><br>    &#125;,<br>    <span class="hljs-attr">toString</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;(&#x27;</span> + _lat + <span class="hljs-string">&#x27;,&#x27;</span> + _long + <span class="hljs-string">&#x27;)&#x27;</span>;<br>    &#125;<br> &#125;;<br>&#125;<br><span class="hljs-keyword">const</span> greenwich = <span class="hljs-title function_">coordinate</span>(<span class="hljs-number">51.4778</span>, <span class="hljs-number">0.0015</span>);<br>greenwich.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &#x27;(51.4778, 0.0015)&#x27;</span><br></code></pre></td></tr></table></figure><p>值对象是⼀个由函数式编程启发⽽来的⾯向对象设计模式。</p><h3 id="深冻结可变部分"><a href="#深冻结可变部分" class="headerlink" title="深冻结可变部分"></a>深冻结可变部分</h3><p>JavaScript 的Object.freeze()函数可以通过writable隐藏对象元属性设置为false来阻⽌对象状态的改变。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> person = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Haskell&#x27;</span>, <span class="hljs-string">&#x27;Curry&#x27;</span>, <span class="hljs-string">&#x27;444-44-4444&#x27;</span>));<br>person.<span class="hljs-property">firstname</span> = <span class="hljs-string">&#x27;Bob&#x27;</span>; <span class="hljs-comment">// 不被允许 TypeError: Cannot assign to read only property &#x27;_firstname&#x27; of #&lt;Person&gt;</span><br></code></pre></td></tr></table></figure><p>Object.freeze()不能被⽤于冻结嵌套对象属性.</p><p><img src="/../img/function2-oop3.png" alt="只有顶层变量会被冻结，该Object.freeze机制是浅冻结"></p><p>要解决浅冻结问题，需要⼿动冻结对象的嵌套结构.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title function_">isObject</span> = (<span class="hljs-params">val</span>) =&gt; val &amp;&amp; <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&#x27;object&#x27;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">deepFreeze</span>(<span class="hljs-params">obj</span>) &#123;<br>    <span class="hljs-comment">// 遍历所有属性并递归调⽤Object.freeze()</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-title function_">isObject</span>(obj) &amp;&amp; !<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">isFrozen</span>(obj)) &#123; <span class="hljs-comment">// 跳过已经冻结过的对象，冻结没有被冻 结过的对象</span><br>      <span class="hljs-comment">// 跳过所有的函数，即使从技术上说，函数也可以被修改, 但是我们更希望注意在数据的属性上</span><br>      <span class="hljs-comment">// 递归地⾃调⽤</span><br>      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj).<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">name</span> =&gt;</span> <span class="hljs-title function_">deepFreeze</span>(obj[name]));<br>      <span class="hljs-comment">// 冻结根对象</span><br>      <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">freeze</span>(obj);<br> &#125;<br>  <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述的⼀些技巧可以⽤来增强代码中的不可变性⽔平，但要创建 ⼀个永不改变任何状态的应⽤是不现实的。<br>在由原对象创建新 对象（如coordinate.translate() ）时，使⽤这些严格的策略能 够有效降低JavaScript应⽤的复杂性。</p><h3 id="使⽤Lenses【透镜】（函数式引⽤）定位并修改对象图"><a href="#使⽤Lenses【透镜】（函数式引⽤）定位并修改对象图" class="headerlink" title="使⽤Lenses【透镜】（函数式引⽤）定位并修改对象图"></a>使⽤Lenses【透镜】（函数式引⽤）定位并修改对象图</h3><blockquote><p>是函数式程序设计中⽤于访问和不可改变地操纵状态数据类型属性的解决⽅案</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ⾃⾏实现写时复制策略，在每次⽅法调⽤时返回⼀个新的对象。 烦琐且容易出错</span><br><span class="hljs-keyword">set</span> <span class="hljs-title function_">lastname</span>(<span class="hljs-params">lastname</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">_firstname</span>, lastname, <span class="hljs-variable language_">this</span>.<span class="hljs-property">_ssn</span>); <span class="hljs-comment">// 需要将对象中所有的属性状态复制到新的实例（太糟糕了）</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><a href="https://ramdajs.com/docs/">ramdajs库文档地址</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> R = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;ramda&#x27;</span>);<br><br><span class="hljs-comment">// 使⽤ R.lensProp 来创建⼀个包装了Person 的 lastname属性的 Lens</span><br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;Alonzo&#x27;</span>, <span class="hljs-string">&#x27;Church&#x27;</span>, <span class="hljs-string">&#x27;444-44-4444&#x27;</span>);<br><span class="hljs-keyword">var</span> lastnameLens = R.<span class="hljs-title function_">lenseProp</span>(<span class="hljs-string">&#x27;lastName&#x27;</span>);<br><br><span class="hljs-comment">// 使⽤R.view 来读取该属性的内容</span><br>R.<span class="hljs-title function_">view</span>(lastnameLens, person); <span class="hljs-comment">//-&gt; &#x27;Church&#x27;</span><br><br><span class="hljs-comment">// 调⽤R.set 时，它创建并返回⼀个全新的对象 副本，其中包含⼀个新的属性值，并保留原始实例状态</span><br><span class="hljs-keyword">var</span> newPerson = R.<span class="hljs-title function_">set</span>(lastnameLens, <span class="hljs-string">&#x27;Mourning&#x27;</span>, person);<br>newPerson.<span class="hljs-property">lastname</span>; <span class="hljs-comment">//-&gt; &#x27;Mourning&#x27;</span><br>person.<span class="hljs-property">lastname</span>; <span class="hljs-comment">//-&gt; &#x27;Church&#x27;</span><br><br><span class="hljs-comment">// 支持嵌套</span><br>person.<span class="hljs-property">address</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Address</span>(<span class="hljs-string">&#x27;US&#x27;</span>, <span class="hljs-string">&#x27;NJ&#x27;</span>, <span class="hljs-string">&#x27;Princeton&#x27;</span>, <span class="hljs-title function_">zipCode</span>(<span class="hljs-string">&#x27;08544&#x27;</span>,<span class="hljs-string">&#x27;1234&#x27;</span>), <span class="hljs-string">&#x27;Alexander St.&#x27;</span>);<br><span class="hljs-keyword">var</span> zipPath = [<span class="hljs-string">&#x27;address&#x27;</span>, <span class="hljs-string">&#x27;zip&#x27;</span>];<br><span class="hljs-keyword">var</span> zipLens = R.<span class="hljs-title function_">lens</span>(R.<span class="hljs-title function_">path</span>(zipPath), R.<span class="hljs-title function_">assocPath</span>(zipPath));<br>R.<span class="hljs-title function_">view</span>(zipLens, person); <span class="hljs-comment">//-&gt; zipCode(&#x27;08544&#x27;, &#x27;1234&#x27;)</span><br><br><br><span class="hljs-keyword">var</span> newPerson = R.<span class="hljs-title function_">set</span>(zipLens, person, <span class="hljs-title function_">zipCode</span>(<span class="hljs-string">&#x27;90210&#x27;</span>, <span class="hljs-string">&#x27;5678&#x27;</span>));<br>R.<span class="hljs-title function_">view</span>(zipLens, newPerson); <span class="hljs-comment">//-&gt; zipCode(&#x27;90210&#x27;, &#x27;5678&#x27;)</span><br>R.<span class="hljs-title function_">view</span>(zipLens, person); <span class="hljs-comment">//-&gt; zipCode(&#x27;08544&#x27;, &#x27;1234&#x27;)</span><br>newPerson !== person; <span class="hljs-comment">//-&gt; true</span><br></code></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数是函数式编程的⼯作单元与中⼼。<br>为了达到学习⽬的，我们需要区分表达式（如返回⼀个值的函数）和语句（如不返回值的函数）。<br>命令式编程和过程式程序⼤多是由⼀系列有序的语 句组成的，⽽函数式编程完全依赖于表达式，因此⽆值函数在该范式下并没有意义。</p><p>JavaScript 函数有两个⽀柱性的重要特性：⼀等的和⾼阶的。</p><h3 id="⼀等函数"><a href="#⼀等函数" class="headerlink" title="⼀等函数"></a>⼀等函数</h3><p>在JavaScript中，术语是⼀等的，指的在语⾔层⾯将函数视为真实的对象。</p><blockquote><p>一等公民的定义<br>根据维基百科，编程语言中一等公民的概念是由英国计算机学家Christopher Strachey提出来的，时间则早在上个世纪 60 年代，那个时候还没有个人电脑，没有互联网，没有浏览器，也没有 JavaScript。</p></blockquote><blockquote><p>来自于一本书《Programming Language Pragmatics》，这本书是很多大学的程序语言设计的教材。<br>In general, a value in a programming language is said to have ﬁrst-class status if it can be passed as a parameter, returned from a subroutine, or assigned into a variable.<br>也就是说，在编程语言中，一等公民可以作为函数参数，可以作为函数返回值，也可以赋值给变量。</p></blockquote><blockquote><p>一篇讲JavaScript历史的文章里面提到：JavaScript借鉴Scheme语言，将函数提升到”一等公民”（first class citizen）的地位。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 函数声明</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">multiplier</span>(<span class="hljs-params">a,b</span>) &#123;<br>  <span class="hljs-keyword">return</span> a * b;<br>&#125;<br><br><span class="hljs-comment">// 作为匿名函数或lambda表达式给变量赋值</span><br><span class="hljs-keyword">var</span> square = <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123; <span class="hljs-comment">// 匿名函数</span><br>  <span class="hljs-keyword">return</span> x * x;<br>&#125;<br><br><span class="hljs-keyword">var</span> <span class="hljs-title function_">square</span> = x =&gt; x * x; <span class="hljs-comment">// lambda表达式</span><br><br><span class="hljs-comment">// 作为成员⽅法给对象的属性赋值</span><br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">method</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123; <span class="hljs-keyword">return</span> x * x; &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>函数还可以通过构造函数来实例化，构造函数以函数形参，函数体为参 数，并需要使⽤new 关键字，如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> multiplier = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Function</span>(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;return a * b&#x27;</span>);<br><span class="hljs-title function_">multiplier</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">//-&gt; 6</span><br></code></pre></td></tr></table></figure><p>在 JavaScript 中，任何函数都是 Function 类型的⼀个实例<br>函数的 length 属性可以⽤来获取形参的数量<br>apply()和call()⽅法可以⽤来调⽤函数并加⼊上下⽂</p><h3 id="⾼阶函数"><a href="#⾼阶函数" class="headerlink" title="⾼阶函数"></a>⾼阶函数</h3><p>匿名函数表达式的右侧是⼀个具有空 name 属性的函数对象。可 以通过将匿名函数作为参数的⽅式来扩展或者定制化当前函数的⾏ 为。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">people.<span class="hljs-title function_">sort</span>(<span class="hljs-function">(<span class="hljs-params">p1, p2</span>) =&gt;</span> p1.<span class="hljs-title function_">getAge</span>() - p2.<span class="hljs-title function_">getAge</span>());<br></code></pre></td></tr></table></figure><p>像sort() 这样可以接收其他函数作为参数的JavaScript函数，均属于⼀种函数类型——⾼阶函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">applyOperation</span>(<span class="hljs-params">a, b, opt</span>) &#123; <span class="hljs-comment">// opt()函数可以作为参数传⼊其他函数中</span><br> <span class="hljs-keyword">return</span> <span class="hljs-title function_">opt</span>(a,b);<br>&#125;<br><span class="hljs-keyword">var</span> <span class="hljs-title function_">multiplier</span> = (<span class="hljs-params">a, b</span>) =&gt; a * b;<br><span class="hljs-title function_">applyOperation</span>(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, multiplier); <span class="hljs-comment">// -&gt; 6</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a</span>) &#123;<br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">b</span>) &#123; <span class="hljs-comment">// ⼀个返回其他函数的函数</span><br>    <span class="hljs-keyword">return</span> a + b;<br> &#125;<br>&#125;<br><span class="hljs-title function_">add</span>(<span class="hljs-number">3</span>)(<span class="hljs-number">3</span>); <span class="hljs-comment">//-&gt; 6</span><br></code></pre></td></tr></table></figure><p>因为函数的⼀等性和⾼阶性，JavaScript函数具有值的⾏为。 <code>函数就是⼀个基于输⼊的且尚未求值的不可变的值。</code></p><p>通过组合⼀些⼩的⾼阶函数来创建有意义的表达式，可以简化很多烦琐的程序。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 要打印住在美国的⼈员名单</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printPeopleInTheUs</span>(<span class="hljs-params">people</span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; people.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">var</span> thisPerson = people[i];<br>    <span class="hljs-keyword">if</span>(thisPerson.<span class="hljs-property">address</span>.<span class="hljs-property">country</span> === <span class="hljs-string">&#x27;US&#x27;</span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(thisPerson); <span class="hljs-comment">// &lt;---隐式调⽤对象的toString⽅法</span><br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-title function_">printPeopleInTheUs</span>([p1, p2, p3]); <span class="hljs-comment">// &lt;--- p1、p2和p3 是Person的实例</span><br><br><span class="hljs-comment">// ⽀持打印⽣活在其他国家的⼈</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printPeople</span>(<span class="hljs-params">people, action</span>) &#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; people.<span class="hljs-property">length</span>; i++) &#123;<br>    action (people[i]);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> action = <span class="hljs-keyword">function</span> (<span class="hljs-params">person</span>) &#123;<br>  <span class="hljs-keyword">if</span>(person.<span class="hljs-property">address</span>.<span class="hljs-property">country</span> === <span class="hljs-string">&#x27;US&#x27;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person);<br>  &#125;<br>&#125;<br><span class="hljs-title function_">printPeople</span>(people,action); <br><br><span class="hljs-comment">// 基于函数的⾼阶特性将printPeople重构 数据 + 条件 + 动作分离</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printPeople</span>(<span class="hljs-params">people, selector, printer</span>) &#123;<br> people.<span class="hljs-title function_">forEach</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">person</span>) &#123;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-title function_">selector</span>(person)) &#123;<br>    <span class="hljs-title function_">printer</span>(person);<br>  &#125;<br> &#125;);<br>&#125;<br><span class="hljs-keyword">var</span> <span class="hljs-title function_">inUs</span> = person =&gt; person.<span class="hljs-property">address</span>.<span class="hljs-property">country</span> === <span class="hljs-string">&#x27;US&#x27;</span>;<br><span class="hljs-title function_">printPeople</span>(people, inUs, <span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>);<br><br><span class="hljs-comment">// 以使⽤ Lens 来创建可以访问对象属性的函数 -- 代码⽐之前的更加函数式</span><br><span class="hljs-keyword">var</span> countryPath = [<span class="hljs-string">&#x27;address&#x27;</span>, <span class="hljs-string">&#x27;country&#x27;</span>];<br><span class="hljs-keyword">var</span> countryL = R.<span class="hljs-title function_">lens</span>(R.<span class="hljs-title function_">path</span>(countryPath), R.<span class="hljs-title function_">assocPath</span>(countryPath));<br><span class="hljs-keyword">var</span> inCountry = R.<span class="hljs-title function_">curry</span>(<span class="hljs-function">(<span class="hljs-params">country, person</span>) =&gt;</span> R.<span class="hljs-title function_">equals</span>(R.<span class="hljs-title function_">view</span>(countryL, person), country));<br>people.<span class="hljs-title function_">filter</span>(<span class="hljs-title function_">inCountry</span>(<span class="hljs-string">&#x27;US&#x27;</span>)).<span class="hljs-title function_">map</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>); <br></code></pre></td></tr></table></figure><h3 id="函数调⽤的类型"><a href="#函数调⽤的类型" class="headerlink" title="函数调⽤的类型"></a>函数调⽤的类型</h3><p>JavaScript 给予了我们完全的⾃由来指定调⽤函数的运⾏上下⽂，也就是函数体中 this 的值。<br>不同的⽅式来调⽤： </p><ul><li>作为全局函数 – 其中this 的引⽤可以是global 对象或是undefined （在严格模式中）<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doWork</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-variable language_">this</span>.<span class="hljs-property">myVar</span> = <span class="hljs-string">&#x27;Some value&#x27;</span>; <span class="hljs-comment">// 在全局上下⽂调⽤doWork()会造成this引⽤到全局对象上</span><br>&#125;<br><span class="hljs-title function_">doWork</span>(); <span class="hljs-comment">// 在全局上下⽂调⽤doWork()会造成this引⽤到全局对象上</span><br></code></pre></td></tr></table></figure></li><li>作为⽅法 – 其中 this 的引⽤是⽅法的所有者 OOP<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">prop</span>: <span class="hljs-string">&#x27;Some property&#x27;</span>, <br>  <span class="hljs-attr">getProp</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">prop</span>&#125; <span class="hljs-comment">// 调⽤对象中的⽅法时，this指向该对象</span><br>&#125;;<br>obj.<span class="hljs-title function_">getProp</span>(); <span class="hljs-comment">// 调⽤对象中的⽅法时，this指向该对象</span><br></code></pre></td></tr></table></figure></li><li>作为构造函数与 new⼀起使⽤ – 这种⽅式会返回新创建对象的引⽤<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyType</span>(<span class="hljs-params">arg</span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">prop</span> = arg; <span class="hljs-comment">// 使⽤new关键字会把this引⽤到新创建的对象上 </span><br>&#125;<br><span class="hljs-keyword">var</span> someVal = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyType</span>(<span class="hljs-string">&#x27;some argument&#x27;</span>); <span class="hljs-comment">// 使⽤new关键字会把this引⽤到新创建的对象上</span><br></code></pre></td></tr></table></figure></li></ul><p>在函数式代码中很少会使⽤this（事实上，应不 惜⼀切代价来避免使⽤它）。但在⼀些库和⼯具中，它被⼤量使⽤， 以在⼀些特殊情形下改变语⾔环境来实现⼀些难以置信的功能。这些 往往会涉及 apply ⽅法以及 call ⽅法。</p><h3 id="函数⽅法"><a href="#函数⽅法" class="headerlink" title="函数⽅法"></a>函数⽅法</h3><p>JavaScript ⽀持通过使⽤函数原型链上的函数⽅法（类似元函数）call 和 apply 来调⽤函数本⾝。</p><h2 id="作用域与闭包"><a href="#作用域与闭包" class="headerlink" title="作用域与闭包"></a>作用域与闭包</h2><h3 id="作用域分类"><a href="#作用域分类" class="headerlink" title="作用域分类"></a>作用域分类</h3><ul><li><p>全局作⽤域<br>任何对象和在脚本最外层声明的（不在任何函数中的）变量都是全局作⽤域的⼀部分，并且可以被所有JavaScript代码访问。<br>在函数式编程时，我们应该不惜⼀切代价地避免使⽤全局变量。</p></li><li><p>函数作⽤域</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> x = <span class="hljs-string">&#x27;Some value&#x27;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">parentFunction</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">innerFunction</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);<br>  &#125;<br>  <span class="hljs-keyword">return</span> innerFunction;<br>&#125;<br><span class="hljs-keyword">var</span> inner = <span class="hljs-title function_">parentFunction</span>();<br><span class="hljs-title function_">inner</span>();<br></code></pre></td></tr></table></figure></li></ul><p><img src="/../img/function2-fn2.png" alt="JavaScript 的名称解析顺序，在最近的作⽤域查找到变量，并逐层向外扩展。 它⾸先检查函数（局部）作⽤域，然后移动到（倘若存在的）⽗作⽤域，最终移动⾄ 全局作⽤域。如果⽆法找到变量x ，该函数将返回 undefined"></p><ul><li><p>伪块作⽤域<br>标准 ES5 JavaScript 并不⽀持块级作⽤域。</p><ul><li>比如包裹在括号{} 中的，⾪属于各种控制结构，如 for 、while 、if 和switch 语句。</li><li>传递到 catch 块的错误变量 - 块级作用域</li><li>语句 with 与块作⽤域类似，但它已不被建议使⽤，并且在严格模式下被 禁⽌。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doWork</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (!myVar) &#123;<br>    <span class="hljs-keyword">var</span> myVar = <span class="hljs-number">10</span>;<br>  &#125;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(myVar); <span class="hljs-comment">//-&gt; 10</span><br>&#125;<br><span class="hljs-title function_">doWork</span>();<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">processArr</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">multipleBy10</span>(<span class="hljs-params">val</span>) &#123;<br>    i = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">return</span> val * i;<br>  &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-property">length</span>; i++) &#123;<br>    arr[i] = <span class="hljs-title function_">multipleBy10</span>(arr[i]);<br>  &#125;<br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br><span class="hljs-title function_">processArr</span>(); <span class="hljs-comment">//-&gt; [10, 2, 3, 4]</span><br></code></pre></td></tr></table></figure></li></ul><p>推荐ES6使⽤let ⽽不是var 来声明作⽤域变量</p></li></ul><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> outerVar = <span class="hljs-string">&#x27;Outer&#x27;</span>; <span class="language-xml">&lt;---声明全局变量outerVar</span><br><span class="language-xml">function makeInner(params) &#123;</span><br><span class="language-xml">  var innerVar = &#x27;Inner&#x27;; // 调⽤makeInner会得到inner函数</span><br><span class="language-xml">  function inner() &#123;</span><br><span class="language-xml">    // 声明inner：innerVar和outerVar在inner闭包内</span><br><span class="language-xml">    console.log(`I can see: $&#123;outerVar&#125;, $&#123;innerVar&#125;, and $&#123;params&#125;`);</span><br><span class="language-xml">  &#125;</span><br><span class="language-xml"> return inner;</span><br><span class="language-xml">&#125;</span><br><span class="language-xml">var inner = makeInner(&#x27;Params&#x27;); // 声明局部变量makeInner</span><br><span class="language-xml">inner(); // 函数inner⽣命周期⽐外部函数还⻓</span><br><span class="language-xml"></span><br><span class="language-xml">// --&gt; &#x27;I can see: Outer, Inner, and Params&#x27;</span><br></code></pre></td></tr></table></figure><p><img src="/../img/function2-fn1.png" alt="作用域示意"></p><h6 id="闭包包含了在外部（全局）作⽤域中声明的变量、在⽗函数内部作⽤域中声明的变量、⽗函数的参数以及在函数声明之后声明的变量。函数体中的代码可以访问这些作⽤域中-定义的变量和对象。⽽所有函数都共享全局作⽤域"><a href="#闭包包含了在外部（全局）作⽤域中声明的变量、在⽗函数内部作⽤域中声明的变量、⽗函数的参数以及在函数声明之后声明的变量。函数体中的代码可以访问这些作⽤域中-定义的变量和对象。⽽所有函数都共享全局作⽤域" class="headerlink" title="闭包包含了在外部（全局）作⽤域中声明的变量、在⽗函数内部作⽤域中声明的变量、⽗函数的参数以及在函数声明之后声明的变量。函数体中的代码可以访问这些作⽤域中 定义的变量和对象。⽽所有函数都共享全局作⽤域"></a>闭包包含了在外部（全局）作⽤域中声明的变量、在⽗函数内部作⽤域中声明的变量、⽗函数的参数以及在函数声明之后声明的变量。函数体中的代码可以访问这些作⽤域中 定义的变量和对象。⽽所有函数都共享全局作⽤域</h6><p>从makeInner 返回的函数会在其声明时记住其作⽤域内的所有变量， 并防⽌它们被回收。由于全局作⽤域内也是闭包的⼀部分，因此返回 的函数也能够访问 outerVar 。</p><p>闭包是⼀种能够在函数声明过程中将环境信息与所属函数绑定在⼀起的数据结构。它是基于函数声明的⽂本位置的，因此也被称为围 绕函数定义的静态作⽤域或词法作⽤域。<br>⽀配函数闭包⾏为的规则与 JavaScript 的作⽤域规则密切相关。<br>从本质上讲，闭包就是函数继承⽽来的作⽤域，这类似于对象⽅法是如何访问 其继承的实例变量的，它们都具有其⽗类型的引⽤。</p><h4 id="闭包的实际应⽤"><a href="#闭包的实际应⽤" class="headerlink" title="闭包的实际应⽤"></a>闭包的实际应⽤</h4><ul><li>模拟私有变量<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title class_">MyModule</span> = (<span class="hljs-keyword">function</span> <span class="hljs-title function_">MyModule</span>(<span class="hljs-params"><span class="hljs-keyword">export</span></span>) &#123; <span class="hljs-comment">// &lt;---给IIFE⼀个名字，这样 有⽤的信息更⽅便栈追踪</span><br>  <span class="hljs-keyword">let</span> _myPrivateVar = ...;  <span class="hljs-comment">// &lt;---⽆法从外部访问到这个私有变量，但对内部 的两个⽅法可⻅</span><br>      <span class="hljs-keyword">export</span>.<span class="hljs-property">method1</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;  <span class="hljs-comment">//&lt;---需要暴露的⽅法，这⾥给予了伪命名空 间// do work</span><br>  &#125;;<br>  <span class="hljs-keyword">export</span>.<span class="hljs-property">method2</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <span class="hljs-comment">//&lt;---需要暴露的⽅法，这⾥给予了伪命名 空间</span><br>  <span class="hljs-comment">// do work</span><br>  &#125;;<br>&#125;(<span class="hljs-title class_">MyModule</span> || &#123;&#125;)); <span class="hljs-comment">// &lt;---⼀个单例对象，⽤来私有的封装所有的状态和⽅法。可以 通过MyModule.method1()调⽤到method1()</span><br></code></pre></td></tr></table></figure>闭包还可以⽤来管理的全局命名空间，以免在全局范围内共享数 据。⼀些库和模块还会使⽤闭包来隐藏整个模块的私有⽅法和数据。 这被称为模块模式 ，它采⽤了⽴即调⽤函数表达式（IIFE） ，在封 装内部变量的同时，允许对外公开必要的功能集合，从⽽有效减少了全局引⽤。</li><li>异步服务端调⽤<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">getJSON</span>(<span class="hljs-string">&#x27;/students&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">students</span>) =&gt;</span> &#123;<br>  <span class="hljs-title function_">getJSON</span>(<span class="hljs-string">&#x27;/students/grades&#x27;</span>, <br>    <span class="hljs-function"><span class="hljs-params">grades</span> =&gt;</span> <span class="hljs-title function_">processGrades</span>(grades), <span class="hljs-comment">// 处理两个返回结果</span><br>    <span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error.<span class="hljs-property">message</span>)); <span class="hljs-comment">// 处理获取评分等级 时发⽣的错误</span><br>&#125;,<br><span class="hljs-comment">// 处理获取学⽣时发⽣的错误</span><br><span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error.<span class="hljs-property">message</span>) )<br></code></pre></td></tr></table></figure></li><li>模拟块作⽤域变量<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">outputNumbers</span>(<span class="hljs-params">count</span>)&#123;<br>  (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-comment">//块级作用域</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; count; i++)&#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i); <span class="hljs-comment">// 0, 1, ... count - 1</span><br>    &#125;<br>  &#125;)();<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i); <span class="hljs-comment">// error</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>JavaScript 是⼀种⽤途⼴泛的、具有强⼤⾯向对象和函数式编程特性的语⾔。 </li><li>使⽤不可变的实现⽅式可以使函数式与⾯向对象编程很好地结合在⼀起。</li><li>⼀等⾼阶的函数使得 JavaScript 成了函数式编程的中坚⼒量。</li><li>闭包具有很多实际⽤途，如信息隐藏、模块化开发，并能够将参数化的⾏为跨数据类型地应⽤于粗粒度的函数之上。</li></ul><h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><p><img src="/../img/mind/function2.png" alt="总结脑图"></p>]]></content>
    
    
    <categories>
      
      <category>函数式编程指南</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书分享</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《JavaScript函数式编程指南》第一章 走进函数式</title>
    <link href="/2023/11/11/functionalProgramming/book1/"/>
    <url>/2023/11/11/functionalProgramming/book1/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章-走进函数式"><a href="#第一章-走进函数式" class="headerlink" title="第一章 走进函数式"></a>第一章 走进函数式</h1><h2 id="分享之前"><a href="#分享之前" class="headerlink" title="分享之前"></a>分享之前</h2><h3 id="为什么选择这本书"><a href="#为什么选择这本书" class="headerlink" title="为什么选择这本书"></a>为什么选择这本书</h3><p>在当前 JavaScript 的发展趋势中，函数式编程逐渐成为主流。值得注意的是，目前流行的前端框架几乎都是基于函数式编程的理念。React 框架是典型的函数式编程范例，其核心思想是一切皆为纯函数。在 React 框架中，所有组件和操作都被视为纯函数，使得整个框架更符合 JavaScript 的本质，将 JavaScript 分割成一个个独立的纯函数模块。</p><p>Vue 框架在其 3.x 版本中也逐渐向 React 靠拢，引入了类似 React 中的 Hooks 思想。同时，Vue 框架中的双向绑定机制本质上也是一个纯函数，它是函数式编程中重要的一环。在我们的学习过程中，将逐渐发现 Vue 中双向绑定的设计也是受到函数式编程影响的。</p><p>选择这本书的原因在于，它概括了当前前端框架的核心思想，通过学习函数式编程的理念，我们能更好地理解大前端框架的设计哲学。本书不仅注重理论，还将实际示例贯穿其中，帮助我们更好地应用所学知识。通过深入学习本书，我们能够更高效地使用和理解现代前端框架，提升自己的前端开发技能。</p><h3 id="希望大家从中学到什么"><a href="#希望大家从中学到什么" class="headerlink" title="希望大家从中学到什么"></a>希望大家从中学到什么</h3><p>随着前端框架的不断更新，我们应该关注它们之间的相似之处，因为这些相似之处很可能代表未来相当长一段时间内的发展趋势。我们迫切需要掌握框架的思维方式，而不仅仅是学会使用它们。<br><img src="/../img/learn-too-much.png" alt="学不动了"></p><p>个人认为，函数式编程思想将成为未来一段时间内前端框架发展的关键趋势。因此，我们不仅仅要追求框架的使用技巧，更要通过学习本书深入理解函数式编程的思维方式。希望通过共同学习，我们能够在编程思维上从命令式、面向对象的范式逐渐过渡到更为灵活和强大的函数式编程。</p><p><img src="/../img/forget.png" alt="忘记"></p><h2 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a>前沿</h2><h4 id="web-应用的重要性"><a href="#web-应用的重要性" class="headerlink" title="web 应用的重要性"></a>web 应用的重要性</h4><p>人们对 web 应用的期待和要求促使着我们前端开发人员不断的去思考各种解决方案，并适时地采用那些可能提供最优解决方案的编程范式和最佳实践。特别是对于我们 B 端应用，往往面对着复杂的表单设计，复杂的数据交互场景，如果没有一个好的编程方式，代码很快就会变得不可维护。</p><h4 id="面向对象和函数式编程的区别"><a href="#面向对象和函数式编程的区别" class="headerlink" title="面向对象和函数式编程的区别"></a>面向对象和函数式编程的区别</h4><p>面向对象编程和函数式编程在 JavaScript 中有一些显著的区别。首先，JavaScript 最初被设计为一种用于浏览器脚本的语言，目的是实现简单的交互。由于想要迅速推广，JavaScript 的设计从 Java 中获得了一些灵感，但由于其弱类型的本质，也带来了一些固有的缺陷。</p><p>在 ES5 版本中，JavaScript 并不支持类，因此在努力实现面向对象编程时，我们不得不通过使用函数来模拟类。这种方式虽然勉强能够实现面向对象的概念，但在继承和封装方面存在一些潜在的问题。</p><p>随着 JavaScript 的重要性逐渐上升，ES6 引入了类的概念，使我们可以直接使用 class 关键字来实现面向对象编程。这为开发者提供了更直观、清晰的面向对象的编码方式。</p><p>然而，尽管我们已经掌握了面向对象编程的技巧，为什么现在又需要转向函数式编程呢？这是因为 JavaScript 的灵活性导致代码在一段时间后可能变得庞大且难以维护。尽管面向对象编程能够缓解一些问题，但这并不足够。函数式编程的出现为我们提供了一种更为灵活和可维护的编码方式。在接下来的章节中，我们将深入探讨函数式编程是如何使代码更易于维护的。</p><h4 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h4><p>要想做一个完善的技术方案设计，让我们的代码变得更加优雅和便于维护，在做应用设计时，应该遵从以下设计原则</p><ul><li>可扩展性</li><li>易模块性</li><li>可重用性</li><li>可测性</li><li>易推理性</li></ul><h2 id="函数式编程有用吗"><a href="#函数式编程有用吗" class="headerlink" title="函数式编程有用吗"></a>函数式编程有用吗</h2><p>因为 javascript 动态语言的灵活性，导致了我们的状态管理原生结构的缺乏，当然我们现在的前端框架通过了封装第三方的库改进了这些弊端。但函数式编程可以让我们编写干净的、模块化的、可测性的并且简洁的代码，开发过程更加高效。</p><blockquote><p>因为函数式编程是一种编写代码的方式，而不是一种框架或工具，函数式的思维方式与面向对象的思维方式完全不同。但如何迈向函数式呢？如何开始使用函数式去思考呢？一旦你掌握了它的本质，函数式编程将是直观的。摒弃旧习是最难的部分，对于一个有面向对象背景的人来说，将是一个巨大的编程范式转变。在学习如何使用函数式思考之前，首先你必须知道函数式编程到底是什么。</p></blockquote><h2 id="什么是函数式编程"><a href="#什么是函数式编程" class="headerlink" title="什么是函数式编程"></a>什么是函数式编程</h2><h3 id="函数式和非函数式比较"><a href="#函数式和非函数式比较" class="headerlink" title="函数式和非函数式比较"></a>函数式和非函数式比较</h3><h4 id="非函数式编程"><a href="#非函数式编程" class="headerlink" title="非函数式编程"></a>非函数式编程</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">printMessage</span>(<span class="hljs-params">elementId, format, message</span>) &#123;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<br>    <span class="hljs-string">`#<span class="hljs-subst">$&#123;elementId&#125;</span>`</span><br>  ).<span class="hljs-property">innerHTML</span> = <span class="hljs-string">`&lt;<span class="hljs-subst">$&#123;format&#125;</span>&gt;<span class="hljs-subst">$&#123;message&#125;</span>&lt;/<span class="hljs-subst">$&#123;format&#125;</span>&gt;`</span><br>&#125;<br><span class="hljs-title function_">printMessage</span>(<span class="hljs-string">&#x27;msg&#x27;</span>, <span class="hljs-string">&#x27;h1&#x27;</span>, <span class="hljs-string">&#x27;Hello World&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> printMessage = <span class="hljs-title function_">run</span>(<span class="hljs-title function_">addToDom</span>(<span class="hljs-string">&#x27;msg&#x27;</span>), h1, echo)<br><span class="hljs-title function_">printMessage</span>(<span class="hljs-string">&#x27;Hello World&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> printMessage = <span class="hljs-title function_">run</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>, <span class="hljs-title function_">repeat</span>(<span class="hljs-number">3</span>), h2, echo)<br><span class="hljs-title function_">printMessage</span>(<span class="hljs-string">&#x27;Get Functional&#x27;</span>)<br></code></pre></td></tr></table></figure><p>我们能看到函数式编程其实是将代码分解为一些更可重用、更可靠且更易于理解的部分，再将它们组合起来，形成一个更易推理的程序整体。所有的函数式程序都遵循这一基本原则。</p><h3 id="声明式"><a href="#声明式" class="headerlink" title="声明式"></a>声明式</h3><h4 id="命令式编程"><a href="#命令式编程" class="headerlink" title="命令式编程"></a>命令式编程</h4><p>命令式编程将计算机程序视为一系列自上而下的断言，通过修改系统的各个状态来计算最终的结果。我们在日常开发过程中从上到下的实现页面功能过程就是一个具体的实例，在 vue2 或者 angularJs 中我们如果不加注意，代码就很容易形成一个从上到下的命令式编程或者过程式的编程形式。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> array = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; array.<span class="hljs-property">length</span>; i++) &#123;<br>  array[i] = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(array[i], <span class="hljs-number">2</span>)<br>&#125;<br>array <span class="hljs-comment">//-&gt; [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]”</span><br></code></pre></td></tr></table></figure><h4 id="声明式编程"><a href="#声明式编程" class="headerlink" title="声明式编程"></a>声明式编程</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>].<span class="hljs-title function_">map</span>(<br><span class="hljs-keyword">function</span>(<span class="hljs-params">num</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(num, <span class="hljs-number">2</span>);  <span class="language-xml">&lt;--- map接收一个计算平方的函数</span><br><span class="language-xml">&#125;);</span><br><span class="language-xml">//-&gt;</span> [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>, <span class="hljs-number">36</span>, <span class="hljs-number">49</span>, <span class="hljs-number">64</span>, <span class="hljs-number">81</span>]<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">;[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>].<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">pow</span>(num, <span class="hljs-number">2</span>))<br><span class="hljs-comment">//-&gt; [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</span><br></code></pre></td></tr></table></figure><p>我们可以从上面的例子中很容易的看出，使用 for 循环的过程是一个很明显的命令式编程的例子，我们不仅要关注循环里我们真正要做的事情，还要维护好代码循环的逻辑。而在 map 函数中我们只需要关注我们真正要处理的核心逻辑，将循环的逻辑交给函数自己来处理。类似这样的函数我们还有 filter，reduce 等。</p><blockquote><p>“循环是一种重要的命令控制结构，但很难重用，并且很难插入其他操作中。”</p></blockquote><blockquote><p>lambda 表达式提供了一种比常规函数更具语法优势的特性，因为它简化了常规函数的结构，使人关注于函数的那些真正重要的部分</p></blockquote><h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><p>纯函数是指没有副作用和状态变化的函数。它具有以下几个特点：</p><ul><li>不可变性</li><li>仅取决于提供的输入</li><li>不会造成超出其作用域的变化</li></ul><p>我们从书中的例子来理解下纯函数的定义，下面这个例子就能很明显的看出函数内部的逻辑对全局的影响，例如依赖外部的元素，对全局 html 内容的写入等。这个就依赖了很多外部资源，代码很不灵活，很难测试和维护。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">showStudent</span>(<span class="hljs-params">ssn</span>) &#123;<br>    <span class="hljs-keyword">var</span> student = db.<span class="hljs-title function_">get</span>(ssn);  &lt;---在对象存储中通过SSN查找学生。请假设这个操作现在是同步的，之后我会处理异步的情况<br>    if(student !== null) &#123;<br>       document.querySelector(`#$&#123;elementId&#125;`).innerHTML =  &lt;---读取函数外的elementId变量<br>          `$&#123;student.ssn&#125;,<br>           $&#123;student.firstname&#125;,<br>           $&#123;student.lastname&#125;`;<br>    &#125;<br>    else &#123;<br>        throw new Error(&#x27;Student not found!&#x27;);  &lt;---当学生信息错误时抛出异常<br>    &#125;<br>&#125;<br>showStudent(&#x27;444-44-4444&#x27;);  &lt;---使用SSN号444-44-4444作为参数执行函数，结果会显示在页面上<br></code></pre></td></tr></table></figure><p>我们可以将函数拆解成一个个具有单一职责的短函数，减少副作用的数量，使得代码变得更加灵活和容易维护。有了可以重用的组件，增加了代码的可读性。</p><p>分解后的代码我们会涉及到柯里化的概念，柯里化可以允许部分地传递函数参数，以便将函数的参数减少为一个。在此不做过多展开，后续章节会涉及。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> find = <span class="hljs-title function_">curry</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">db, id</span>) &#123;<br>    <span class="hljs-keyword">var</span> obj = db.<span class="hljs-title function_">get</span>(id);<br>    <span class="hljs-keyword">if</span>(obj === <span class="hljs-literal">null</span>) &#123;<br>       <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Object not found!&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;);<br><br><span class="hljs-keyword">var</span> csv = (student) &#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;student.ssn&#125;</span>, <span class="hljs-subst">$&#123;student.firstname&#125;</span>, <span class="hljs-subst">$&#123;student.lastname&#125;</span>`</span>;<br>&#125;;<br><br><span class="hljs-keyword">var</span> append = <span class="hljs-title function_">curry</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">elementId, info</span>) &#123;<br>   <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(elementId).<span class="hljs-property">innerHTML</span> = info;<br>&#125;);<br><br><span class="hljs-keyword">var</span> showStudent = <span class="hljs-title function_">run</span>(<br>   <span class="hljs-title function_">append</span>(<span class="hljs-string">&#x27;#student-info&#x27;</span>),  &lt;---部分设置HTML元素的ID<br>   csv,<br>   find(db));  &lt;---部分设置查找对象为学生表<br><br>showStudent(&#x27;444-44-4444&#x27;);<br></code></pre></td></tr></table></figure><p>其实 javascript 中还有一个很容易带来副作用的用法 this，这个会导致我们函数作用域的变化，大家在开发过程中要注意。例如以下的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"> <span class="hljs-keyword">var</span> x = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">var</span> y = <br>   &#123; <br>     <span class="hljs-attr">x</span>: <span class="hljs-number">3</span>, <br>     <span class="hljs-attr">z</span>: (<span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) &#123; <br>       <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> *= x; <br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) &#123;<br>         <span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span> *= n; <br>         x += <span class="hljs-number">3</span>; <br>         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x); <br>       &#125; <br>     &#125;)(x),<br>   &#125;<br>  <span class="hljs-keyword">var</span> m = y.<span class="hljs-property">z</span>;<br>  <span class="hljs-title function_">m</span>(<span class="hljs-number">4</span>);<br>  y.<span class="hljs-title function_">z</span>(<span class="hljs-number">5</span>);<br>   <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x, y.<span class="hljs-property">z</span>);<br></code></pre></td></tr></table></figure><h3 id="引用透明"><a href="#引用透明" class="headerlink" title="引用透明"></a>引用透明</h3><p>一个函数对于相同的输入始终产生的相同的结果，那么这个函数就是引用透明的。下面就是一个最简单最直观的例子，能说明我们函数的引用透明性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> counter = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> ++counter;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> <span class="hljs-title function_">increment</span> = counter =&gt; counter + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>通过这个例子能够很好的解释引用透明的概念，但是我们在开发中还是要注意引用类型的入参，在对引用类型的参数操作时一定要谨慎，不要在不经意间改变他们。</p><blockquote><p>纯度: 一个函数的参数和返回值之间映射的纯的关系</p></blockquote><blockquote><p>状态系统的模型”： Program &#x3D; [Input] + [func1, func2, func3, …] -&gt; Output</p></blockquote><h3 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h3><p>不可变性是指创建后不能更改的数据，我们在开发中运用的很多会改变原有数据的函数，一定要特别注意。<br>例如，sort,splice等</p><p>强迫自己去思考纯的操作，将函数看作永不会修改数据的闭合功能单元，必然可以减少这种潜在bug的可能性。理解这些核心的原则非常重要，它可以让代码发挥出函数式的诸多优势，从而引导你走向克服复杂性的函数式编程之路。</p><blockquote><p>函数式编程是指为创建不可变的程序，通过消除外部可见的副作用，来对纯函数的声明式的求值过程。</p></blockquote><h2 id="函数式编程的优点"><a href="#函数式编程的优点" class="headerlink" title="函数式编程的优点"></a>函数式编程的优点</h2><p>函数式编程能给我们在开发过程中带来诸多好处，我们下面分几步来讲解函数式编程的优点</p><h3 id="鼓励复杂任务的分解"><a href="#鼓励复杂任务的分解" class="headerlink" title="鼓励复杂任务的分解"></a>鼓励复杂任务的分解</h3><p>我们在处理复杂的功能逻辑的时候，更好的是将我们复杂的逻辑不断的分解成单一功能、相互独立的函数，然后再通过组合将各个函数关联起来。这样的函数式编程可以让我们的代码变得更加高效和模块化。</p><h4 id="compose-和-pipe-函数的使用"><a href="#compose-和-pipe-函数的使用" class="headerlink" title="compose 和 pipe 函数的使用"></a>compose 和 pipe 函数的使用</h4><p>组合和管道是我们函数式编程中至关重要的两个概念。函数的组合和管道提高了函数的抽象层次，可以让我们在代码中清晰地勾勒所有步骤，但又不暴露然后底层细节。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">compose</span> = (<span class="hljs-params">...fns</span>)=&gt;<span class="hljs-function"><span class="hljs-params">val</span>=&gt;</span>fns.<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc,fn</span>)=&gt;</span><span class="hljs-title function_">fn</span>(acc),val);<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">pipe</span> = (<span class="hljs-params">...fns</span>)=&gt;<span class="hljs-function"><span class="hljs-params">val</span>=&gt;</span>fns.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">acc,fn</span>)=&gt;</span><span class="hljs-title function_">fn</span>(acc),val);<br></code></pre></td></tr></table></figure><h3 id="使用流式链来处理数据"><a href="#使用流式链来处理数据" class="headerlink" title="使用流式链来处理数据"></a>使用流式链来处理数据</h3><p>我们最开始接触链式操作是通过jquery的链式操作，我们可以方便的通过链式来处理一条完整的逻辑，在jquery中实现链式操作的底层原理是通过返回this来实现的。而对于我们在函数式编程中实现链式操作跟其也有相似性，但是实现的过程要谨记我们上文提到的纯函数等概念。</p><p>以下是命令式编程和链式操作的一个对比</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// bad </span><br><span class="hljs-keyword">var</span> totalGrades = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">var</span> totalStudentsFound = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; enrollment.<span class="hljs-property">length</span>; i++) &#123;<br>    <span class="hljs-keyword">let</span> student = enrollment [i];<br>    <span class="hljs-keyword">if</span>(student !== <span class="hljs-literal">null</span>) &#123;<br>       <span class="hljs-keyword">if</span>(student.<span class="hljs-property">enrolled</span> &gt; <span class="hljs-number">1</span>) &#123;<br>          totalGrades+= student.<span class="hljs-property">grade</span>;<br>          totalStudentsFound++;<br>       &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> average = totalGrades / totalStudentsFound; <span class="hljs-comment">//-&gt; 90”</span><br><br><span class="hljs-comment">// good </span><br>_.<span class="hljs-title function_">chain</span>(enrollment)<br>  .<span class="hljs-title function_">filter</span>(<span class="hljs-function"><span class="hljs-params">student</span> =&gt;</span> student.<span class="hljs-property">enrolled</span> &gt; <span class="hljs-number">1</span>)<br>  .<span class="hljs-title function_">pluck</span>(<span class="hljs-string">&#x27;grade&#x27;</span>)<br>  .<span class="hljs-title function_">average</span>()<br>  .<span class="hljs-title function_">value</span>(); <span class="hljs-comment">//-&gt; 90  &lt;---调用 _.value() 会触发整个链上的所有操作</span><br></code></pre></td></tr></table></figure><p>虽然链式操作能给我们带来足够的方便和可读性，但是如果不考虑整体，一味的使用链式操作也会给我们带来一些副作用，比如链式操作中异常的处理，又比如对于复杂的数据处理，在一系列的链式操作中没有办法打断点去调试中间数据，这就要求我们在使用链式操作的时候要更加的谨慎，需要我们考虑的更加全面。任何的技术都不是银弹，不要手里有了一把锤子，看什么都像钉子。</p><h3 id="复杂异步应用中的响应"><a href="#复杂异步应用中的响应" class="headerlink" title="复杂异步应用中的响应"></a>复杂异步应用中的响应</h3><p>响应式编程应该是我们当下热门前端框架都应用的编程概念。从anjularJs中的脏检查，到react中使用虚拟DOM和协调算法实现高效的响应式更新，再到vue中通过劫持对象来实现对数据的监听和更新，无一不在用响应式编程的来实现底层机制。</p><p>对于三大框架对于Observable的实现原理，也是我们前端开发人员必备的知识技能，至少是面试中不可避免的一道大题。</p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>函数式编程对于我们现在的开发中并不是一个全有或全无的方案，我们现有阶段没有必要完全的面向函数式编程，在我们现有的框架体系内，比如一些采用jquery,angularJs的项目，我们也可以逐步的采用函数式编程，借鉴其中的优点让我们的代码变得更加可读，更好的维护，更加的优雅。</p><p>对于我们新的框架，比如我们的Rhino，应该完全的面向函数式编程，让我们的代码变得更加模块化和通用。当然，任何技术的使用都要考虑其最终实现的场景，我们要谨慎，我们不能矫枉过正。记住我我们的锤子！</p><p><img src="/../img/hammer.jpg" alt="锤子"></p><h2 id="附件"><a href="#附件" class="headerlink" title="附件"></a>附件</h2><p><img src="/../img/mind/function1.png" alt="锤子"></p>]]></content>
    
    
    <categories>
      
      <category>函数式编程指南</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书分享</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
