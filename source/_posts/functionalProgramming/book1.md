---
title: 《JavaScript函数式编程指南》第一章 走进函数式
date: 2023-11-11 21:07:59
post: comments
enable: true
categories: 
- 函数式编程指南
tags: 
- 读书分享
---

# 第一章 走进函数式

## 分享之前

### 为什么选择这本书

在当前 JavaScript 的发展趋势中，函数式编程逐渐成为主流。值得注意的是，目前流行的前端框架几乎都是基于函数式编程的理念。React 框架是典型的函数式编程范例，其核心思想是一切皆为纯函数。在 React 框架中，所有组件和操作都被视为纯函数，使得整个框架更符合 JavaScript 的本质，将 JavaScript 分割成一个个独立的纯函数模块。

Vue 框架在其 3.x 版本中也逐渐向 React 靠拢，引入了类似 React 中的 Hooks 思想。同时，Vue 框架中的双向绑定机制本质上也是一个纯函数，它是函数式编程中重要的一环。在我们的学习过程中，将逐渐发现 Vue 中双向绑定的设计也是受到函数式编程影响的。

选择这本书的原因在于，它概括了当前前端框架的核心思想，通过学习函数式编程的理念，我们能更好地理解大前端框架的设计哲学。本书不仅注重理论，还将实际示例贯穿其中，帮助我们更好地应用所学知识。通过深入学习本书，我们能够更高效地使用和理解现代前端框架，提升自己的前端开发技能。


### 希望大家从中学到什么

随着前端框架的不断更新，我们应该关注它们之间的相似之处，因为这些相似之处很可能代表未来相当长一段时间内的发展趋势。我们迫切需要掌握框架的思维方式，而不仅仅是学会使用它们。
![学不动了](../img/learn-too-much.png)

个人认为，函数式编程思想将成为未来一段时间内前端框架发展的关键趋势。因此，我们不仅仅要追求框架的使用技巧，更要通过学习本书深入理解函数式编程的思维方式。希望通过共同学习，我们能够在编程思维上从命令式、面向对象的范式逐渐过渡到更为灵活和强大的函数式编程。

![忘记](../img/forget.png)

## 前沿

#### web 应用的重要性

人们对 web 应用的期待和要求促使着我们前端开发人员不断的去思考各种解决方案，并适时地采用那些可能提供最优解决方案的编程范式和最佳实践。特别是对于我们 B 端应用，往往面对着复杂的表单设计，复杂的数据交互场景，如果没有一个好的编程方式，代码很快就会变得不可维护。

#### 面向对象和函数式编程的区别

面向对象编程和函数式编程在 JavaScript 中有一些显著的区别。首先，JavaScript 最初被设计为一种用于浏览器脚本的语言，目的是实现简单的交互。由于想要迅速推广，JavaScript 的设计从 Java 中获得了一些灵感，但由于其弱类型的本质，也带来了一些固有的缺陷。

在 ES5 版本中，JavaScript 并不支持类，因此在努力实现面向对象编程时，我们不得不通过使用函数来模拟类。这种方式虽然勉强能够实现面向对象的概念，但在继承和封装方面存在一些潜在的问题。

随着 JavaScript 的重要性逐渐上升，ES6 引入了类的概念，使我们可以直接使用 class 关键字来实现面向对象编程。这为开发者提供了更直观、清晰的面向对象的编码方式。

然而，尽管我们已经掌握了面向对象编程的技巧，为什么现在又需要转向函数式编程呢？这是因为 JavaScript 的灵活性导致代码在一段时间后可能变得庞大且难以维护。尽管面向对象编程能够缓解一些问题，但这并不足够。函数式编程的出现为我们提供了一种更为灵活和可维护的编码方式。在接下来的章节中，我们将深入探讨函数式编程是如何使代码更易于维护的。

#### 设计原则

要想做一个完善的技术方案设计，让我们的代码变得更加优雅和便于维护，在做应用设计时，应该遵从以下设计原则

- 可扩展性
- 易模块性
- 可重用性
- 可测性
- 易推理性

## 函数式编程有用吗

因为 javascript 动态语言的灵活性，导致了我们的状态管理原生结构的缺乏，当然我们现在的前端框架通过了封装第三方的库改进了这些弊端。但函数式编程可以让我们编写干净的、模块化的、可测性的并且简洁的代码，开发过程更加高效。

> 因为函数式编程是一种编写代码的方式，而不是一种框架或工具，函数式的思维方式与面向对象的思维方式完全不同。但如何迈向函数式呢？如何开始使用函数式去思考呢？一旦你掌握了它的本质，函数式编程将是直观的。摒弃旧习是最难的部分，对于一个有面向对象背景的人来说，将是一个巨大的编程范式转变。在学习如何使用函数式思考之前，首先你必须知道函数式编程到底是什么。

## 什么是函数式编程

### 函数式和非函数式比较

#### 非函数式编程

```js
function printMessage(elementId, format, message) {
  document.querySelector(
    `#${elementId}`
  ).innerHTML = `<${format}>${message}</${format}>`
}
printMessage('msg', 'h1', 'Hello World')
```

#### 函数式编程

```js
var printMessage = run(addToDom('msg'), h1, echo)
printMessage('Hello World')
```

```js
var printMessage = run(console.log, repeat(3), h2, echo)
printMessage('Get Functional')
```

我们能看到函数式编程其实是将代码分解为一些更可重用、更可靠且更易于理解的部分，再将它们组合起来，形成一个更易推理的程序整体。所有的函数式程序都遵循这一基本原则。

### 声明式

#### 命令式编程

命令式编程将计算机程序视为一系列自上而下的断言，通过修改系统的各个状态来计算最终的结果。我们在日常开发过程中从上到下的实现页面功能过程就是一个具体的实例，在 vue2 或者 angularJs 中我们如果不加注意，代码就很容易形成一个从上到下的命令式编程或者过程式的编程形式。

```js
var array = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
for (let i = 0; i < array.length; i++) {
  array[i] = Math.pow(array[i], 2)
}
array //-> [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]”
```

#### 声明式编程

```js
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map(
function(num) {
  return Math.pow(num, 2);  <--- map接收一个计算平方的函数
});
//-> [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

```js
;[0, 1, 2, 3, 4, 5, 6, 7, 8, 9].map((num) => Math.pow(num, 2))
//-> [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

我们可以从上面的例子中很容易的看出，使用 for 循环的过程是一个很明显的命令式编程的例子，我们不仅要关注循环里我们真正要做的事情，还要维护好代码循环的逻辑。而在 map 函数中我们只需要关注我们真正要处理的核心逻辑，将循环的逻辑交给函数自己来处理。类似这样的函数我们还有 filter，reduce 等。

> “循环是一种重要的命令控制结构，但很难重用，并且很难插入其他操作中。”

> lambda 表达式提供了一种比常规函数更具语法优势的特性，因为它简化了常规函数的结构，使人关注于函数的那些真正重要的部分

### 纯函数

纯函数是指没有副作用和状态变化的函数。它具有以下几个特点：

- 不可变性
- 仅取决于提供的输入
- 不会造成超出其作用域的变化

我们从书中的例子来理解下纯函数的定义，下面这个例子就能很明显的看出函数内部的逻辑对全局的影响，例如依赖外部的元素，对全局 html 内容的写入等。这个就依赖了很多外部资源，代码很不灵活，很难测试和维护。

```js
function showStudent(ssn) {
    var student = db.get(ssn);  <---在对象存储中通过SSN查找学生。请假设这个操作现在是同步的，之后我会处理异步的情况
    if(student !== null) {
       document.querySelector(`#${elementId}`).innerHTML =  <---读取函数外的elementId变量
          `${student.ssn},
           ${student.firstname},
           ${student.lastname}`;
    }
    else {
        throw new Error('Student not found!');  <---当学生信息错误时抛出异常
    }
}
showStudent('444-44-4444');  <---使用SSN号444-44-4444作为参数执行函数，结果会显示在页面上
```

我们可以将函数拆解成一个个具有单一职责的短函数，减少副作用的数量，使得代码变得更加灵活和容易维护。有了可以重用的组件，增加了代码的可读性。

分解后的代码我们会涉及到柯里化的概念，柯里化可以允许部分地传递函数参数，以便将函数的参数减少为一个。在此不做过多展开，后续章节会涉及。

```js
var find = curry(function (db, id) {
    var obj = db.get(id);
    if(obj === null) {
       throw new Error('Object not found!');
    }
    return obj;
});

var csv = (student) {
   return `${student.ssn}, ${student.firstname}, ${student.lastname}`;
};

var append = curry(function (elementId, info) {
   document.querySelector(elementId).innerHTML = info;
});

var showStudent = run(
   append('#student-info'),  <---部分设置HTML元素的ID
   csv,
   find(db));  <---部分设置查找对象为学生表

showStudent('444-44-4444');
```

其实 javascript 中还有一个很容易带来副作用的用法 this，这个会导致我们函数作用域的变化，大家在开发过程中要注意。例如以下的例子：

```js
  var x = 2;
	var y = 
    { 
      x: 3, 
      z: (function (x) { 
        this.x *= x; 
        return function (n) {
          this.x *= n; 
          x += 3; 
          console.log(x); 
        } 
      })(x),
    }
	  var m = y.z;
	  m(4);
	  y.z(5);
    console.log(x, y.z);
```

### 引用透明
一个函数对于相同的输入始终产生的相同的结果，那么这个函数就是引用透明的。下面就是一个最简单最直观的例子，能说明我们函数的引用透明性。

```js
var counter = 0;
function increment() {
    return ++counter;
}
```

```js
  var increment = counter => counter + 1;
```
通过这个例子能够很好的解释引用透明的概念，但是我们在开发中还是要注意引用类型的入参，在对引用类型的参数操作时一定要谨慎，不要在不经意间改变他们。

> 纯度: 一个函数的参数和返回值之间映射的纯的关系

> 状态系统的模型”： Program = [Input] + [func1, func2, func3, ...] -> Output

### 不可变性

不可变性是指创建后不能更改的数据，我们在开发中运用的很多会改变原有数据的函数，一定要特别注意。
例如，sort,splice等

强迫自己去思考纯的操作，将函数看作永不会修改数据的闭合功能单元，必然可以减少这种潜在bug的可能性。理解这些核心的原则非常重要，它可以让代码发挥出函数式的诸多优势，从而引导你走向克服复杂性的函数式编程之路。

> 函数式编程是指为创建不可变的程序，通过消除外部可见的副作用，来对纯函数的声明式的求值过程。

## 函数式编程的优点

函数式编程能给我们在开发过程中带来诸多好处，我们下面分几步来讲解函数式编程的优点

### 鼓励复杂任务的分解
我们在处理复杂的功能逻辑的时候，更好的是将我们复杂的逻辑不断的分解成单一功能、相互独立的函数，然后再通过组合将各个函数关联起来。这样的函数式编程可以让我们的代码变得更加高效和模块化。

#### compose 和 pipe 函数的使用

组合和管道是我们函数式编程中至关重要的两个概念。函数的组合和管道提高了函数的抽象层次，可以让我们在代码中清晰地勾勒所有步骤，但又不暴露然后底层细节。

```js
const compose = (...fns)=>val=>fns.reverse().reduce((acc,fn)=>fn(acc),val);
const pipe = (...fns)=>val=>fns.reduce((acc,fn)=>fn(acc),val);
```

### 使用流式链来处理数据
我们最开始接触链式操作是通过jquery的链式操作，我们可以方便的通过链式来处理一条完整的逻辑，在jquery中实现链式操作的底层原理是通过返回this来实现的。而对于我们在函数式编程中实现链式操作跟其也有相似性，但是实现的过程要谨记我们上文提到的纯函数等概念。

以下是命令式编程和链式操作的一个对比

```js
// bad 
var totalGrades = 0;
var totalStudentsFound = 0;
for(let i = 0; i < enrollment.length; i++) {
    let student = enrollment [i];
    if(student !== null) {
       if(student.enrolled > 1) {
          totalGrades+= student.grade;
          totalStudentsFound++;
       }
    }
}
var average = totalGrades / totalStudentsFound; //-> 90”

// good 
_.chain(enrollment)
  .filter(student => student.enrolled > 1)
  .pluck('grade')
  .average()
  .value(); //-> 90  <---调用 _.value() 会触发整个链上的所有操作
```

虽然链式操作能给我们带来足够的方便和可读性，但是如果不考虑整体，一味的使用链式操作也会给我们带来一些副作用，比如链式操作中异常的处理，又比如对于复杂的数据处理，在一系列的链式操作中没有办法打断点去调试中间数据，这就要求我们在使用链式操作的时候要更加的谨慎，需要我们考虑的更加全面。任何的技术都不是银弹，不要手里有了一把锤子，看什么都像钉子。

### 复杂异步应用中的响应
响应式编程应该是我们当下热门前端框架都应用的编程概念。从anjularJs中的脏检查，到react中使用虚拟DOM和协调算法实现高效的响应式更新，再到vue中通过劫持对象来实现对数据的监听和更新，无一不在用响应式编程的来实现底层机制。

对于三大框架对于Observable的实现原理，也是我们前端开发人员必备的知识技能，至少是面试中不可避免的一道大题。

## 写在最后
函数式编程对于我们现在的开发中并不是一个全有或全无的方案，我们现有阶段没有必要完全的面向函数式编程，在我们现有的框架体系内，比如一些采用jquery,angularJs的项目，我们也可以逐步的采用函数式编程，借鉴其中的优点让我们的代码变得更加可读，更好的维护，更加的优雅。

对于我们新的框架，比如我们的Rhino，应该完全的面向函数式编程，让我们的代码变得更加模块化和通用。当然，任何技术的使用都要考虑其最终实现的场景，我们要谨慎，我们不能矫枉过正。记住我我们的锤子！

![锤子](../img/hammer.jpg)

## 附件
![锤子](../img/mind/function1.png)
